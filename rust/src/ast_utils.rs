/*
* Copyright (c) 2024. caoccao.com Sam Cao
* All rights reserved.

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

* http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

use jni::objects::{GlobalRef, JMethodID, JObject, JString};
use jni::signature::{Primitive, ReturnType};
use jni::sys::jvalue;
use jni::JNIEnv;

use crate::jni_utils::*;
use crate::span_utils::{ByteToIndexMap, RegisterWithMap, ToJavaWithMap};

use deno_ast::swc::ast::*;
use deno_ast::swc::common::{Spanned, DUMMY_SP};
use num_bigint::{BigInt as BigIntValue, BigUint, Sign};

use std::ptr::null_mut;

/*
 * This file is 99% code generated.
 * Do not edit this file unless you know what you are doing.
 */

#[allow(dead_code)]
struct JavaISwc4jAst {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAst {}
unsafe impl Sync for JavaISwc4jAst {}

#[allow(dead_code)]
impl JavaISwc4jAst {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAst")
      .expect("Couldn't find enum ISwc4jAst");
    let class = env.new_global_ref(class).expect("Couldn't globalize enum ISwc4jAst");
    let method_get_type = env
      .get_method_id(&class, "getType", "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;")
      .expect("Couldn't find method ISwc4jAst.getType");
    JavaISwc4jAst { class, method_get_type }
  }

  pub fn get_type<'local, 'a>(&self, env: &mut JNIEnv<'local>, obj: &JObject<'_>) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(env, obj, self.method_get_type, &[], "List get_type()");
    return_value
  }
}

static mut JAVA_CLASS_I_AST: Option<JavaISwc4jAst> = None;

pub fn init<'local>(env: &mut JNIEnv<'local>) {
  unsafe {
    JAVA_CLASS_I_AST = Some(JavaISwc4jAst::new(env));
    init_ast_classes(env);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BigInt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_sign = self.value.sign().to_java(env);
    let optional_raw = self.raw.as_ref().map(|node| node.as_str().to_owned());
    let return_value =
      unsafe { JAVA_CLASS_BIG_INT.as_ref().unwrap() }.construct(env, &java_sign, &optional_raw, &java_span_ex);
    delete_local_ref!(env, java_sign);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl FromJava for BigInt {
  fn from_java<'local>(env: &mut JNIEnv<'local>, obj: &JObject<'_>) -> Self {
    let java_class = unsafe { JAVA_CLASS_BIG_INT.as_ref().unwrap() };
    let java_sign = java_class.get_sign(env, &obj);
    let sign = Sign::from_java(env, &java_sign);
    let java_optional_raw = java_class.get_raw(env, &obj);
    let raw = if optional_is_present(env, &java_optional_raw) {
      let java_raw = optional_get(env, &java_optional_raw);
      let raw = jstring_to_string!(env, java_raw.as_raw());
      delete_local_ref!(env, java_raw);
      Some(raw)
    } else {
      None
    };
    let data: BigUint = raw
      .as_ref()
      .map_or_else(|| Default::default(), |raw| BigUint::parse_bytes(&raw.as_bytes(), 10))
      .unwrap_or_else(|| Default::default());
    delete_local_ref!(env, java_sign);
    delete_local_ref!(env, java_optional_raw);
    let value = BigIntValue::from_biguint(sign, data);
    BigInt {
      span: DUMMY_SP,
      value : Box::new(value),
      raw: raw.map(|raw| raw.into()),
    }
  }
}

impl FromJava for Str {
  fn from_java<'local>(env: &mut JNIEnv<'local>, obj: &JObject<'_>) -> Self {
    let java_class = unsafe { JAVA_CLASS_STR.as_ref().unwrap() };
    let value = java_class.get_value(env, obj);
    let java_optional_raw = java_class.get_raw(env, obj);
    let raw = if optional_is_present(env, &java_optional_raw) {
      let java_raw = optional_get(env, &java_optional_raw);
      let raw = jstring_to_string!(env, java_raw.as_raw());
      delete_local_ref!(env, java_raw);
      Some(raw)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_raw);
    Str {
      span: DUMMY_SP,
      value : value.into(),
      raw: raw.map(|raw| raw.into()),
    }
  }
}

/* JNI Begin */
#[allow(dead_code)]
struct JavaSwc4jAstArrayLit {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elems: JMethodID,
}
unsafe impl Send for JavaSwc4jAstArrayLit {}
unsafe impl Sync for JavaSwc4jAstArrayLit {}

#[allow(dead_code)]
impl JavaSwc4jAstArrayLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstArrayLit")
      .expect("Couldn't find class Swc4jAstArrayLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstArrayLit");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstArrayLit::new");
    let method_get_elems = env
      .get_method_id(
        &class,
        "getElems",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstArrayLit.getElems");
    JavaSwc4jAstArrayLit {
      class,
      method_construct,
      method_get_elems,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elems: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let elems = object_to_jvalue!(elems);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elems, span],
        "Swc4jAstArrayLit construct()"
      );
    return_value
  }

  pub fn get_elems<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elems,
        &[],
        "List get_elems()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstArrayPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elems: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstArrayPat {}
unsafe impl Sync for JavaSwc4jAstArrayPat {}

#[allow(dead_code)]
impl JavaSwc4jAstArrayPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstArrayPat")
      .expect("Couldn't find class Swc4jAstArrayPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstArrayPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstArrayPat::new");
    let method_get_elems = env
      .get_method_id(
        &class,
        "getElems",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstArrayPat.getElems");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstArrayPat.getTypeAnn");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstArrayPat.isOptional");
    JavaSwc4jAstArrayPat {
      class,
      method_construct,
      method_get_elems,
      method_get_type_ann,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elems: &JObject<'_>,
    optional: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let elems = object_to_jvalue!(elems);
    let optional = boolean_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elems, optional, type_ann, span],
        "Swc4jAstArrayPat construct()"
      );
    return_value
  }

  pub fn get_elems<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elems,
        &[],
        "List get_elems()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstArrowExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_params: JMethodID,
  method_get_return_type: JMethodID,
  method_get_type_params: JMethodID,
  method_is_async: JMethodID,
  method_is_generator: JMethodID,
}
unsafe impl Send for JavaSwc4jAstArrowExpr {}
unsafe impl Sync for JavaSwc4jAstArrowExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstArrowExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstArrowExpr")
      .expect("Couldn't find class Swc4jAstArrowExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstArrowExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstBlockStmtOrExpr;ZZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstBlockStmtOrExpr;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getBody");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getParams");
    let method_get_return_type = env
      .get_method_id(
        &class,
        "getReturnType",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getReturnType");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getTypeParams");
    let method_is_async = env
      .get_method_id(
        &class,
        "isAsync",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.isAsync");
    let method_is_generator = env
      .get_method_id(
        &class,
        "isGenerator",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.isGenerator");
    JavaSwc4jAstArrowExpr {
      class,
      method_construct,
      method_get_body,
      method_get_params,
      method_get_return_type,
      method_get_type_params,
      method_is_async,
      method_is_generator,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    body: &JObject<'_>,
    is_async: bool,
    generator: bool,
    type_params: &Option<JObject>,
    return_type: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let body = object_to_jvalue!(body);
    let is_async = boolean_to_jvalue!(is_async);
    let generator = boolean_to_jvalue!(generator);
    let type_params = optional_object_to_jvalue!(type_params);
    let return_type = optional_object_to_jvalue!(return_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, body, is_async, generator, type_params, return_type, span],
        "Swc4jAstArrowExpr construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstBlockStmtOrExpr get_body()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_return_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_return_type,
        &[],
        "Optional get_return_type()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_async<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_async,
        &[],
        "boolean is_async()"
      );
    return_value
  }

  pub fn is_generator<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_generator,
        &[],
        "boolean is_generator()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_op: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignExpr {}
unsafe impl Sync for JavaSwc4jAstAssignExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstAssignExpr")
      .expect("Couldn't find class Swc4jAstAssignExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAssignOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstAssignTarget;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstAssignTarget;",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr.getLeft");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAssignOp;",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr.getOp");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr.getRight");
    JavaSwc4jAstAssignExpr {
      class,
      method_construct,
      method_get_left,
      method_get_op,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, left, right, span],
        "Swc4jAstAssignExpr construct()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstAssignTarget get_left()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstAssignOp get_op()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignPat {}
unsafe impl Sync for JavaSwc4jAstAssignPat {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstAssignPat")
      .expect("Couldn't find class Swc4jAstAssignPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignPat::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstAssignPat.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAssignPat.getRight");
    JavaSwc4jAstAssignPat {
      class,
      method_construct,
      method_get_left,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[left, right, span],
        "Swc4jAstAssignPat construct()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstPat get_left()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignPatProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignPatProp {}
unsafe impl Sync for JavaSwc4jAstAssignPatProp {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignPatProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstAssignPatProp")
      .expect("Couldn't find class Swc4jAstAssignPatProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignPatProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/pat/Swc4jAstBindingIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignPatProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/pat/Swc4jAstBindingIdent;",
      )
      .expect("Couldn't find method Swc4jAstAssignPatProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAssignPatProp.getValue");
    JavaSwc4jAstAssignPatProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstAssignPatProp construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstBindingIdent get_key()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignProp {}
unsafe impl Sync for JavaSwc4jAstAssignProp {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstAssignProp")
      .expect("Couldn't find class Swc4jAstAssignProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstAssignProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAssignProp.getValue");
    JavaSwc4jAstAssignProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstAssignProp construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstIdent get_key()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "ISwc4jAstExpr get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAutoAccessor {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_value: JMethodID,
  method_is_definite: JMethodID,
  method_is_override: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAutoAccessor {}
unsafe impl Sync for JavaSwc4jAstAutoAccessor {}

#[allow(dead_code)]
impl JavaSwc4jAstAutoAccessor {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstAutoAccessor")
      .expect("Couldn't find class Swc4jAstAutoAccessor");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAutoAccessor");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstKey;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getDecorators");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstKey;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getTypeAnn");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getValue");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isDefinite");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isOverride");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isStatic");
    JavaSwc4jAstAutoAccessor {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_key,
      method_get_type_ann,
      method_get_value,
      method_is_definite,
      method_is_override,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    type_ann: &Option<JObject>,
    is_static: bool,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    is_override: bool,
    definite: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let is_static = boolean_to_jvalue!(is_static);
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_override = boolean_to_jvalue!(is_override);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, type_ann, is_static, decorators, accessibility, is_override, definite, span],
        "Swc4jAstAutoAccessor construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstKey get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAwaitExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAwaitExpr {}
unsafe impl Sync for JavaSwc4jAstAwaitExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstAwaitExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstAwaitExpr")
      .expect("Couldn't find class Swc4jAstAwaitExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAwaitExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAwaitExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAwaitExpr.getArg");
    JavaSwc4jAstAwaitExpr {
      class,
      method_construct,
      method_get_arg,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, span],
        "Swc4jAstAwaitExpr construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBigInt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_sign: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBigInt {}
unsafe impl Sync for JavaSwc4jAstBigInt {}

#[allow(dead_code)]
impl JavaSwc4jAstBigInt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstBigInt")
      .expect("Couldn't find class Swc4jAstBigInt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBigInt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBigIntSign;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBigInt::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstBigInt.getRaw");
    let method_get_sign = env
      .get_method_id(
        &class,
        "getSign",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBigIntSign;",
      )
      .expect("Couldn't find method Swc4jAstBigInt.getSign");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/math/BigInteger;",
      )
      .expect("Couldn't find method Swc4jAstBigInt.getValue");
    JavaSwc4jAstBigInt {
      class,
      method_construct,
      method_get_raw,
      method_get_sign,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    sign: &JObject<'_>,
    raw: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let sign = object_to_jvalue!(sign);
    let java_raw = optional_string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[sign, raw, span],
        "Swc4jAstBigInt construct()"
      );
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_raw<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "Optional get_raw()"
      );
    return_value
  }

  pub fn get_sign<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_sign,
        &[],
        "Swc4jAstBigIntSign get_sign()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "BigInteger get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBinExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_op: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBinExpr {}
unsafe impl Sync for JavaSwc4jAstBinExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstBinExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstBinExpr")
      .expect("Couldn't find class Swc4jAstBinExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBinExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBinaryOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBinExpr::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstBinExpr.getLeft");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBinaryOp;",
      )
      .expect("Couldn't find method Swc4jAstBinExpr.getOp");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstBinExpr.getRight");
    JavaSwc4jAstBinExpr {
      class,
      method_construct,
      method_get_left,
      method_get_op,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, left, right, span],
        "Swc4jAstBinExpr construct()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstExpr get_left()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstBinaryOp get_op()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBindingIdent {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBindingIdent {}
unsafe impl Sync for JavaSwc4jAstBindingIdent {}

#[allow(dead_code)]
impl JavaSwc4jAstBindingIdent {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstBindingIdent")
      .expect("Couldn't find class Swc4jAstBindingIdent");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBindingIdent");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBindingIdent::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstBindingIdent.getId");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstBindingIdent.getTypeAnn");
    JavaSwc4jAstBindingIdent {
      class,
      method_construct,
      method_get_id,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, type_ann, span],
        "Swc4jAstBindingIdent construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBlockStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_stmts: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBlockStmt {}
unsafe impl Sync for JavaSwc4jAstBlockStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstBlockStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt")
      .expect("Couldn't find class Swc4jAstBlockStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBlockStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBlockStmt::new");
    let method_get_stmts = env
      .get_method_id(
        &class,
        "getStmts",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstBlockStmt.getStmts");
    JavaSwc4jAstBlockStmt {
      class,
      method_construct,
      method_get_stmts,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    stmts: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let stmts = object_to_jvalue!(stmts);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[stmts, span],
        "Swc4jAstBlockStmt construct()"
      );
    return_value
  }

  pub fn get_stmts<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_stmts,
        &[],
        "List get_stmts()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBool {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBool {}
unsafe impl Sync for JavaSwc4jAstBool {}

#[allow(dead_code)]
impl JavaSwc4jAstBool {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstBool")
      .expect("Couldn't find class Swc4jAstBool");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBool");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBool::new");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstBool.getValue");
    JavaSwc4jAstBool {
      class,
      method_construct,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let value = boolean_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, span],
        "Swc4jAstBool construct()"
      );
    return_value
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_get_value,
        &[],
        "boolean get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBreakStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_label: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBreakStmt {}
unsafe impl Sync for JavaSwc4jAstBreakStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstBreakStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstBreakStmt")
      .expect("Couldn't find class Swc4jAstBreakStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBreakStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBreakStmt::new");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstBreakStmt.getLabel");
    JavaSwc4jAstBreakStmt {
      class,
      method_construct,
      method_get_label,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let label = optional_object_to_jvalue!(label);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, span],
        "Swc4jAstBreakStmt construct()"
      );
    return_value
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Optional get_label()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstCallExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_args: JMethodID,
  method_get_callee: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstCallExpr {}
unsafe impl Sync for JavaSwc4jAstCallExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstCallExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstCallExpr")
      .expect("Couldn't find class Swc4jAstCallExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstCallExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstCallee;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstCallExpr::new");
    let method_get_args = env
      .get_method_id(
        &class,
        "getArgs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getArgs");
    let method_get_callee = env
      .get_method_id(
        &class,
        "getCallee",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstCallee;",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getCallee");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getTypeArgs");
    JavaSwc4jAstCallExpr {
      class,
      method_construct,
      method_get_args,
      method_get_callee,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    callee: &JObject<'_>,
    args: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let callee = object_to_jvalue!(callee);
    let args = object_to_jvalue!(args);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[callee, args, type_args, span],
        "Swc4jAstCallExpr construct()"
      );
    return_value
  }

  pub fn get_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_args,
        &[],
        "List get_args()"
      );
    return_value
  }

  pub fn get_callee<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_callee,
        &[],
        "ISwc4jAstCallee get_callee()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstCatchClause {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstCatchClause {}
unsafe impl Sync for JavaSwc4jAstCatchClause {}

#[allow(dead_code)]
impl JavaSwc4jAstCatchClause {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstCatchClause")
      .expect("Couldn't find class Swc4jAstCatchClause");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstCatchClause");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstCatchClause::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;",
      )
      .expect("Couldn't find method Swc4jAstCatchClause.getBody");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstCatchClause.getParam");
    JavaSwc4jAstCatchClause {
      class,
      method_construct,
      method_get_body,
      method_get_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    param: &Option<JObject>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let param = optional_object_to_jvalue!(param);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[param, body, span],
        "Swc4jAstCatchClause construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Swc4jAstBlockStmt get_body()"
      );
    return_value
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "Optional get_param()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClass {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_decorators: JMethodID,
  method_get_implements: JMethodID,
  method_get_super_class: JMethodID,
  method_get_super_type_params: JMethodID,
  method_get_type_params: JMethodID,
  method_is_abstract: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClass {}
unsafe impl Sync for JavaSwc4jAstClass {}

#[allow(dead_code)]
impl JavaSwc4jAstClass {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass")
      .expect("Couldn't find class Swc4jAstClass");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClass");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClass::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClass.getBody");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClass.getDecorators");
    let method_get_implements = env
      .get_method_id(
        &class,
        "getImplements",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClass.getImplements");
    let method_get_super_class = env
      .get_method_id(
        &class,
        "getSuperClass",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClass.getSuperClass");
    let method_get_super_type_params = env
      .get_method_id(
        &class,
        "getSuperTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClass.getSuperTypeParams");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClass.getTypeParams");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClass.isAbstract");
    JavaSwc4jAstClass {
      class,
      method_construct,
      method_get_body,
      method_get_decorators,
      method_get_implements,
      method_get_super_class,
      method_get_super_type_params,
      method_get_type_params,
      method_is_abstract,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decorators: &JObject<'_>,
    body: &JObject<'_>,
    super_class: &Option<JObject>,
    is_abstract: bool,
    type_params: &Option<JObject>,
    super_type_params: &Option<JObject>,
    implements: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decorators = object_to_jvalue!(decorators);
    let body = object_to_jvalue!(body);
    let super_class = optional_object_to_jvalue!(super_class);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let type_params = optional_object_to_jvalue!(type_params);
    let super_type_params = optional_object_to_jvalue!(super_type_params);
    let implements = object_to_jvalue!(implements);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decorators, body, super_class, is_abstract, type_params, super_type_params, implements, span],
        "Swc4jAstClass construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_implements<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_implements,
        &[],
        "List get_implements()"
      );
    return_value
  }

  pub fn get_super_class<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_super_class,
        &[],
        "Optional get_super_class()"
      );
    return_value
  }

  pub fn get_super_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_super_type_params,
        &[],
        "Optional get_super_type_params()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_clazz: JMethodID,
  method_get_ident: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassDecl {}
unsafe impl Sync for JavaSwc4jAstClassDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstClassDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstClassDecl")
      .expect("Couldn't find class Swc4jAstClassDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassDecl::new");
    let method_get_clazz = env
      .get_method_id(
        &class,
        "getClazz",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;",
      )
      .expect("Couldn't find method Swc4jAstClassDecl.getClazz");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstClassDecl.getIdent");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassDecl.isDeclare");
    JavaSwc4jAstClassDecl {
      class,
      method_construct,
      method_get_clazz,
      method_get_ident,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &JObject<'_>,
    declare: bool,
    clazz: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ident = object_to_jvalue!(ident);
    let declare = boolean_to_jvalue!(declare);
    let clazz = object_to_jvalue!(clazz);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, declare, clazz, span],
        "Swc4jAstClassDecl construct()"
      );
    return_value
  }

  pub fn get_clazz<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_clazz,
        &[],
        "Swc4jAstClass get_clazz()"
      );
    return_value
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Swc4jAstIdent get_ident()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_clazz: JMethodID,
  method_get_ident: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassExpr {}
unsafe impl Sync for JavaSwc4jAstClassExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstClassExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstClassExpr")
      .expect("Couldn't find class Swc4jAstClassExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassExpr::new");
    let method_get_clazz = env
      .get_method_id(
        &class,
        "getClazz",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;",
      )
      .expect("Couldn't find method Swc4jAstClassExpr.getClazz");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassExpr.getIdent");
    JavaSwc4jAstClassExpr {
      class,
      method_construct,
      method_get_clazz,
      method_get_ident,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &Option<JObject>,
    clazz: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ident = optional_object_to_jvalue!(ident);
    let clazz = object_to_jvalue!(clazz);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, clazz, span],
        "Swc4jAstClassExpr construct()"
      );
    return_value
  }

  pub fn get_clazz<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_clazz,
        &[],
        "Swc4jAstClass get_clazz()"
      );
    return_value
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Optional get_ident()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassMethod {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_function: JMethodID,
  method_get_key: JMethodID,
  method_get_kind: JMethodID,
  method_is_abstract: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassMethod {}
unsafe impl Sync for JavaSwc4jAstClassMethod {}

#[allow(dead_code)]
impl JavaSwc4jAstClassMethod {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstClassMethod")
      .expect("Couldn't find class Swc4jAstClassMethod");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassMethod");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;ZLcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassMethod::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getAccessibility");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getFunction");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getKey");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getKind");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isAbstract");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isOverride");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isStatic");
    JavaSwc4jAstClassMethod {
      class,
      method_construct,
      method_get_accessibility,
      method_get_function,
      method_get_key,
      method_get_kind,
      method_is_abstract,
      method_is_optional,
      method_is_override,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    function: &JObject<'_>,
    kind: &JObject<'_>,
    is_static: bool,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    optional: bool,
    is_override: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let function = object_to_jvalue!(function);
    let kind = object_to_jvalue!(kind);
    let is_static = boolean_to_jvalue!(is_static);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, function, kind, is_static, accessibility, is_abstract, optional, is_override, span],
        "Swc4jAstClassMethod construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstMethodKind get_kind()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_value: JMethodID,
  method_is_abstract: JMethodID,
  method_is_declare: JMethodID,
  method_is_definite: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_readonly: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassProp {}
unsafe impl Sync for JavaSwc4jAstClassProp {}

#[allow(dead_code)]
impl JavaSwc4jAstClassProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstClassProp")
      .expect("Couldn't find class Swc4jAstClassProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassProp::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getDecorators");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getTypeAnn");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getValue");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isAbstract");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isDeclare");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isDefinite");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isOverride");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isReadonly");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isStatic");
    JavaSwc4jAstClassProp {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_key,
      method_get_type_ann,
      method_get_value,
      method_is_abstract,
      method_is_declare,
      method_is_definite,
      method_is_optional,
      method_is_override,
      method_is_readonly,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    type_ann: &Option<JObject>,
    is_static: bool,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    optional: bool,
    is_override: bool,
    readonly: bool,
    declare: bool,
    definite: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let is_static = boolean_to_jvalue!(is_static);
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let readonly = boolean_to_jvalue!(readonly);
    let declare = boolean_to_jvalue!(declare);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, type_ann, is_static, decorators, accessibility, is_abstract, optional, is_override, readonly, declare, definite, span],
        "Swc4jAstClassProp construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstComputedPropName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstComputedPropName {}
unsafe impl Sync for JavaSwc4jAstComputedPropName {}

#[allow(dead_code)]
impl JavaSwc4jAstComputedPropName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstComputedPropName")
      .expect("Couldn't find class Swc4jAstComputedPropName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstComputedPropName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstComputedPropName::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstComputedPropName.getExpr");
    JavaSwc4jAstComputedPropName {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstComputedPropName construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstCondExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_alt: JMethodID,
  method_get_cons: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstCondExpr {}
unsafe impl Sync for JavaSwc4jAstCondExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstCondExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstCondExpr")
      .expect("Couldn't find class Swc4jAstCondExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstCondExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstCondExpr::new");
    let method_get_alt = env
      .get_method_id(
        &class,
        "getAlt",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstCondExpr.getAlt");
    let method_get_cons = env
      .get_method_id(
        &class,
        "getCons",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstCondExpr.getCons");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstCondExpr.getTest");
    JavaSwc4jAstCondExpr {
      class,
      method_construct,
      method_get_alt,
      method_get_cons,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    cons: &JObject<'_>,
    alt: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let cons = object_to_jvalue!(cons);
    let alt = object_to_jvalue!(alt);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, cons, alt, span],
        "Swc4jAstCondExpr construct()"
      );
    return_value
  }

  pub fn get_alt<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_alt,
        &[],
        "ISwc4jAstExpr get_alt()"
      );
    return_value
  }

  pub fn get_cons<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cons,
        &[],
        "ISwc4jAstExpr get_cons()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstConstructor {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_body: JMethodID,
  method_get_key: JMethodID,
  method_get_params: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstConstructor {}
unsafe impl Sync for JavaSwc4jAstConstructor {}

#[allow(dead_code)]
impl JavaSwc4jAstConstructor {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstConstructor")
      .expect("Couldn't find class Swc4jAstConstructor");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstConstructor");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstConstructor::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getAccessibility");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getBody");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getKey");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getParams");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstConstructor.isOptional");
    JavaSwc4jAstConstructor {
      class,
      method_construct,
      method_get_accessibility,
      method_get_body,
      method_get_key,
      method_get_params,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    params: &JObject<'_>,
    body: &Option<JObject>,
    accessibility: &Option<JObject>,
    optional: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let params = object_to_jvalue!(params);
    let body = optional_object_to_jvalue!(body);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let optional = boolean_to_jvalue!(optional);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, params, body, accessibility, optional, span],
        "Swc4jAstConstructor construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstContinueStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_label: JMethodID,
}
unsafe impl Send for JavaSwc4jAstContinueStmt {}
unsafe impl Sync for JavaSwc4jAstContinueStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstContinueStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstContinueStmt")
      .expect("Couldn't find class Swc4jAstContinueStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstContinueStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstContinueStmt::new");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstContinueStmt.getLabel");
    JavaSwc4jAstContinueStmt {
      class,
      method_construct,
      method_get_label,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let label = optional_object_to_jvalue!(label);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, span],
        "Swc4jAstContinueStmt construct()"
      );
    return_value
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Optional get_label()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstDebuggerStmt {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstDebuggerStmt {}
unsafe impl Sync for JavaSwc4jAstDebuggerStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstDebuggerStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstDebuggerStmt")
      .expect("Couldn't find class Swc4jAstDebuggerStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstDebuggerStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstDebuggerStmt::new");
    JavaSwc4jAstDebuggerStmt {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstDebuggerStmt construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstDecorator {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstDecorator {}
unsafe impl Sync for JavaSwc4jAstDecorator {}

#[allow(dead_code)]
impl JavaSwc4jAstDecorator {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstDecorator")
      .expect("Couldn't find class Swc4jAstDecorator");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstDecorator");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstDecorator::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstDecorator.getExpr");
    JavaSwc4jAstDecorator {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstDecorator construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstDoWhileStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstDoWhileStmt {}
unsafe impl Sync for JavaSwc4jAstDoWhileStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstDoWhileStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstDoWhileStmt")
      .expect("Couldn't find class Swc4jAstDoWhileStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstDoWhileStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstDoWhileStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstDoWhileStmt.getBody");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstDoWhileStmt.getTest");
    JavaSwc4jAstDoWhileStmt {
      class,
      method_construct,
      method_get_body,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, body, span],
        "Swc4jAstDoWhileStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstEmptyStmt {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstEmptyStmt {}
unsafe impl Sync for JavaSwc4jAstEmptyStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstEmptyStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstEmptyStmt")
      .expect("Couldn't find class Swc4jAstEmptyStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstEmptyStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstEmptyStmt::new");
    JavaSwc4jAstEmptyStmt {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstEmptyStmt construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportAll {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_src: JMethodID,
  method_get_with: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportAll {}
unsafe impl Sync for JavaSwc4jAstExportAll {}

#[allow(dead_code)]
impl JavaSwc4jAstExportAll {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportAll")
      .expect("Couldn't find class Swc4jAstExportAll");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportAll");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;ZLcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportAll::new");
    let method_get_src = env
      .get_method_id(
        &class,
        "getSrc",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstExportAll.getSrc");
    let method_get_with = env
      .get_method_id(
        &class,
        "getWith",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstExportAll.getWith");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstExportAll.isTypeOnly");
    JavaSwc4jAstExportAll {
      class,
      method_construct,
      method_get_src,
      method_get_with,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    src: &JObject<'_>,
    type_only: bool,
    with: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let src = object_to_jvalue!(src);
    let type_only = boolean_to_jvalue!(type_only);
    let with = optional_object_to_jvalue!(with);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[src, type_only, with, span],
        "Swc4jAstExportAll construct()"
      );
    return_value
  }

  pub fn get_src<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_src,
        &[],
        "Swc4jAstStr get_src()"
      );
    return_value
  }

  pub fn get_with<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_with,
        &[],
        "Optional get_with()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decl: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDecl {}
unsafe impl Sync for JavaSwc4jAstExportDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDecl")
      .expect("Couldn't find class Swc4jAstExportDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDecl::new");
    let method_get_decl = env
      .get_method_id(
        &class,
        "getDecl",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDecl;",
      )
      .expect("Couldn't find method Swc4jAstExportDecl.getDecl");
    JavaSwc4jAstExportDecl {
      class,
      method_construct,
      method_get_decl,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decl: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decl = object_to_jvalue!(decl);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decl, span],
        "Swc4jAstExportDecl construct()"
      );
    return_value
  }

  pub fn get_decl<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decl,
        &[],
        "ISwc4jAstDecl get_decl()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDefaultDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decl: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDefaultDecl {}
unsafe impl Sync for JavaSwc4jAstExportDefaultDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDefaultDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDefaultDecl")
      .expect("Couldn't find class Swc4jAstExportDefaultDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDefaultDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDefaultDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultDecl::new");
    let method_get_decl = env
      .get_method_id(
        &class,
        "getDecl",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDefaultDecl;",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultDecl.getDecl");
    JavaSwc4jAstExportDefaultDecl {
      class,
      method_construct,
      method_get_decl,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decl: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decl = object_to_jvalue!(decl);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decl, span],
        "Swc4jAstExportDefaultDecl construct()"
      );
    return_value
  }

  pub fn get_decl<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decl,
        &[],
        "ISwc4jAstDefaultDecl get_decl()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDefaultExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDefaultExpr {}
unsafe impl Sync for JavaSwc4jAstExportDefaultExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDefaultExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDefaultExpr")
      .expect("Couldn't find class Swc4jAstExportDefaultExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDefaultExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultExpr.getExpr");
    JavaSwc4jAstExportDefaultExpr {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstExportDefaultExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDefaultSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exported: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDefaultSpecifier {}
unsafe impl Sync for JavaSwc4jAstExportDefaultSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDefaultSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDefaultSpecifier")
      .expect("Couldn't find class Swc4jAstExportDefaultSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDefaultSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultSpecifier::new");
    let method_get_exported = env
      .get_method_id(
        &class,
        "getExported",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultSpecifier.getExported");
    JavaSwc4jAstExportDefaultSpecifier {
      class,
      method_construct,
      method_get_exported,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exported: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let exported = object_to_jvalue!(exported);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exported, span],
        "Swc4jAstExportDefaultSpecifier construct()"
      );
    return_value
  }

  pub fn get_exported<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exported,
        &[],
        "Swc4jAstIdent get_exported()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportNamedSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exported: JMethodID,
  method_get_orig: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportNamedSpecifier {}
unsafe impl Sync for JavaSwc4jAstExportNamedSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstExportNamedSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportNamedSpecifier")
      .expect("Couldn't find class Swc4jAstExportNamedSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportNamedSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier::new");
    let method_get_exported = env
      .get_method_id(
        &class,
        "getExported",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier.getExported");
    let method_get_orig = env
      .get_method_id(
        &class,
        "getOrig",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier.getOrig");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier.isTypeOnly");
    JavaSwc4jAstExportNamedSpecifier {
      class,
      method_construct,
      method_get_exported,
      method_get_orig,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    orig: &JObject<'_>,
    exported: &Option<JObject>,
    type_only: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let orig = object_to_jvalue!(orig);
    let exported = optional_object_to_jvalue!(exported);
    let type_only = boolean_to_jvalue!(type_only);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[orig, exported, type_only, span],
        "Swc4jAstExportNamedSpecifier construct()"
      );
    return_value
  }

  pub fn get_exported<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exported,
        &[],
        "Optional get_exported()"
      );
    return_value
  }

  pub fn get_orig<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_orig,
        &[],
        "ISwc4jAstModuleExportName get_orig()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportNamespaceSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportNamespaceSpecifier {}
unsafe impl Sync for JavaSwc4jAstExportNamespaceSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstExportNamespaceSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportNamespaceSpecifier")
      .expect("Couldn't find class Swc4jAstExportNamespaceSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportNamespaceSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportNamespaceSpecifier::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;",
      )
      .expect("Couldn't find method Swc4jAstExportNamespaceSpecifier.getName");
    JavaSwc4jAstExportNamespaceSpecifier {
      class,
      method_construct,
      method_get_name,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, span],
        "Swc4jAstExportNamespaceSpecifier construct()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstModuleExportName get_name()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExprOrSpread {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_spread: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExprOrSpread {}
unsafe impl Sync for JavaSwc4jAstExprOrSpread {}

#[allow(dead_code)]
impl JavaSwc4jAstExprOrSpread {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstExprOrSpread")
      .expect("Couldn't find class Swc4jAstExprOrSpread");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExprOrSpread");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExprOrSpread::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstExprOrSpread.getExpr");
    let method_get_spread = env
      .get_method_id(
        &class,
        "getSpread",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstExprOrSpread.getSpread");
    JavaSwc4jAstExprOrSpread {
      class,
      method_construct,
      method_get_expr,
      method_get_spread,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    spread: &Option<JObject>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let spread = optional_object_to_jvalue!(spread);
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[spread, expr, span],
        "Swc4jAstExprOrSpread construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_spread<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_spread,
        &[],
        "Optional get_spread()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExprStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExprStmt {}
unsafe impl Sync for JavaSwc4jAstExprStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstExprStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstExprStmt")
      .expect("Couldn't find class Swc4jAstExprStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExprStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExprStmt::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstExprStmt.getExpr");
    JavaSwc4jAstExprStmt {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstExprStmt construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstFnDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_function: JMethodID,
  method_get_ident: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstFnDecl {}
unsafe impl Sync for JavaSwc4jAstFnDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstFnDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstFnDecl")
      .expect("Couldn't find class Swc4jAstFnDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstFnDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstFnDecl::new");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstFnDecl.getFunction");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstFnDecl.getIdent");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstFnDecl.isDeclare");
    JavaSwc4jAstFnDecl {
      class,
      method_construct,
      method_get_function,
      method_get_ident,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &JObject<'_>,
    declare: bool,
    function: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ident = object_to_jvalue!(ident);
    let declare = boolean_to_jvalue!(declare);
    let function = object_to_jvalue!(function);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, declare, function, span],
        "Swc4jAstFnDecl construct()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Swc4jAstIdent get_ident()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstFnExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_function: JMethodID,
  method_get_ident: JMethodID,
}
unsafe impl Send for JavaSwc4jAstFnExpr {}
unsafe impl Sync for JavaSwc4jAstFnExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstFnExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstFnExpr")
      .expect("Couldn't find class Swc4jAstFnExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstFnExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstFnExpr::new");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstFnExpr.getFunction");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFnExpr.getIdent");
    JavaSwc4jAstFnExpr {
      class,
      method_construct,
      method_get_function,
      method_get_ident,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &Option<JObject>,
    function: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ident = optional_object_to_jvalue!(ident);
    let function = object_to_jvalue!(function);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, function, span],
        "Swc4jAstFnExpr construct()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Optional get_ident()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstForInStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstForInStmt {}
unsafe impl Sync for JavaSwc4jAstForInStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstForInStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstForInStmt")
      .expect("Couldn't find class Swc4jAstForInStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstForInStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstForInStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstForInStmt.getBody");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;",
      )
      .expect("Couldn't find method Swc4jAstForInStmt.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstForInStmt.getRight");
    JavaSwc4jAstForInStmt {
      class,
      method_construct,
      method_get_body,
      method_get_left,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[left, right, body, span],
        "Swc4jAstForInStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstForHead get_left()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstForOfStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
  method_is_await: JMethodID,
}
unsafe impl Send for JavaSwc4jAstForOfStmt {}
unsafe impl Sync for JavaSwc4jAstForOfStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstForOfStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstForOfStmt")
      .expect("Couldn't find class Swc4jAstForOfStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstForOfStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.getBody");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.getRight");
    let method_is_await = env
      .get_method_id(
        &class,
        "isAwait",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.isAwait");
    JavaSwc4jAstForOfStmt {
      class,
      method_construct,
      method_get_body,
      method_get_left,
      method_get_right,
      method_is_await,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    is_await: bool,
    left: &JObject<'_>,
    right: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let is_await = boolean_to_jvalue!(is_await);
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[is_await, left, right, body, span],
        "Swc4jAstForOfStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstForHead get_left()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }

  pub fn is_await<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_await,
        &[],
        "boolean is_await()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstForStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_init: JMethodID,
  method_get_test: JMethodID,
  method_get_update: JMethodID,
}
unsafe impl Send for JavaSwc4jAstForStmt {}
unsafe impl Sync for JavaSwc4jAstForStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstForStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstForStmt")
      .expect("Couldn't find class Swc4jAstForStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstForStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstVarDeclOrExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstForStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getBody");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getInit");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getTest");
    let method_get_update = env
      .get_method_id(
        &class,
        "getUpdate",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getUpdate");
    JavaSwc4jAstForStmt {
      class,
      method_construct,
      method_get_body,
      method_get_init,
      method_get_test,
      method_get_update,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    init: &Option<JObject>,
    test: &Option<JObject>,
    update: &Option<JObject>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let init = optional_object_to_jvalue!(init);
    let test = optional_object_to_jvalue!(test);
    let update = optional_object_to_jvalue!(update);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[init, test, update, body, span],
        "Swc4jAstForStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "Optional get_test()"
      );
    return_value
  }

  pub fn get_update<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_update,
        &[],
        "Optional get_update()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstFunction {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_decorators: JMethodID,
  method_get_params: JMethodID,
  method_get_return_type: JMethodID,
  method_get_type_params: JMethodID,
  method_is_async: JMethodID,
  method_is_generator: JMethodID,
}
unsafe impl Send for JavaSwc4jAstFunction {}
unsafe impl Sync for JavaSwc4jAstFunction {}

#[allow(dead_code)]
impl JavaSwc4jAstFunction {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction")
      .expect("Couldn't find class Swc4jAstFunction");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstFunction");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;ZZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstFunction::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getBody");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getDecorators");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getParams");
    let method_get_return_type = env
      .get_method_id(
        &class,
        "getReturnType",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getReturnType");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getTypeParams");
    let method_is_async = env
      .get_method_id(
        &class,
        "isAsync",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstFunction.isAsync");
    let method_is_generator = env
      .get_method_id(
        &class,
        "isGenerator",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstFunction.isGenerator");
    JavaSwc4jAstFunction {
      class,
      method_construct,
      method_get_body,
      method_get_decorators,
      method_get_params,
      method_get_return_type,
      method_get_type_params,
      method_is_async,
      method_is_generator,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    decorators: &JObject<'_>,
    body: &Option<JObject>,
    is_generator: bool,
    is_async: bool,
    type_params: &Option<JObject>,
    return_type: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let decorators = object_to_jvalue!(decorators);
    let body = optional_object_to_jvalue!(body);
    let is_generator = boolean_to_jvalue!(is_generator);
    let is_async = boolean_to_jvalue!(is_async);
    let type_params = optional_object_to_jvalue!(type_params);
    let return_type = optional_object_to_jvalue!(return_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, decorators, body, is_generator, is_async, type_params, return_type, span],
        "Swc4jAstFunction construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_return_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_return_type,
        &[],
        "Optional get_return_type()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_async<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_async,
        &[],
        "boolean is_async()"
      );
    return_value
  }

  pub fn is_generator<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_generator,
        &[],
        "boolean is_generator()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstGetterProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstGetterProp {}
unsafe impl Sync for JavaSwc4jAstGetterProp {}

#[allow(dead_code)]
impl JavaSwc4jAstGetterProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstGetterProp")
      .expect("Couldn't find class Swc4jAstGetterProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstGetterProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstGetterProp::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstGetterProp.getBody");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstGetterProp.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstGetterProp.getTypeAnn");
    JavaSwc4jAstGetterProp {
      class,
      method_construct,
      method_get_body,
      method_get_key,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    type_ann: &Option<JObject>,
    body: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let body = optional_object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, type_ann, body, span],
        "Swc4jAstGetterProp construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstIdent {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_sym: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstIdent {}
unsafe impl Sync for JavaSwc4jAstIdent {}

#[allow(dead_code)]
impl JavaSwc4jAstIdent {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent")
      .expect("Couldn't find class Swc4jAstIdent");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstIdent");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstIdent::new");
    let method_get_sym = env
      .get_method_id(
        &class,
        "getSym",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstIdent.getSym");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstIdent.isOptional");
    JavaSwc4jAstIdent {
      class,
      method_construct,
      method_get_sym,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    sym: &str,
    optional: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_sym = string_to_jstring!(env, &sym);
    let sym = object_to_jvalue!(java_sym);
    let optional = boolean_to_jvalue!(optional);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[sym, optional, span],
        "Swc4jAstIdent construct()"
      );
    delete_local_ref!(env, java_sym);
    return_value
  }

  pub fn get_sym<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_sym,
        &[],
        "String get_sym()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstIfStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_alt: JMethodID,
  method_get_cons: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstIfStmt {}
unsafe impl Sync for JavaSwc4jAstIfStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstIfStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstIfStmt")
      .expect("Couldn't find class Swc4jAstIfStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstIfStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstIfStmt::new");
    let method_get_alt = env
      .get_method_id(
        &class,
        "getAlt",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstIfStmt.getAlt");
    let method_get_cons = env
      .get_method_id(
        &class,
        "getCons",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstIfStmt.getCons");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstIfStmt.getTest");
    JavaSwc4jAstIfStmt {
      class,
      method_construct,
      method_get_alt,
      method_get_cons,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    cons: &JObject<'_>,
    alt: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let cons = object_to_jvalue!(cons);
    let alt = optional_object_to_jvalue!(alt);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, cons, alt, span],
        "Swc4jAstIfStmt construct()"
      );
    return_value
  }

  pub fn get_alt<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_alt,
        &[],
        "Optional get_alt()"
      );
    return_value
  }

  pub fn get_cons<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cons,
        &[],
        "ISwc4jAstStmt get_cons()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImport {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_phase: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImport {}
unsafe impl Sync for JavaSwc4jAstImport {}

#[allow(dead_code)]
impl JavaSwc4jAstImport {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImport")
      .expect("Couldn't find class Swc4jAstImport");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImport");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImport::new");
    let method_get_phase = env
      .get_method_id(
        &class,
        "getPhase",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;",
      )
      .expect("Couldn't find method Swc4jAstImport.getPhase");
    JavaSwc4jAstImport {
      class,
      method_construct,
      method_get_phase,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    phase: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let phase = object_to_jvalue!(phase);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[phase, span],
        "Swc4jAstImport construct()"
      );
    return_value
  }

  pub fn get_phase<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_phase,
        &[],
        "Swc4jAstImportPhase get_phase()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_phase: JMethodID,
  method_get_specifiers: JMethodID,
  method_get_src: JMethodID,
  method_get_with: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportDecl {}
unsafe impl Sync for JavaSwc4jAstImportDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstImportDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportDecl")
      .expect("Couldn't find class Swc4jAstImportDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;ZLcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportDecl::new");
    let method_get_phase = env
      .get_method_id(
        &class,
        "getPhase",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getPhase");
    let method_get_specifiers = env
      .get_method_id(
        &class,
        "getSpecifiers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getSpecifiers");
    let method_get_src = env
      .get_method_id(
        &class,
        "getSrc",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getSrc");
    let method_get_with = env
      .get_method_id(
        &class,
        "getWith",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getWith");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.isTypeOnly");
    JavaSwc4jAstImportDecl {
      class,
      method_construct,
      method_get_phase,
      method_get_specifiers,
      method_get_src,
      method_get_with,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    specifiers: &JObject<'_>,
    src: &JObject<'_>,
    type_only: bool,
    with: &Option<JObject>,
    phase: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let specifiers = object_to_jvalue!(specifiers);
    let src = object_to_jvalue!(src);
    let type_only = boolean_to_jvalue!(type_only);
    let with = optional_object_to_jvalue!(with);
    let phase = object_to_jvalue!(phase);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[specifiers, src, type_only, with, phase, span],
        "Swc4jAstImportDecl construct()"
      );
    return_value
  }

  pub fn get_phase<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_phase,
        &[],
        "Swc4jAstImportPhase get_phase()"
      );
    return_value
  }

  pub fn get_specifiers<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_specifiers,
        &[],
        "List get_specifiers()"
      );
    return_value
  }

  pub fn get_src<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_src,
        &[],
        "Swc4jAstStr get_src()"
      );
    return_value
  }

  pub fn get_with<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_with,
        &[],
        "Optional get_with()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportDefaultSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_local: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportDefaultSpecifier {}
unsafe impl Sync for JavaSwc4jAstImportDefaultSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstImportDefaultSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportDefaultSpecifier")
      .expect("Couldn't find class Swc4jAstImportDefaultSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportDefaultSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportDefaultSpecifier::new");
    let method_get_local = env
      .get_method_id(
        &class,
        "getLocal",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstImportDefaultSpecifier.getLocal");
    JavaSwc4jAstImportDefaultSpecifier {
      class,
      method_construct,
      method_get_local,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    local: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let local = object_to_jvalue!(local);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[local, span],
        "Swc4jAstImportDefaultSpecifier construct()"
      );
    return_value
  }

  pub fn get_local<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_local,
        &[],
        "Swc4jAstIdent get_local()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportNamedSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_imported: JMethodID,
  method_get_local: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportNamedSpecifier {}
unsafe impl Sync for JavaSwc4jAstImportNamedSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstImportNamedSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportNamedSpecifier")
      .expect("Couldn't find class Swc4jAstImportNamedSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportNamedSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier::new");
    let method_get_imported = env
      .get_method_id(
        &class,
        "getImported",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier.getImported");
    let method_get_local = env
      .get_method_id(
        &class,
        "getLocal",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier.getLocal");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier.isTypeOnly");
    JavaSwc4jAstImportNamedSpecifier {
      class,
      method_construct,
      method_get_imported,
      method_get_local,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    local: &JObject<'_>,
    imported: &Option<JObject>,
    type_only: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let local = object_to_jvalue!(local);
    let imported = optional_object_to_jvalue!(imported);
    let type_only = boolean_to_jvalue!(type_only);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[local, imported, type_only, span],
        "Swc4jAstImportNamedSpecifier construct()"
      );
    return_value
  }

  pub fn get_imported<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_imported,
        &[],
        "Optional get_imported()"
      );
    return_value
  }

  pub fn get_local<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_local,
        &[],
        "Swc4jAstIdent get_local()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportStarAsSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_local: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportStarAsSpecifier {}
unsafe impl Sync for JavaSwc4jAstImportStarAsSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstImportStarAsSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportStarAsSpecifier")
      .expect("Couldn't find class Swc4jAstImportStarAsSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportStarAsSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportStarAsSpecifier::new");
    let method_get_local = env
      .get_method_id(
        &class,
        "getLocal",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstImportStarAsSpecifier.getLocal");
    JavaSwc4jAstImportStarAsSpecifier {
      class,
      method_construct,
      method_get_local,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    local: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let local = object_to_jvalue!(local);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[local, span],
        "Swc4jAstImportStarAsSpecifier construct()"
      );
    return_value
  }

  pub fn get_local<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_local,
        &[],
        "Swc4jAstIdent get_local()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstInvalid {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstInvalid {}
unsafe impl Sync for JavaSwc4jAstInvalid {}

#[allow(dead_code)]
impl JavaSwc4jAstInvalid {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstInvalid")
      .expect("Couldn't find class Swc4jAstInvalid");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstInvalid");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstInvalid::new");
    JavaSwc4jAstInvalid {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstInvalid construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxAttr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxAttr {}
unsafe impl Sync for JavaSwc4jAstJsxAttr {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxAttr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxAttr")
      .expect("Couldn't find class Swc4jAstJsxAttr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxAttr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrValue;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxAttr::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrName;",
      )
      .expect("Couldn't find method Swc4jAstJsxAttr.getName");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstJsxAttr.getValue");
    JavaSwc4jAstJsxAttr {
      class,
      method_construct,
      method_get_name,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    value: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let value = optional_object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, value, span],
        "Swc4jAstJsxAttr construct()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstJsxAttrName get_name()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxClosingElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxClosingElement {}
unsafe impl Sync for JavaSwc4jAstJsxClosingElement {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxClosingElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingElement")
      .expect("Couldn't find class Swc4jAstJsxClosingElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxClosingElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxClosingElement::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;",
      )
      .expect("Couldn't find method Swc4jAstJsxClosingElement.getName");
    JavaSwc4jAstJsxClosingElement {
      class,
      method_construct,
      method_get_name,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, span],
        "Swc4jAstJsxClosingElement construct()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstJsxElementName get_name()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxClosingFragment {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxClosingFragment {}
unsafe impl Sync for JavaSwc4jAstJsxClosingFragment {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxClosingFragment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingFragment")
      .expect("Couldn't find class Swc4jAstJsxClosingFragment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxClosingFragment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxClosingFragment::new");
    JavaSwc4jAstJsxClosingFragment {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstJsxClosingFragment construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_children: JMethodID,
  method_get_closing: JMethodID,
  method_get_opening: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxElement {}
unsafe impl Sync for JavaSwc4jAstJsxElement {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxElement")
      .expect("Couldn't find class Swc4jAstJsxElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningElement;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingElement;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxElement::new");
    let method_get_children = env
      .get_method_id(
        &class,
        "getChildren",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstJsxElement.getChildren");
    let method_get_closing = env
      .get_method_id(
        &class,
        "getClosing",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstJsxElement.getClosing");
    let method_get_opening = env
      .get_method_id(
        &class,
        "getOpening",
        "()Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningElement;",
      )
      .expect("Couldn't find method Swc4jAstJsxElement.getOpening");
    JavaSwc4jAstJsxElement {
      class,
      method_construct,
      method_get_children,
      method_get_closing,
      method_get_opening,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    opening: &JObject<'_>,
    children: &JObject<'_>,
    closing: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let opening = object_to_jvalue!(opening);
    let children = object_to_jvalue!(children);
    let closing = optional_object_to_jvalue!(closing);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[opening, children, closing, span],
        "Swc4jAstJsxElement construct()"
      );
    return_value
  }

  pub fn get_children<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_children,
        &[],
        "List get_children()"
      );
    return_value
  }

  pub fn get_closing<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_closing,
        &[],
        "Optional get_closing()"
      );
    return_value
  }

  pub fn get_opening<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_opening,
        &[],
        "Swc4jAstJsxOpeningElement get_opening()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxEmptyExpr {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxEmptyExpr {}
unsafe impl Sync for JavaSwc4jAstJsxEmptyExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxEmptyExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxEmptyExpr")
      .expect("Couldn't find class Swc4jAstJsxEmptyExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxEmptyExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxEmptyExpr::new");
    JavaSwc4jAstJsxEmptyExpr {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstJsxEmptyExpr construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxExprContainer {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxExprContainer {}
unsafe impl Sync for JavaSwc4jAstJsxExprContainer {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxExprContainer {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxExprContainer")
      .expect("Couldn't find class Swc4jAstJsxExprContainer");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxExprContainer");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxExprContainer::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxExpr;",
      )
      .expect("Couldn't find method Swc4jAstJsxExprContainer.getExpr");
    JavaSwc4jAstJsxExprContainer {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstJsxExprContainer construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstJsxExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxFragment {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_children: JMethodID,
  method_get_closing: JMethodID,
  method_get_opening: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxFragment {}
unsafe impl Sync for JavaSwc4jAstJsxFragment {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxFragment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxFragment")
      .expect("Couldn't find class Swc4jAstJsxFragment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxFragment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningFragment;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingFragment;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment::new");
    let method_get_children = env
      .get_method_id(
        &class,
        "getChildren",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment.getChildren");
    let method_get_closing = env
      .get_method_id(
        &class,
        "getClosing",
        "()Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingFragment;",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment.getClosing");
    let method_get_opening = env
      .get_method_id(
        &class,
        "getOpening",
        "()Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningFragment;",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment.getOpening");
    JavaSwc4jAstJsxFragment {
      class,
      method_construct,
      method_get_children,
      method_get_closing,
      method_get_opening,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    opening: &JObject<'_>,
    children: &JObject<'_>,
    closing: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let opening = object_to_jvalue!(opening);
    let children = object_to_jvalue!(children);
    let closing = object_to_jvalue!(closing);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[opening, children, closing, span],
        "Swc4jAstJsxFragment construct()"
      );
    return_value
  }

  pub fn get_children<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_children,
        &[],
        "List get_children()"
      );
    return_value
  }

  pub fn get_closing<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_closing,
        &[],
        "Swc4jAstJsxClosingFragment get_closing()"
      );
    return_value
  }

  pub fn get_opening<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_opening,
        &[],
        "Swc4jAstJsxOpeningFragment get_opening()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxMemberExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_obj: JMethodID,
  method_get_prop: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxMemberExpr {}
unsafe impl Sync for JavaSwc4jAstJsxMemberExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxMemberExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxMemberExpr")
      .expect("Couldn't find class Swc4jAstJsxMemberExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxMemberExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxObject;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxMemberExpr::new");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxObject;",
      )
      .expect("Couldn't find method Swc4jAstJsxMemberExpr.getObj");
    let method_get_prop = env
      .get_method_id(
        &class,
        "getProp",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstJsxMemberExpr.getProp");
    JavaSwc4jAstJsxMemberExpr {
      class,
      method_construct,
      method_get_obj,
      method_get_prop,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    prop: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let prop = object_to_jvalue!(prop);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, prop, span],
        "Swc4jAstJsxMemberExpr construct()"
      );
    return_value
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "ISwc4jAstJsxObject get_obj()"
      );
    return_value
  }

  pub fn get_prop<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_prop,
        &[],
        "Swc4jAstIdent get_prop()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxNamespacedName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
  method_get_ns: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxNamespacedName {}
unsafe impl Sync for JavaSwc4jAstJsxNamespacedName {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxNamespacedName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxNamespacedName")
      .expect("Couldn't find class Swc4jAstJsxNamespacedName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxNamespacedName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxNamespacedName::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstJsxNamespacedName.getName");
    let method_get_ns = env
      .get_method_id(
        &class,
        "getNs",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstJsxNamespacedName.getNs");
    JavaSwc4jAstJsxNamespacedName {
      class,
      method_construct,
      method_get_name,
      method_get_ns,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ns: &JObject<'_>,
    name: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ns = object_to_jvalue!(ns);
    let name = object_to_jvalue!(name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ns, name, span],
        "Swc4jAstJsxNamespacedName construct()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "Swc4jAstIdent get_name()"
      );
    return_value
  }

  pub fn get_ns<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ns,
        &[],
        "Swc4jAstIdent get_ns()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxOpeningElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_attrs: JMethodID,
  method_get_name: JMethodID,
  method_get_type_args: JMethodID,
  method_is_self_closing: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxOpeningElement {}
unsafe impl Sync for JavaSwc4jAstJsxOpeningElement {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxOpeningElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningElement")
      .expect("Couldn't find class Swc4jAstJsxOpeningElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxOpeningElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;Ljava/util/List;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement::new");
    let method_get_attrs = env
      .get_method_id(
        &class,
        "getAttrs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.getAttrs");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.getName");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.getTypeArgs");
    let method_is_self_closing = env
      .get_method_id(
        &class,
        "isSelfClosing",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.isSelfClosing");
    JavaSwc4jAstJsxOpeningElement {
      class,
      method_construct,
      method_get_attrs,
      method_get_name,
      method_get_type_args,
      method_is_self_closing,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    attrs: &JObject<'_>,
    self_closing: bool,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let attrs = object_to_jvalue!(attrs);
    let self_closing = boolean_to_jvalue!(self_closing);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, attrs, self_closing, type_args, span],
        "Swc4jAstJsxOpeningElement construct()"
      );
    return_value
  }

  pub fn get_attrs<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_attrs,
        &[],
        "List get_attrs()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstJsxElementName get_name()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }

  pub fn is_self_closing<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_self_closing,
        &[],
        "boolean is_self_closing()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxOpeningFragment {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxOpeningFragment {}
unsafe impl Sync for JavaSwc4jAstJsxOpeningFragment {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxOpeningFragment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningFragment")
      .expect("Couldn't find class Swc4jAstJsxOpeningFragment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxOpeningFragment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningFragment::new");
    JavaSwc4jAstJsxOpeningFragment {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstJsxOpeningFragment construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxSpreadChild {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxSpreadChild {}
unsafe impl Sync for JavaSwc4jAstJsxSpreadChild {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxSpreadChild {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxSpreadChild")
      .expect("Couldn't find class Swc4jAstJsxSpreadChild");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxSpreadChild");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxSpreadChild::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstJsxSpreadChild.getExpr");
    JavaSwc4jAstJsxSpreadChild {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstJsxSpreadChild construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxText {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxText {}
unsafe impl Sync for JavaSwc4jAstJsxText {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxText {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstJsxText")
      .expect("Couldn't find class Swc4jAstJsxText");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxText");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxText::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstJsxText.getRaw");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstJsxText.getValue");
    JavaSwc4jAstJsxText {
      class,
      method_construct,
      method_get_raw,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: &str,
    raw: &str,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_value = string_to_jstring!(env, &value);
    let value = object_to_jvalue!(java_value);
    let java_raw = string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, raw, span],
        "Swc4jAstJsxText construct()"
      );
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_raw<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "String get_raw()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "String get_value()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstKeyValuePatProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstKeyValuePatProp {}
unsafe impl Sync for JavaSwc4jAstKeyValuePatProp {}

#[allow(dead_code)]
impl JavaSwc4jAstKeyValuePatProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstKeyValuePatProp")
      .expect("Couldn't find class Swc4jAstKeyValuePatProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstKeyValuePatProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstKeyValuePatProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstKeyValuePatProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstKeyValuePatProp.getValue");
    JavaSwc4jAstKeyValuePatProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstKeyValuePatProp construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "ISwc4jAstPat get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstKeyValueProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstKeyValueProp {}
unsafe impl Sync for JavaSwc4jAstKeyValueProp {}

#[allow(dead_code)]
impl JavaSwc4jAstKeyValueProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstKeyValueProp")
      .expect("Couldn't find class Swc4jAstKeyValueProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstKeyValueProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstKeyValueProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstKeyValueProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstKeyValueProp.getValue");
    JavaSwc4jAstKeyValueProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstKeyValueProp construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "ISwc4jAstExpr get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstLabeledStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_label: JMethodID,
}
unsafe impl Send for JavaSwc4jAstLabeledStmt {}
unsafe impl Sync for JavaSwc4jAstLabeledStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstLabeledStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstLabeledStmt")
      .expect("Couldn't find class Swc4jAstLabeledStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstLabeledStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstLabeledStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstLabeledStmt.getBody");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstLabeledStmt.getLabel");
    JavaSwc4jAstLabeledStmt {
      class,
      method_construct,
      method_get_body,
      method_get_label,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let label = object_to_jvalue!(label);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, body, span],
        "Swc4jAstLabeledStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Swc4jAstIdent get_label()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstMemberExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_obj: JMethodID,
  method_get_prop: JMethodID,
}
unsafe impl Send for JavaSwc4jAstMemberExpr {}
unsafe impl Sync for JavaSwc4jAstMemberExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstMemberExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstMemberExpr")
      .expect("Couldn't find class Swc4jAstMemberExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstMemberExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstMemberProp;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstMemberExpr::new");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstMemberExpr.getObj");
    let method_get_prop = env
      .get_method_id(
        &class,
        "getProp",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstMemberProp;",
      )
      .expect("Couldn't find method Swc4jAstMemberExpr.getProp");
    JavaSwc4jAstMemberExpr {
      class,
      method_construct,
      method_get_obj,
      method_get_prop,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    prop: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let prop = object_to_jvalue!(prop);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, prop, span],
        "Swc4jAstMemberExpr construct()"
      );
    return_value
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "ISwc4jAstExpr get_obj()"
      );
    return_value
  }

  pub fn get_prop<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_prop,
        &[],
        "ISwc4jAstMemberProp get_prop()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstMetaPropExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_kind: JMethodID,
}
unsafe impl Send for JavaSwc4jAstMetaPropExpr {}
unsafe impl Sync for JavaSwc4jAstMetaPropExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstMetaPropExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstMetaPropExpr")
      .expect("Couldn't find class Swc4jAstMetaPropExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstMetaPropExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMetaPropKind;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstMetaPropExpr::new");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMetaPropKind;",
      )
      .expect("Couldn't find method Swc4jAstMetaPropExpr.getKind");
    JavaSwc4jAstMetaPropExpr {
      class,
      method_construct,
      method_get_kind,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    kind: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let kind = object_to_jvalue!(kind);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[kind, span],
        "Swc4jAstMetaPropExpr construct()"
      );
    return_value
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstMetaPropKind get_kind()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstMethodProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_function: JMethodID,
  method_get_key: JMethodID,
}
unsafe impl Send for JavaSwc4jAstMethodProp {}
unsafe impl Sync for JavaSwc4jAstMethodProp {}

#[allow(dead_code)]
impl JavaSwc4jAstMethodProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstMethodProp")
      .expect("Couldn't find class Swc4jAstMethodProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstMethodProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstMethodProp::new");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstMethodProp.getFunction");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstMethodProp.getKey");
    JavaSwc4jAstMethodProp {
      class,
      method_construct,
      method_get_function,
      method_get_key,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    function: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let function = object_to_jvalue!(function);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, function, span],
        "Swc4jAstMethodProp construct()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstModule {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_shebang: JMethodID,
}
unsafe impl Send for JavaSwc4jAstModule {}
unsafe impl Sync for JavaSwc4jAstModule {}

#[allow(dead_code)]
impl JavaSwc4jAstModule {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/program/Swc4jAstModule")
      .expect("Couldn't find class Swc4jAstModule");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstModule");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstModule::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstModule.getBody");
    let method_get_shebang = env
      .get_method_id(
        &class,
        "getShebang",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstModule.getShebang");
    JavaSwc4jAstModule {
      class,
      method_construct,
      method_get_body,
      method_get_shebang,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    shebang: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let java_shebang = optional_string_to_jstring!(env, &shebang);
    let shebang = object_to_jvalue!(java_shebang);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, shebang, span],
        "Swc4jAstModule construct()"
      );
    delete_local_ref!(env, java_shebang);
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }

  pub fn get_shebang<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_shebang,
        &[],
        "Optional get_shebang()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNamedExport {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_specifiers: JMethodID,
  method_get_src: JMethodID,
  method_get_with: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNamedExport {}
unsafe impl Sync for JavaSwc4jAstNamedExport {}

#[allow(dead_code)]
impl JavaSwc4jAstNamedExport {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstNamedExport")
      .expect("Couldn't find class Swc4jAstNamedExport");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNamedExport");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;ZLcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNamedExport::new");
    let method_get_specifiers = env
      .get_method_id(
        &class,
        "getSpecifiers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.getSpecifiers");
    let method_get_src = env
      .get_method_id(
        &class,
        "getSrc",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.getSrc");
    let method_get_with = env
      .get_method_id(
        &class,
        "getWith",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.getWith");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.isTypeOnly");
    JavaSwc4jAstNamedExport {
      class,
      method_construct,
      method_get_specifiers,
      method_get_src,
      method_get_with,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    specifiers: &JObject<'_>,
    src: &Option<JObject>,
    type_only: bool,
    with: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let specifiers = object_to_jvalue!(specifiers);
    let src = optional_object_to_jvalue!(src);
    let type_only = boolean_to_jvalue!(type_only);
    let with = optional_object_to_jvalue!(with);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[specifiers, src, type_only, with, span],
        "Swc4jAstNamedExport construct()"
      );
    return_value
  }

  pub fn get_specifiers<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_specifiers,
        &[],
        "List get_specifiers()"
      );
    return_value
  }

  pub fn get_src<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_src,
        &[],
        "Optional get_src()"
      );
    return_value
  }

  pub fn get_with<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_with,
        &[],
        "Optional get_with()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNewExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_args: JMethodID,
  method_get_callee: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNewExpr {}
unsafe impl Sync for JavaSwc4jAstNewExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstNewExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstNewExpr")
      .expect("Couldn't find class Swc4jAstNewExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNewExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNewExpr::new");
    let method_get_args = env
      .get_method_id(
        &class,
        "getArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getArgs");
    let method_get_callee = env
      .get_method_id(
        &class,
        "getCallee",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getCallee");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getTypeArgs");
    JavaSwc4jAstNewExpr {
      class,
      method_construct,
      method_get_args,
      method_get_callee,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    callee: &JObject<'_>,
    args: &Option<JObject>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let callee = object_to_jvalue!(callee);
    let args = optional_object_to_jvalue!(args);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[callee, args, type_args, span],
        "Swc4jAstNewExpr construct()"
      );
    return_value
  }

  pub fn get_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_args,
        &[],
        "Optional get_args()"
      );
    return_value
  }

  pub fn get_callee<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_callee,
        &[],
        "ISwc4jAstExpr get_callee()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNull {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNull {}
unsafe impl Sync for JavaSwc4jAstNull {}

#[allow(dead_code)]
impl JavaSwc4jAstNull {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstNull")
      .expect("Couldn't find class Swc4jAstNull");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNull");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNull::new");
    JavaSwc4jAstNull {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstNull construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNumber {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNumber {}
unsafe impl Sync for JavaSwc4jAstNumber {}

#[allow(dead_code)]
impl JavaSwc4jAstNumber {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstNumber")
      .expect("Couldn't find class Swc4jAstNumber");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNumber");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(DLjava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNumber::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNumber.getRaw");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()D",
      )
      .expect("Couldn't find method Swc4jAstNumber.getValue");
    JavaSwc4jAstNumber {
      class,
      method_construct,
      method_get_raw,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: f64,
    raw: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let value = double_to_jvalue!(value);
    let java_raw = optional_string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, raw, span],
        "Swc4jAstNumber construct()"
      );
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_raw<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "Optional get_raw()"
      );
    return_value
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> f64
  {
    let return_value = call_as_double!(
        env,
        obj,
        self.method_get_value,
        &[],
        "double get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstObjectLit {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_props: JMethodID,
}
unsafe impl Send for JavaSwc4jAstObjectLit {}
unsafe impl Sync for JavaSwc4jAstObjectLit {}

#[allow(dead_code)]
impl JavaSwc4jAstObjectLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit")
      .expect("Couldn't find class Swc4jAstObjectLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstObjectLit");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstObjectLit::new");
    let method_get_props = env
      .get_method_id(
        &class,
        "getProps",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstObjectLit.getProps");
    JavaSwc4jAstObjectLit {
      class,
      method_construct,
      method_get_props,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    props: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let props = object_to_jvalue!(props);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[props, span],
        "Swc4jAstObjectLit construct()"
      );
    return_value
  }

  pub fn get_props<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_props,
        &[],
        "List get_props()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstObjectPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_props: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstObjectPat {}
unsafe impl Sync for JavaSwc4jAstObjectPat {}

#[allow(dead_code)]
impl JavaSwc4jAstObjectPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstObjectPat")
      .expect("Couldn't find class Swc4jAstObjectPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstObjectPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstObjectPat::new");
    let method_get_props = env
      .get_method_id(
        &class,
        "getProps",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstObjectPat.getProps");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstObjectPat.getTypeAnn");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstObjectPat.isOptional");
    JavaSwc4jAstObjectPat {
      class,
      method_construct,
      method_get_props,
      method_get_type_ann,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    props: &JObject<'_>,
    optional: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let props = object_to_jvalue!(props);
    let optional = boolean_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[props, optional, type_ann, span],
        "Swc4jAstObjectPat construct()"
      );
    return_value
  }

  pub fn get_props<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_props,
        &[],
        "List get_props()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstOptCall {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_args: JMethodID,
  method_get_callee: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstOptCall {}
unsafe impl Sync for JavaSwc4jAstOptCall {}

#[allow(dead_code)]
impl JavaSwc4jAstOptCall {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstOptCall")
      .expect("Couldn't find class Swc4jAstOptCall");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstOptCall");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstOptCall::new");
    let method_get_args = env
      .get_method_id(
        &class,
        "getArgs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getArgs");
    let method_get_callee = env
      .get_method_id(
        &class,
        "getCallee",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getCallee");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getTypeArgs");
    JavaSwc4jAstOptCall {
      class,
      method_construct,
      method_get_args,
      method_get_callee,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    callee: &JObject<'_>,
    args: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let callee = object_to_jvalue!(callee);
    let args = object_to_jvalue!(args);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[callee, args, type_args, span],
        "Swc4jAstOptCall construct()"
      );
    return_value
  }

  pub fn get_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_args,
        &[],
        "List get_args()"
      );
    return_value
  }

  pub fn get_callee<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_callee,
        &[],
        "ISwc4jAstExpr get_callee()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstOptChainExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_base: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstOptChainExpr {}
unsafe impl Sync for JavaSwc4jAstOptChainExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstOptChainExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstOptChainExpr")
      .expect("Couldn't find class Swc4jAstOptChainExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstOptChainExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstOptChainBase;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstOptChainExpr::new");
    let method_get_base = env
      .get_method_id(
        &class,
        "getBase",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstOptChainBase;",
      )
      .expect("Couldn't find method Swc4jAstOptChainExpr.getBase");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstOptChainExpr.isOptional");
    JavaSwc4jAstOptChainExpr {
      class,
      method_construct,
      method_get_base,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    optional: bool,
    base: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let optional = boolean_to_jvalue!(optional);
    let base = object_to_jvalue!(base);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[optional, base, span],
        "Swc4jAstOptChainExpr construct()"
      );
    return_value
  }

  pub fn get_base<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_base,
        &[],
        "ISwc4jAstOptChainBase get_base()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstParam {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decorators: JMethodID,
  method_get_pat: JMethodID,
}
unsafe impl Send for JavaSwc4jAstParam {}
unsafe impl Sync for JavaSwc4jAstParam {}

#[allow(dead_code)]
impl JavaSwc4jAstParam {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstParam")
      .expect("Couldn't find class Swc4jAstParam");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstParam");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstParam::new");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstParam.getDecorators");
    let method_get_pat = env
      .get_method_id(
        &class,
        "getPat",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstParam.getPat");
    JavaSwc4jAstParam {
      class,
      method_construct,
      method_get_decorators,
      method_get_pat,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decorators: &JObject<'_>,
    pat: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decorators = object_to_jvalue!(decorators);
    let pat = object_to_jvalue!(pat);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decorators, pat, span],
        "Swc4jAstParam construct()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_pat<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_pat,
        &[],
        "ISwc4jAstPat get_pat()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstParenExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstParenExpr {}
unsafe impl Sync for JavaSwc4jAstParenExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstParenExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstParenExpr")
      .expect("Couldn't find class Swc4jAstParenExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstParenExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstParenExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstParenExpr.getExpr");
    JavaSwc4jAstParenExpr {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstParenExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstPrivateMethod {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_function: JMethodID,
  method_get_key: JMethodID,
  method_get_kind: JMethodID,
  method_is_abstract: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstPrivateMethod {}
unsafe impl Sync for JavaSwc4jAstPrivateMethod {}

#[allow(dead_code)]
impl JavaSwc4jAstPrivateMethod {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateMethod")
      .expect("Couldn't find class Swc4jAstPrivateMethod");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstPrivateMethod");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;ZLcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getAccessibility");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getFunction");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getKey");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getKind");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isAbstract");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isOverride");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isStatic");
    JavaSwc4jAstPrivateMethod {
      class,
      method_construct,
      method_get_accessibility,
      method_get_function,
      method_get_key,
      method_get_kind,
      method_is_abstract,
      method_is_optional,
      method_is_override,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    function: &JObject<'_>,
    kind: &JObject<'_>,
    is_static: bool,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    optional: bool,
    is_override: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let function = object_to_jvalue!(function);
    let kind = object_to_jvalue!(kind);
    let is_static = boolean_to_jvalue!(is_static);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, function, kind, is_static, accessibility, is_abstract, optional, is_override, span],
        "Swc4jAstPrivateMethod construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstPrivateName get_key()"
      );
    return_value
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstMethodKind get_kind()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstPrivateName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
}
unsafe impl Send for JavaSwc4jAstPrivateName {}
unsafe impl Sync for JavaSwc4jAstPrivateName {}

#[allow(dead_code)]
impl JavaSwc4jAstPrivateName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName")
      .expect("Couldn't find class Swc4jAstPrivateName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstPrivateName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstPrivateName::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstPrivateName.getId");
    JavaSwc4jAstPrivateName {
      class,
      method_construct,
      method_get_id,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, span],
        "Swc4jAstPrivateName construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstPrivateProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_value: JMethodID,
  method_is_definite: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_readonly: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstPrivateProp {}
unsafe impl Sync for JavaSwc4jAstPrivateProp {}

#[allow(dead_code)]
impl JavaSwc4jAstPrivateProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateProp")
      .expect("Couldn't find class Swc4jAstPrivateProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstPrivateProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getDecorators");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getTypeAnn");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getValue");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isDefinite");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isOverride");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isReadonly");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isStatic");
    JavaSwc4jAstPrivateProp {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_key,
      method_get_type_ann,
      method_get_value,
      method_is_definite,
      method_is_optional,
      method_is_override,
      method_is_readonly,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    type_ann: &Option<JObject>,
    is_static: bool,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    optional: bool,
    is_override: bool,
    readonly: bool,
    definite: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let is_static = boolean_to_jvalue!(is_static);
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let readonly = boolean_to_jvalue!(readonly);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, type_ann, is_static, decorators, accessibility, optional, is_override, readonly, definite, span],
        "Swc4jAstPrivateProp construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstPrivateName get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstRegex {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exp: JMethodID,
  method_get_flags: JMethodID,
}
unsafe impl Send for JavaSwc4jAstRegex {}
unsafe impl Sync for JavaSwc4jAstRegex {}

#[allow(dead_code)]
impl JavaSwc4jAstRegex {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstRegex")
      .expect("Couldn't find class Swc4jAstRegex");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstRegex");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstRegex::new");
    let method_get_exp = env
      .get_method_id(
        &class,
        "getExp",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstRegex.getExp");
    let method_get_flags = env
      .get_method_id(
        &class,
        "getFlags",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstRegex.getFlags");
    JavaSwc4jAstRegex {
      class,
      method_construct,
      method_get_exp,
      method_get_flags,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exp: &str,
    flags: &str,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_exp = string_to_jstring!(env, &exp);
    let exp = object_to_jvalue!(java_exp);
    let java_flags = string_to_jstring!(env, &flags);
    let flags = object_to_jvalue!(java_flags);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exp, flags, span],
        "Swc4jAstRegex construct()"
      );
    delete_local_ref!(env, java_exp);
    delete_local_ref!(env, java_flags);
    return_value
  }

  pub fn get_exp<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exp,
        &[],
        "String get_exp()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }

  pub fn get_flags<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_flags,
        &[],
        "String get_flags()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstRestPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_dot3_token: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstRestPat {}
unsafe impl Sync for JavaSwc4jAstRestPat {}

#[allow(dead_code)]
impl JavaSwc4jAstRestPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstRestPat")
      .expect("Couldn't find class Swc4jAstRestPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstRestPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstRestPat::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstRestPat.getArg");
    let method_get_dot3_token = env
      .get_method_id(
        &class,
        "getDot3Token",
        "()Lcom/caoccao/javet/swc4j/span/Swc4jSpan;",
      )
      .expect("Couldn't find method Swc4jAstRestPat.getDot3Token");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstRestPat.getTypeAnn");
    JavaSwc4jAstRestPat {
      class,
      method_construct,
      method_get_arg,
      method_get_dot3_token,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    dot3_token: &JObject<'_>,
    arg: &JObject<'_>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let dot3_token = object_to_jvalue!(dot3_token);
    let arg = object_to_jvalue!(arg);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[dot3_token, arg, type_ann, span],
        "Swc4jAstRestPat construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstPat get_arg()"
      );
    return_value
  }

  pub fn get_dot3_token<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_dot3_token,
        &[],
        "Swc4jSpan get_dot3_token()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstReturnStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
}
unsafe impl Send for JavaSwc4jAstReturnStmt {}
unsafe impl Sync for JavaSwc4jAstReturnStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstReturnStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstReturnStmt")
      .expect("Couldn't find class Swc4jAstReturnStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstReturnStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstReturnStmt::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstReturnStmt.getArg");
    JavaSwc4jAstReturnStmt {
      class,
      method_construct,
      method_get_arg,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = optional_object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, span],
        "Swc4jAstReturnStmt construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "Optional get_arg()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstScript {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_shebang: JMethodID,
}
unsafe impl Send for JavaSwc4jAstScript {}
unsafe impl Sync for JavaSwc4jAstScript {}

#[allow(dead_code)]
impl JavaSwc4jAstScript {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/program/Swc4jAstScript")
      .expect("Couldn't find class Swc4jAstScript");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstScript");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstScript::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstScript.getBody");
    let method_get_shebang = env
      .get_method_id(
        &class,
        "getShebang",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstScript.getShebang");
    JavaSwc4jAstScript {
      class,
      method_construct,
      method_get_body,
      method_get_shebang,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    shebang: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let java_shebang = optional_string_to_jstring!(env, &shebang);
    let shebang = object_to_jvalue!(java_shebang);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, shebang, span],
        "Swc4jAstScript construct()"
      );
    delete_local_ref!(env, java_shebang);
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }

  pub fn get_shebang<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_shebang,
        &[],
        "Optional get_shebang()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSeqExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exprs: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSeqExpr {}
unsafe impl Sync for JavaSwc4jAstSeqExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstSeqExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstSeqExpr")
      .expect("Couldn't find class Swc4jAstSeqExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSeqExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSeqExpr::new");
    let method_get_exprs = env
      .get_method_id(
        &class,
        "getExprs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstSeqExpr.getExprs");
    JavaSwc4jAstSeqExpr {
      class,
      method_construct,
      method_get_exprs,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exprs: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let exprs = object_to_jvalue!(exprs);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exprs, span],
        "Swc4jAstSeqExpr construct()"
      );
    return_value
  }

  pub fn get_exprs<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exprs,
        &[],
        "List get_exprs()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSetterProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_key: JMethodID,
  method_get_param: JMethodID,
  method_get_this_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSetterProp {}
unsafe impl Sync for JavaSwc4jAstSetterProp {}

#[allow(dead_code)]
impl JavaSwc4jAstSetterProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstSetterProp")
      .expect("Couldn't find class Swc4jAstSetterProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSetterProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSetterProp::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getBody");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getKey");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getParam");
    let method_get_this_param = env
      .get_method_id(
        &class,
        "getThisParam",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getThisParam");
    JavaSwc4jAstSetterProp {
      class,
      method_construct,
      method_get_body,
      method_get_key,
      method_get_param,
      method_get_this_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    this_param: &Option<JObject>,
    param: &JObject<'_>,
    body: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let this_param = optional_object_to_jvalue!(this_param);
    let param = object_to_jvalue!(param);
    let body = optional_object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, this_param, param, body, span],
        "Swc4jAstSetterProp construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "ISwc4jAstPat get_param()"
      );
    return_value
  }

  pub fn get_this_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_this_param,
        &[],
        "Optional get_this_param()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSpreadElement {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSpreadElement {}
unsafe impl Sync for JavaSwc4jAstSpreadElement {}

#[allow(dead_code)]
impl JavaSwc4jAstSpreadElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstSpreadElement")
      .expect("Couldn't find class Swc4jAstSpreadElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSpreadElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSpreadElement::new");
    JavaSwc4jAstSpreadElement {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    dot3_token: &JObject<'_>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let dot3_token = object_to_jvalue!(dot3_token);
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[dot3_token, expr, span],
        "Swc4jAstSpreadElement construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstStaticBlock {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
}
unsafe impl Send for JavaSwc4jAstStaticBlock {}
unsafe impl Sync for JavaSwc4jAstStaticBlock {}

#[allow(dead_code)]
impl JavaSwc4jAstStaticBlock {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstStaticBlock")
      .expect("Couldn't find class Swc4jAstStaticBlock");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstStaticBlock");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstStaticBlock::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;",
      )
      .expect("Couldn't find method Swc4jAstStaticBlock.getBody");
    JavaSwc4jAstStaticBlock {
      class,
      method_construct,
      method_get_body,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, span],
        "Swc4jAstStaticBlock construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Swc4jAstBlockStmt get_body()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstStr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstStr {}
unsafe impl Sync for JavaSwc4jAstStr {}

#[allow(dead_code)]
impl JavaSwc4jAstStr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr")
      .expect("Couldn't find class Swc4jAstStr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstStr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstStr::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstStr.getRaw");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstStr.getValue");
    JavaSwc4jAstStr {
      class,
      method_construct,
      method_get_raw,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: &str,
    raw: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_value = string_to_jstring!(env, &value);
    let value = object_to_jvalue!(java_value);
    let java_raw = optional_string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, raw, span],
        "Swc4jAstStr construct()"
      );
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_raw<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "Optional get_raw()"
      );
    return_value
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "String get_value()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSuper {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSuper {}
unsafe impl Sync for JavaSwc4jAstSuper {}

#[allow(dead_code)]
impl JavaSwc4jAstSuper {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstSuper")
      .expect("Couldn't find class Swc4jAstSuper");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSuper");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSuper::new");
    JavaSwc4jAstSuper {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstSuper construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSuperPropExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_obj: JMethodID,
  method_get_prop: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSuperPropExpr {}
unsafe impl Sync for JavaSwc4jAstSuperPropExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstSuperPropExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstSuperPropExpr")
      .expect("Couldn't find class Swc4jAstSuperPropExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSuperPropExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstSuper;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstSuperProp;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSuperPropExpr::new");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstSuper;",
      )
      .expect("Couldn't find method Swc4jAstSuperPropExpr.getObj");
    let method_get_prop = env
      .get_method_id(
        &class,
        "getProp",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstSuperProp;",
      )
      .expect("Couldn't find method Swc4jAstSuperPropExpr.getProp");
    JavaSwc4jAstSuperPropExpr {
      class,
      method_construct,
      method_get_obj,
      method_get_prop,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    prop: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let prop = object_to_jvalue!(prop);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, prop, span],
        "Swc4jAstSuperPropExpr construct()"
      );
    return_value
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "Swc4jAstSuper get_obj()"
      );
    return_value
  }

  pub fn get_prop<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_prop,
        &[],
        "ISwc4jAstSuperProp get_prop()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSwitchCase {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_cons: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSwitchCase {}
unsafe impl Sync for JavaSwc4jAstSwitchCase {}

#[allow(dead_code)]
impl JavaSwc4jAstSwitchCase {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstSwitchCase")
      .expect("Couldn't find class Swc4jAstSwitchCase");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSwitchCase");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSwitchCase::new");
    let method_get_cons = env
      .get_method_id(
        &class,
        "getCons",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstSwitchCase.getCons");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstSwitchCase.getTest");
    JavaSwc4jAstSwitchCase {
      class,
      method_construct,
      method_get_cons,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &Option<JObject>,
    cons: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = optional_object_to_jvalue!(test);
    let cons = object_to_jvalue!(cons);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, cons, span],
        "Swc4jAstSwitchCase construct()"
      );
    return_value
  }

  pub fn get_cons<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cons,
        &[],
        "List get_cons()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "Optional get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSwitchStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_cases: JMethodID,
  method_get_discriminant: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSwitchStmt {}
unsafe impl Sync for JavaSwc4jAstSwitchStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstSwitchStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstSwitchStmt")
      .expect("Couldn't find class Swc4jAstSwitchStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSwitchStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSwitchStmt::new");
    let method_get_cases = env
      .get_method_id(
        &class,
        "getCases",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstSwitchStmt.getCases");
    let method_get_discriminant = env
      .get_method_id(
        &class,
        "getDiscriminant",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstSwitchStmt.getDiscriminant");
    JavaSwc4jAstSwitchStmt {
      class,
      method_construct,
      method_get_cases,
      method_get_discriminant,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    discriminant: &JObject<'_>,
    cases: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let discriminant = object_to_jvalue!(discriminant);
    let cases = object_to_jvalue!(cases);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[discriminant, cases, span],
        "Swc4jAstSwitchStmt construct()"
      );
    return_value
  }

  pub fn get_cases<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cases,
        &[],
        "List get_cases()"
      );
    return_value
  }

  pub fn get_discriminant<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_discriminant,
        &[],
        "ISwc4jAstExpr get_discriminant()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTaggedTpl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_tag: JMethodID,
  method_get_tpl: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTaggedTpl {}
unsafe impl Sync for JavaSwc4jAstTaggedTpl {}

#[allow(dead_code)]
impl JavaSwc4jAstTaggedTpl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTaggedTpl")
      .expect("Couldn't find class Swc4jAstTaggedTpl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTaggedTpl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstTpl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl::new");
    let method_get_tag = env
      .get_method_id(
        &class,
        "getTag",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getTag");
    let method_get_tpl = env
      .get_method_id(
        &class,
        "getTpl",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstTpl;",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getTpl");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getTypeParams");
    JavaSwc4jAstTaggedTpl {
      class,
      method_construct,
      method_get_tag,
      method_get_tpl,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    tag: &JObject<'_>,
    type_params: &Option<JObject>,
    tpl: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let tag = object_to_jvalue!(tag);
    let type_params = optional_object_to_jvalue!(type_params);
    let tpl = object_to_jvalue!(tpl);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[tag, type_params, tpl, span],
        "Swc4jAstTaggedTpl construct()"
      );
    return_value
  }

  pub fn get_tag<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_tag,
        &[],
        "ISwc4jAstExpr get_tag()"
      );
    return_value
  }

  pub fn get_tpl<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_tpl,
        &[],
        "Swc4jAstTpl get_tpl()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstThisExpr {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstThisExpr {}
unsafe impl Sync for JavaSwc4jAstThisExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstThisExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstThisExpr")
      .expect("Couldn't find class Swc4jAstThisExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstThisExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstThisExpr::new");
    JavaSwc4jAstThisExpr {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstThisExpr construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstThrowStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
}
unsafe impl Send for JavaSwc4jAstThrowStmt {}
unsafe impl Sync for JavaSwc4jAstThrowStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstThrowStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstThrowStmt")
      .expect("Couldn't find class Swc4jAstThrowStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstThrowStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstThrowStmt::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstThrowStmt.getArg");
    JavaSwc4jAstThrowStmt {
      class,
      method_construct,
      method_get_arg,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, span],
        "Swc4jAstThrowStmt construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTpl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exprs: JMethodID,
  method_get_quasis: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTpl {}
unsafe impl Sync for JavaSwc4jAstTpl {}

#[allow(dead_code)]
impl JavaSwc4jAstTpl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTpl")
      .expect("Couldn't find class Swc4jAstTpl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTpl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTpl::new");
    let method_get_exprs = env
      .get_method_id(
        &class,
        "getExprs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTpl.getExprs");
    let method_get_quasis = env
      .get_method_id(
        &class,
        "getQuasis",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTpl.getQuasis");
    JavaSwc4jAstTpl {
      class,
      method_construct,
      method_get_exprs,
      method_get_quasis,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exprs: &JObject<'_>,
    quasis: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let exprs = object_to_jvalue!(exprs);
    let quasis = object_to_jvalue!(quasis);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exprs, quasis, span],
        "Swc4jAstTpl construct()"
      );
    return_value
  }

  pub fn get_exprs<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exprs,
        &[],
        "List get_exprs()"
      );
    return_value
  }

  pub fn get_quasis<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_quasis,
        &[],
        "List get_quasis()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTplElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_cooked: JMethodID,
  method_get_raw: JMethodID,
  method_is_tail: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTplElement {}
unsafe impl Sync for JavaSwc4jAstTplElement {}

#[allow(dead_code)]
impl JavaSwc4jAstTplElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstTplElement")
      .expect("Couldn't find class Swc4jAstTplElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTplElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLjava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTplElement::new");
    let method_get_cooked = env
      .get_method_id(
        &class,
        "getCooked",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTplElement.getCooked");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstTplElement.getRaw");
    let method_is_tail = env
      .get_method_id(
        &class,
        "isTail",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTplElement.isTail");
    JavaSwc4jAstTplElement {
      class,
      method_construct,
      method_get_cooked,
      method_get_raw,
      method_is_tail,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    tail: bool,
    cooked: &Option<String>,
    raw: &str,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let tail = boolean_to_jvalue!(tail);
    let java_cooked = optional_string_to_jstring!(env, &cooked);
    let cooked = object_to_jvalue!(java_cooked);
    let java_raw = string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[tail, cooked, raw, span],
        "Swc4jAstTplElement construct()"
      );
    delete_local_ref!(env, java_cooked);
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_cooked<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cooked,
        &[],
        "Optional get_cooked()"
      );
    return_value
  }

  pub fn get_raw<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "String get_raw()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }

  pub fn is_tail<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_tail,
        &[],
        "boolean is_tail()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTryStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_block: JMethodID,
  method_get_finalizer: JMethodID,
  method_get_handler: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTryStmt {}
unsafe impl Sync for JavaSwc4jAstTryStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstTryStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTryStmt")
      .expect("Couldn't find class Swc4jAstTryStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTryStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstCatchClause;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTryStmt::new");
    let method_get_block = env
      .get_method_id(
        &class,
        "getBlock",
        "()Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;",
      )
      .expect("Couldn't find method Swc4jAstTryStmt.getBlock");
    let method_get_finalizer = env
      .get_method_id(
        &class,
        "getFinalizer",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTryStmt.getFinalizer");
    let method_get_handler = env
      .get_method_id(
        &class,
        "getHandler",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTryStmt.getHandler");
    JavaSwc4jAstTryStmt {
      class,
      method_construct,
      method_get_block,
      method_get_finalizer,
      method_get_handler,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    block: &JObject<'_>,
    handler: &Option<JObject>,
    finalizer: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let block = object_to_jvalue!(block);
    let handler = optional_object_to_jvalue!(handler);
    let finalizer = optional_object_to_jvalue!(finalizer);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[block, handler, finalizer, span],
        "Swc4jAstTryStmt construct()"
      );
    return_value
  }

  pub fn get_block<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_block,
        &[],
        "Swc4jAstBlockStmt get_block()"
      );
    return_value
  }

  pub fn get_finalizer<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_finalizer,
        &[],
        "Optional get_finalizer()"
      );
    return_value
  }

  pub fn get_handler<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_handler,
        &[],
        "Optional get_handler()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsArrayType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elem_type: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsArrayType {}
unsafe impl Sync for JavaSwc4jAstTsArrayType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsArrayType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsArrayType")
      .expect("Couldn't find class Swc4jAstTsArrayType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsArrayType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsArrayType::new");
    let method_get_elem_type = env
      .get_method_id(
        &class,
        "getElemType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsArrayType.getElemType");
    JavaSwc4jAstTsArrayType {
      class,
      method_construct,
      method_get_elem_type,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elem_type: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let elem_type = object_to_jvalue!(elem_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elem_type, span],
        "Swc4jAstTsArrayType construct()"
      );
    return_value
  }

  pub fn get_elem_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elem_type,
        &[],
        "ISwc4jAstTsType get_elem_type()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsAsExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsAsExpr {}
unsafe impl Sync for JavaSwc4jAstTsAsExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstTsAsExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsAsExpr")
      .expect("Couldn't find class Swc4jAstTsAsExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsAsExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsAsExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsAsExpr.getExpr");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsAsExpr.getTypeAnn");
    JavaSwc4jAstTsAsExpr {
      class,
      method_construct,
      method_get_expr,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_ann, span],
        "Swc4jAstTsAsExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsCallSignatureDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsCallSignatureDecl {}
unsafe impl Sync for JavaSwc4jAstTsCallSignatureDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsCallSignatureDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsCallSignatureDecl")
      .expect("Couldn't find class Swc4jAstTsCallSignatureDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsCallSignatureDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl.getTypeParams");
    JavaSwc4jAstTsCallSignatureDecl {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_ann, type_params, span],
        "Swc4jAstTsCallSignatureDecl construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConditionalType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_check_type: JMethodID,
  method_get_extends_type: JMethodID,
  method_get_false_type: JMethodID,
  method_get_true_type: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConditionalType {}
unsafe impl Sync for JavaSwc4jAstTsConditionalType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConditionalType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsConditionalType")
      .expect("Couldn't find class Swc4jAstTsConditionalType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConditionalType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType::new");
    let method_get_check_type = env
      .get_method_id(
        &class,
        "getCheckType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getCheckType");
    let method_get_extends_type = env
      .get_method_id(
        &class,
        "getExtendsType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getExtendsType");
    let method_get_false_type = env
      .get_method_id(
        &class,
        "getFalseType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getFalseType");
    let method_get_true_type = env
      .get_method_id(
        &class,
        "getTrueType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getTrueType");
    JavaSwc4jAstTsConditionalType {
      class,
      method_construct,
      method_get_check_type,
      method_get_extends_type,
      method_get_false_type,
      method_get_true_type,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    check_type: &JObject<'_>,
    extends_type: &JObject<'_>,
    true_type: &JObject<'_>,
    false_type: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let check_type = object_to_jvalue!(check_type);
    let extends_type = object_to_jvalue!(extends_type);
    let true_type = object_to_jvalue!(true_type);
    let false_type = object_to_jvalue!(false_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[check_type, extends_type, true_type, false_type, span],
        "Swc4jAstTsConditionalType construct()"
      );
    return_value
  }

  pub fn get_check_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_check_type,
        &[],
        "ISwc4jAstTsType get_check_type()"
      );
    return_value
  }

  pub fn get_extends_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_extends_type,
        &[],
        "ISwc4jAstTsType get_extends_type()"
      );
    return_value
  }

  pub fn get_false_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_false_type,
        &[],
        "ISwc4jAstTsType get_false_type()"
      );
    return_value
  }

  pub fn get_true_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_true_type,
        &[],
        "ISwc4jAstTsType get_true_type()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConstAssertion {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConstAssertion {}
unsafe impl Sync for JavaSwc4jAstTsConstAssertion {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConstAssertion {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsConstAssertion")
      .expect("Couldn't find class Swc4jAstTsConstAssertion");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConstAssertion");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConstAssertion::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsConstAssertion.getExpr");
    JavaSwc4jAstTsConstAssertion {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsConstAssertion construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConstructSignatureDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConstructSignatureDecl {}
unsafe impl Sync for JavaSwc4jAstTsConstructSignatureDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConstructSignatureDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsConstructSignatureDecl")
      .expect("Couldn't find class Swc4jAstTsConstructSignatureDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConstructSignatureDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl.getTypeParams");
    JavaSwc4jAstTsConstructSignatureDecl {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_ann, type_params, span],
        "Swc4jAstTsConstructSignatureDecl construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConstructorType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_abstract: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConstructorType {}
unsafe impl Sync for JavaSwc4jAstTsConstructorType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConstructorType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsConstructorType")
      .expect("Couldn't find class Swc4jAstTsConstructorType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConstructorType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.getTypeParams");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.isAbstract");
    JavaSwc4jAstTsConstructorType {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
      method_is_abstract,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_params: &Option<JObject>,
    type_ann: &JObject<'_>,
    is_abstract: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_params = optional_object_to_jvalue!(type_params);
    let type_ann = object_to_jvalue!(type_ann);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_params, type_ann, is_abstract, span],
        "Swc4jAstTsConstructorType construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Swc4jAstTsTypeAnn get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsEnumDecl {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsEnumDecl {}
unsafe impl Sync for JavaSwc4jAstTsEnumDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsEnumDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsEnumDecl")
      .expect("Couldn't find class Swc4jAstTsEnumDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsEnumDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsEnumDecl::new");
    JavaSwc4jAstTsEnumDecl {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    declare: bool,
    is_const: bool,
    id: &JObject<'_>,
    members: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let declare = boolean_to_jvalue!(declare);
    let is_const = boolean_to_jvalue!(is_const);
    let id = object_to_jvalue!(id);
    let members = object_to_jvalue!(members);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[declare, is_const, id, members, span],
        "Swc4jAstTsEnumDecl construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsEnumMember {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_init: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsEnumMember {}
unsafe impl Sync for JavaSwc4jAstTsEnumMember {}

#[allow(dead_code)]
impl JavaSwc4jAstTsEnumMember {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsEnumMember")
      .expect("Couldn't find class Swc4jAstTsEnumMember");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsEnumMember");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEnumMemberId;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsEnumMember::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEnumMemberId;",
      )
      .expect("Couldn't find method Swc4jAstTsEnumMember.getId");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsEnumMember.getInit");
    JavaSwc4jAstTsEnumMember {
      class,
      method_construct,
      method_get_id,
      method_get_init,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    init: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let init = optional_object_to_jvalue!(init);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, init, span],
        "Swc4jAstTsEnumMember construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "ISwc4jAstTsEnumMemberId get_id()"
      );
    return_value
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsExportAssignment {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsExportAssignment {}
unsafe impl Sync for JavaSwc4jAstTsExportAssignment {}

#[allow(dead_code)]
impl JavaSwc4jAstTsExportAssignment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsExportAssignment")
      .expect("Couldn't find class Swc4jAstTsExportAssignment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsExportAssignment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsExportAssignment::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsExportAssignment.getExpr");
    JavaSwc4jAstTsExportAssignment {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsExportAssignment construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsExprWithTypeArgs {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsExprWithTypeArgs {}
unsafe impl Sync for JavaSwc4jAstTsExprWithTypeArgs {}

#[allow(dead_code)]
impl JavaSwc4jAstTsExprWithTypeArgs {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsExprWithTypeArgs")
      .expect("Couldn't find class Swc4jAstTsExprWithTypeArgs");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsExprWithTypeArgs");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsExprWithTypeArgs::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsExprWithTypeArgs.getExpr");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsExprWithTypeArgs.getTypeArgs");
    JavaSwc4jAstTsExprWithTypeArgs {
      class,
      method_construct,
      method_get_expr,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_args, span],
        "Swc4jAstTsExprWithTypeArgs construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsExternalModuleRef {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsExternalModuleRef {}
unsafe impl Sync for JavaSwc4jAstTsExternalModuleRef {}

#[allow(dead_code)]
impl JavaSwc4jAstTsExternalModuleRef {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsExternalModuleRef")
      .expect("Couldn't find class Swc4jAstTsExternalModuleRef");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsExternalModuleRef");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsExternalModuleRef::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstTsExternalModuleRef.getExpr");
    JavaSwc4jAstTsExternalModuleRef {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsExternalModuleRef construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "Swc4jAstStr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsFnType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsFnType {}
unsafe impl Sync for JavaSwc4jAstTsFnType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsFnType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsFnType")
      .expect("Couldn't find class Swc4jAstTsFnType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsFnType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsFnType::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsFnType.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;",
      )
      .expect("Couldn't find method Swc4jAstTsFnType.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsFnType.getTypeParams");
    JavaSwc4jAstTsFnType {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_params: &Option<JObject>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_params = optional_object_to_jvalue!(type_params);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_params, type_ann, span],
        "Swc4jAstTsFnType construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Swc4jAstTsTypeAnn get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsGetterSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsGetterSignature {}
unsafe impl Sync for JavaSwc4jAstTsGetterSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsGetterSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsGetterSignature")
      .expect("Couldn't find class Swc4jAstTsGetterSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsGetterSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.getTypeAnn");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.isOptional");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.isReadonly");
    JavaSwc4jAstTsGetterSignature {
      class,
      method_construct,
      method_get_key,
      method_get_type_ann,
      method_is_computed,
      method_is_optional,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, key, computed, optional, type_ann, span],
        "Swc4jAstTsGetterSignature construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsImportEqualsDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_module_ref: JMethodID,
  method_is_export: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsImportEqualsDecl {}
unsafe impl Sync for JavaSwc4jAstTsImportEqualsDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsImportEqualsDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsImportEqualsDecl")
      .expect("Couldn't find class Swc4jAstTsImportEqualsDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsImportEqualsDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleRef;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.getId");
    let method_get_module_ref = env
      .get_method_id(
        &class,
        "getModuleRef",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleRef;",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.getModuleRef");
    let method_is_export = env
      .get_method_id(
        &class,
        "isExport",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.isExport");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.isTypeOnly");
    JavaSwc4jAstTsImportEqualsDecl {
      class,
      method_construct,
      method_get_id,
      method_get_module_ref,
      method_is_export,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    export: bool,
    type_only: bool,
    id: &JObject<'_>,
    module_ref: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let export = boolean_to_jvalue!(export);
    let type_only = boolean_to_jvalue!(type_only);
    let id = object_to_jvalue!(id);
    let module_ref = object_to_jvalue!(module_ref);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[export, type_only, id, module_ref, span],
        "Swc4jAstTsImportEqualsDecl construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn get_module_ref<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_module_ref,
        &[],
        "ISwc4jAstTsModuleRef get_module_ref()"
      );
    return_value
  }

  pub fn is_export<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_export,
        &[],
        "boolean is_export()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsImportType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_qualifier: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsImportType {}
unsafe impl Sync for JavaSwc4jAstTsImportType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsImportType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsImportType")
      .expect("Couldn't find class Swc4jAstTsImportType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsImportType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsImportType::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstTsImportType.getArg");
    let method_get_qualifier = env
      .get_method_id(
        &class,
        "getQualifier",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsImportType.getQualifier");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsImportType.getTypeArgs");
    JavaSwc4jAstTsImportType {
      class,
      method_construct,
      method_get_arg,
      method_get_qualifier,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &JObject<'_>,
    qualifier: &Option<JObject>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = object_to_jvalue!(arg);
    let qualifier = optional_object_to_jvalue!(qualifier);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, qualifier, type_args, span],
        "Swc4jAstTsImportType construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "Swc4jAstStr get_arg()"
      );
    return_value
  }

  pub fn get_qualifier<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_qualifier,
        &[],
        "Optional get_qualifier()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsIndexSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_readonly: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsIndexSignature {}
unsafe impl Sync for JavaSwc4jAstTsIndexSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsIndexSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsIndexSignature")
      .expect("Couldn't find class Swc4jAstTsIndexSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsIndexSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.getTypeAnn");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.isReadonly");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.isStatic");
    JavaSwc4jAstTsIndexSignature {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_is_readonly,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    readonly: bool,
    is_static: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let readonly = boolean_to_jvalue!(readonly);
    let is_static = boolean_to_jvalue!(is_static);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_ann, readonly, is_static, span],
        "Swc4jAstTsIndexSignature construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsIndexedAccessType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_index_type: JMethodID,
  method_get_obj_type: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsIndexedAccessType {}
unsafe impl Sync for JavaSwc4jAstTsIndexedAccessType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsIndexedAccessType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsIndexedAccessType")
      .expect("Couldn't find class Swc4jAstTsIndexedAccessType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsIndexedAccessType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType::new");
    let method_get_index_type = env
      .get_method_id(
        &class,
        "getIndexType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType.getIndexType");
    let method_get_obj_type = env
      .get_method_id(
        &class,
        "getObjType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType.getObjType");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType.isReadonly");
    JavaSwc4jAstTsIndexedAccessType {
      class,
      method_construct,
      method_get_index_type,
      method_get_obj_type,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    obj_type: &JObject<'_>,
    index_type: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let obj_type = object_to_jvalue!(obj_type);
    let index_type = object_to_jvalue!(index_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, obj_type, index_type, span],
        "Swc4jAstTsIndexedAccessType construct()"
      );
    return_value
  }

  pub fn get_index_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_index_type,
        &[],
        "ISwc4jAstTsType get_index_type()"
      );
    return_value
  }

  pub fn get_obj_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj_type,
        &[],
        "ISwc4jAstTsType get_obj_type()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInferType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInferType {}
unsafe impl Sync for JavaSwc4jAstTsInferType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInferType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInferType")
      .expect("Couldn't find class Swc4jAstTsInferType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInferType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInferType::new");
    let method_get_type_param = env
      .get_method_id(
        &class,
        "getTypeParam",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;",
      )
      .expect("Couldn't find method Swc4jAstTsInferType.getTypeParam");
    JavaSwc4jAstTsInferType {
      class,
      method_construct,
      method_get_type_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_param: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_param = object_to_jvalue!(type_param);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_param, span],
        "Swc4jAstTsInferType construct()"
      );
    return_value
  }

  pub fn get_type_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_param,
        &[],
        "Swc4jAstTsTypeParam get_type_param()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInstantiation {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInstantiation {}
unsafe impl Sync for JavaSwc4jAstTsInstantiation {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInstantiation {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsInstantiation")
      .expect("Couldn't find class Swc4jAstTsInstantiation");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInstantiation");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInstantiation::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsInstantiation.getExpr");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;",
      )
      .expect("Couldn't find method Swc4jAstTsInstantiation.getTypeArgs");
    JavaSwc4jAstTsInstantiation {
      class,
      method_construct,
      method_get_expr,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_args: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_args = object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_args, span],
        "Swc4jAstTsInstantiation construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Swc4jAstTsTypeParamInstantiation get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInterfaceBody {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInterfaceBody {}
unsafe impl Sync for JavaSwc4jAstTsInterfaceBody {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInterfaceBody {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInterfaceBody")
      .expect("Couldn't find class Swc4jAstTsInterfaceBody");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInterfaceBody");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceBody::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceBody.getBody");
    JavaSwc4jAstTsInterfaceBody {
      class,
      method_construct,
      method_get_body,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, span],
        "Swc4jAstTsInterfaceBody construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInterfaceDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_extends: JMethodID,
  method_get_id: JMethodID,
  method_get_type_params: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInterfaceDecl {}
unsafe impl Sync for JavaSwc4jAstTsInterfaceDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInterfaceDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsInterfaceDecl")
      .expect("Couldn't find class Swc4jAstTsInterfaceDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInterfaceDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInterfaceBody;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInterfaceBody;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getBody");
    let method_get_extends = env
      .get_method_id(
        &class,
        "getExtends",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getExtends");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getId");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getTypeParams");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.isDeclare");
    JavaSwc4jAstTsInterfaceDecl {
      class,
      method_construct,
      method_get_body,
      method_get_extends,
      method_get_id,
      method_get_type_params,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    declare: bool,
    type_params: &Option<JObject>,
    extends: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let declare = boolean_to_jvalue!(declare);
    let type_params = optional_object_to_jvalue!(type_params);
    let extends = object_to_jvalue!(extends);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, declare, type_params, extends, body, span],
        "Swc4jAstTsInterfaceDecl construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Swc4jAstTsInterfaceBody get_body()"
      );
    return_value
  }

  pub fn get_extends<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_extends,
        &[],
        "List get_extends()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsIntersectionType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsIntersectionType {}
unsafe impl Sync for JavaSwc4jAstTsIntersectionType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsIntersectionType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsIntersectionType")
      .expect("Couldn't find class Swc4jAstTsIntersectionType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsIntersectionType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsIntersectionType::new");
    let method_get_types = env
      .get_method_id(
        &class,
        "getTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsIntersectionType.getTypes");
    JavaSwc4jAstTsIntersectionType {
      class,
      method_construct,
      method_get_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    types: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let types = object_to_jvalue!(types);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[types, span],
        "Swc4jAstTsIntersectionType construct()"
      );
    return_value
  }

  pub fn get_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_types,
        &[],
        "List get_types()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsKeywordType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_kind: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsKeywordType {}
unsafe impl Sync for JavaSwc4jAstTsKeywordType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsKeywordType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsKeywordType")
      .expect("Couldn't find class Swc4jAstTsKeywordType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsKeywordType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsKeywordTypeKind;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsKeywordType::new");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsKeywordTypeKind;",
      )
      .expect("Couldn't find method Swc4jAstTsKeywordType.getKind");
    JavaSwc4jAstTsKeywordType {
      class,
      method_construct,
      method_get_kind,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    kind: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let kind = object_to_jvalue!(kind);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[kind, span],
        "Swc4jAstTsKeywordType construct()"
      );
    return_value
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstTsKeywordTypeKind get_kind()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsLitType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_lit: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsLitType {}
unsafe impl Sync for JavaSwc4jAstTsLitType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsLitType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsLitType")
      .expect("Couldn't find class Swc4jAstTsLitType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsLitType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsLit;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsLitType::new");
    let method_get_lit = env
      .get_method_id(
        &class,
        "getLit",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsLit;",
      )
      .expect("Couldn't find method Swc4jAstTsLitType.getLit");
    JavaSwc4jAstTsLitType {
      class,
      method_construct,
      method_get_lit,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    lit: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let lit = object_to_jvalue!(lit);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[lit, span],
        "Swc4jAstTsLitType construct()"
      );
    return_value
  }

  pub fn get_lit<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_lit,
        &[],
        "ISwc4jAstTsLit get_lit()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsMappedType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name_type: JMethodID,
  method_get_optional: JMethodID,
  method_get_readonly: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsMappedType {}
unsafe impl Sync for JavaSwc4jAstTsMappedType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsMappedType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsMappedType")
      .expect("Couldn't find class Swc4jAstTsMappedType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsMappedType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTruePlusMinus;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTruePlusMinus;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType::new");
    let method_get_name_type = env
      .get_method_id(
        &class,
        "getNameType",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getNameType");
    let method_get_optional = env
      .get_method_id(
        &class,
        "getOptional",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getOptional");
    let method_get_readonly = env
      .get_method_id(
        &class,
        "getReadonly",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getReadonly");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getTypeAnn");
    let method_get_type_param = env
      .get_method_id(
        &class,
        "getTypeParam",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getTypeParam");
    JavaSwc4jAstTsMappedType {
      class,
      method_construct,
      method_get_name_type,
      method_get_optional,
      method_get_readonly,
      method_get_type_ann,
      method_get_type_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: &Option<JObject>,
    type_param: &JObject<'_>,
    name_type: &Option<JObject>,
    optional: &Option<JObject>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = optional_object_to_jvalue!(readonly);
    let type_param = object_to_jvalue!(type_param);
    let name_type = optional_object_to_jvalue!(name_type);
    let optional = optional_object_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, type_param, name_type, optional, type_ann, span],
        "Swc4jAstTsMappedType construct()"
      );
    return_value
  }

  pub fn get_name_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name_type,
        &[],
        "Optional get_name_type()"
      );
    return_value
  }

  pub fn get_optional<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_optional,
        &[],
        "Optional get_optional()"
      );
    return_value
  }

  pub fn get_readonly<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_readonly,
        &[],
        "Optional get_readonly()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_param,
        &[],
        "Swc4jAstTsTypeParam get_type_param()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsMethodSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsMethodSignature {}
unsafe impl Sync for JavaSwc4jAstTsMethodSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsMethodSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsMethodSignature")
      .expect("Couldn't find class Swc4jAstTsMethodSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsMethodSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getKey");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getTypeParams");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.isOptional");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.isReadonly");
    JavaSwc4jAstTsMethodSignature {
      class,
      method_construct,
      method_get_key,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
      method_is_computed,
      method_is_optional,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, key, computed, optional, params, type_ann, type_params, span],
        "Swc4jAstTsMethodSignature construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsModuleBlock {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsModuleBlock {}
unsafe impl Sync for JavaSwc4jAstTsModuleBlock {}

#[allow(dead_code)]
impl JavaSwc4jAstTsModuleBlock {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsModuleBlock")
      .expect("Couldn't find class Swc4jAstTsModuleBlock");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsModuleBlock");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsModuleBlock::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsModuleBlock.getBody");
    JavaSwc4jAstTsModuleBlock {
      class,
      method_construct,
      method_get_body,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, span],
        "Swc4jAstTsModuleBlock construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsModuleDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_id: JMethodID,
  method_is_declare: JMethodID,
  method_is_global: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsModuleDecl {}
unsafe impl Sync for JavaSwc4jAstTsModuleDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsModuleDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsModuleDecl")
      .expect("Couldn't find class Swc4jAstTsModuleDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsModuleDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.getBody");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleName;",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.getId");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.isDeclare");
    let method_is_global = env
      .get_method_id(
        &class,
        "isGlobal",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.isGlobal");
    JavaSwc4jAstTsModuleDecl {
      class,
      method_construct,
      method_get_body,
      method_get_id,
      method_is_declare,
      method_is_global,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    declare: bool,
    global: bool,
    id: &JObject<'_>,
    body: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let declare = boolean_to_jvalue!(declare);
    let global = boolean_to_jvalue!(global);
    let id = object_to_jvalue!(id);
    let body = optional_object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[declare, global, id, body, span],
        "Swc4jAstTsModuleDecl construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "ISwc4jAstTsModuleName get_id()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }

  pub fn is_global<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_global,
        &[],
        "boolean is_global()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsNamespaceDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_id: JMethodID,
  method_is_declare: JMethodID,
  method_is_global: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsNamespaceDecl {}
unsafe impl Sync for JavaSwc4jAstTsNamespaceDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsNamespaceDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsNamespaceDecl")
      .expect("Couldn't find class Swc4jAstTsNamespaceDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsNamespaceDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody;",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.getBody");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.getId");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.isDeclare");
    let method_is_global = env
      .get_method_id(
        &class,
        "isGlobal",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.isGlobal");
    JavaSwc4jAstTsNamespaceDecl {
      class,
      method_construct,
      method_get_body,
      method_get_id,
      method_is_declare,
      method_is_global,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    declare: bool,
    global: bool,
    id: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let declare = boolean_to_jvalue!(declare);
    let global = boolean_to_jvalue!(global);
    let id = object_to_jvalue!(id);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[declare, global, id, body, span],
        "Swc4jAstTsNamespaceDecl construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstTsNamespaceBody get_body()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }

  pub fn is_global<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_global,
        &[],
        "boolean is_global()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsNamespaceExportDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsNamespaceExportDecl {}
unsafe impl Sync for JavaSwc4jAstTsNamespaceExportDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsNamespaceExportDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsNamespaceExportDecl")
      .expect("Couldn't find class Swc4jAstTsNamespaceExportDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsNamespaceExportDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceExportDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceExportDecl.getId");
    JavaSwc4jAstTsNamespaceExportDecl {
      class,
      method_construct,
      method_get_id,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, span],
        "Swc4jAstTsNamespaceExportDecl construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsNonNullExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsNonNullExpr {}
unsafe impl Sync for JavaSwc4jAstTsNonNullExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstTsNonNullExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsNonNullExpr")
      .expect("Couldn't find class Swc4jAstTsNonNullExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsNonNullExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsNonNullExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsNonNullExpr.getExpr");
    JavaSwc4jAstTsNonNullExpr {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsNonNullExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsOptionalType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsOptionalType {}
unsafe impl Sync for JavaSwc4jAstTsOptionalType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsOptionalType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsOptionalType")
      .expect("Couldn't find class Swc4jAstTsOptionalType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsOptionalType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsOptionalType::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsOptionalType.getTypeAnn");
    JavaSwc4jAstTsOptionalType {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsOptionalType construct()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsParamProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_param: JMethodID,
  method_is_override: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsParamProp {}
unsafe impl Sync for JavaSwc4jAstTsParamProp {}

#[allow(dead_code)]
impl JavaSwc4jAstTsParamProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsParamProp")
      .expect("Couldn't find class Swc4jAstTsParamProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsParamProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsParamPropParam;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.getDecorators");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsParamPropParam;",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.getParam");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.isOverride");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.isReadonly");
    JavaSwc4jAstTsParamProp {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_param,
      method_is_override,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    is_override: bool,
    readonly: bool,
    param: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_override = boolean_to_jvalue!(is_override);
    let readonly = boolean_to_jvalue!(readonly);
    let param = object_to_jvalue!(param);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decorators, accessibility, is_override, readonly, param, span],
        "Swc4jAstTsParamProp construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "ISwc4jAstTsParamPropParam get_param()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsParenthesizedType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsParenthesizedType {}
unsafe impl Sync for JavaSwc4jAstTsParenthesizedType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsParenthesizedType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsParenthesizedType")
      .expect("Couldn't find class Swc4jAstTsParenthesizedType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsParenthesizedType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsParenthesizedType::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsParenthesizedType.getTypeAnn");
    JavaSwc4jAstTsParenthesizedType {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsParenthesizedType construct()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsPropertySignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_init: JMethodID,
  method_get_key: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsPropertySignature {}
unsafe impl Sync for JavaSwc4jAstTsPropertySignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsPropertySignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsPropertySignature")
      .expect("Couldn't find class Swc4jAstTsPropertySignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsPropertySignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature::new");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getInit");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getKey");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getTypeParams");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.isOptional");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.isReadonly");
    JavaSwc4jAstTsPropertySignature {
      class,
      method_construct,
      method_get_init,
      method_get_key,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
      method_is_computed,
      method_is_optional,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    init: &Option<JObject>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let init = optional_object_to_jvalue!(init);
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, key, computed, optional, init, params, type_ann, type_params, span],
        "Swc4jAstTsPropertySignature construct()"
      );
    return_value
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsQualifiedName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsQualifiedName {}
unsafe impl Sync for JavaSwc4jAstTsQualifiedName {}

#[allow(dead_code)]
impl JavaSwc4jAstTsQualifiedName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsQualifiedName")
      .expect("Couldn't find class Swc4jAstTsQualifiedName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsQualifiedName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsQualifiedName::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;",
      )
      .expect("Couldn't find method Swc4jAstTsQualifiedName.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsQualifiedName.getRight");
    JavaSwc4jAstTsQualifiedName {
      class,
      method_construct,
      method_get_left,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[left, right, span],
        "Swc4jAstTsQualifiedName construct()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstTsEntityName get_left()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "Swc4jAstIdent get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsRestType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsRestType {}
unsafe impl Sync for JavaSwc4jAstTsRestType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsRestType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsRestType")
      .expect("Couldn't find class Swc4jAstTsRestType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsRestType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsRestType::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsRestType.getTypeAnn");
    JavaSwc4jAstTsRestType {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsRestType construct()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsSatisfiesExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsSatisfiesExpr {}
unsafe impl Sync for JavaSwc4jAstTsSatisfiesExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstTsSatisfiesExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsSatisfiesExpr")
      .expect("Couldn't find class Swc4jAstTsSatisfiesExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsSatisfiesExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsSatisfiesExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsSatisfiesExpr.getExpr");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsSatisfiesExpr.getTypeAnn");
    JavaSwc4jAstTsSatisfiesExpr {
      class,
      method_construct,
      method_get_expr,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_ann, span],
        "Swc4jAstTsSatisfiesExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsSetterSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_param: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsSetterSignature {}
unsafe impl Sync for JavaSwc4jAstTsSetterSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsSetterSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsSetterSignature")
      .expect("Couldn't find class Swc4jAstTsSetterSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsSetterSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsFnParam;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.getKey");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsFnParam;",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.getParam");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.isOptional");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.isReadonly");
    JavaSwc4jAstTsSetterSignature {
      class,
      method_construct,
      method_get_key,
      method_get_param,
      method_is_computed,
      method_is_optional,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    param: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let param = object_to_jvalue!(param);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, key, computed, optional, param, span],
        "Swc4jAstTsSetterSignature construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      );
    return_value
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "ISwc4jAstTsFnParam get_param()"
      );
    return_value
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsThisType {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsThisType {}
unsafe impl Sync for JavaSwc4jAstTsThisType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsThisType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsThisType")
      .expect("Couldn't find class Swc4jAstTsThisType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsThisType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsThisType::new");
    JavaSwc4jAstTsThisType {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstTsThisType construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTplLitType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_quasis: JMethodID,
  method_get_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTplLitType {}
unsafe impl Sync for JavaSwc4jAstTsTplLitType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTplLitType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTplLitType")
      .expect("Couldn't find class Swc4jAstTsTplLitType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTplLitType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTplLitType::new");
    let method_get_quasis = env
      .get_method_id(
        &class,
        "getQuasis",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTplLitType.getQuasis");
    let method_get_types = env
      .get_method_id(
        &class,
        "getTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTplLitType.getTypes");
    JavaSwc4jAstTsTplLitType {
      class,
      method_construct,
      method_get_quasis,
      method_get_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    types: &JObject<'_>,
    quasis: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let types = object_to_jvalue!(types);
    let quasis = object_to_jvalue!(quasis);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[types, quasis, span],
        "Swc4jAstTsTplLitType construct()"
      );
    return_value
  }

  pub fn get_quasis<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_quasis,
        &[],
        "List get_quasis()"
      );
    return_value
  }

  pub fn get_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_types,
        &[],
        "List get_types()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTupleElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_label: JMethodID,
  method_get_ty: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTupleElement {}
unsafe impl Sync for JavaSwc4jAstTsTupleElement {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTupleElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTupleElement")
      .expect("Couldn't find class Swc4jAstTsTupleElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTupleElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTupleElement::new");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTupleElement.getLabel");
    let method_get_ty = env
      .get_method_id(
        &class,
        "getTy",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTupleElement.getTy");
    JavaSwc4jAstTsTupleElement {
      class,
      method_construct,
      method_get_label,
      method_get_ty,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &Option<JObject>,
    ty: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let label = optional_object_to_jvalue!(label);
    let ty = object_to_jvalue!(ty);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, ty, span],
        "Swc4jAstTsTupleElement construct()"
      );
    return_value
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Optional get_label()"
      );
    return_value
  }

  pub fn get_ty<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ty,
        &[],
        "ISwc4jAstTsType get_ty()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTupleType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elem_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTupleType {}
unsafe impl Sync for JavaSwc4jAstTsTupleType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTupleType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTupleType")
      .expect("Couldn't find class Swc4jAstTsTupleType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTupleType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTupleType::new");
    let method_get_elem_types = env
      .get_method_id(
        &class,
        "getElemTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTupleType.getElemTypes");
    JavaSwc4jAstTsTupleType {
      class,
      method_construct,
      method_get_elem_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elem_types: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let elem_types = object_to_jvalue!(elem_types);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elem_types, span],
        "Swc4jAstTsTupleType construct()"
      );
    return_value
  }

  pub fn get_elem_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elem_types,
        &[],
        "List get_elem_types()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeAliasDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeAliasDecl {}
unsafe impl Sync for JavaSwc4jAstTsTypeAliasDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeAliasDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsTypeAliasDecl")
      .expect("Couldn't find class Swc4jAstTsTypeAliasDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeAliasDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.getId");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.getTypeParams");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.isDeclare");
    JavaSwc4jAstTsTypeAliasDecl {
      class,
      method_construct,
      method_get_id,
      method_get_type_ann,
      method_get_type_params,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    declare: bool,
    type_params: &Option<JObject>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let declare = boolean_to_jvalue!(declare);
    let type_params = optional_object_to_jvalue!(type_params);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, declare, type_params, type_ann, span],
        "Swc4jAstTsTypeAliasDecl construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeAnn {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeAnn {}
unsafe impl Sync for JavaSwc4jAstTsTypeAnn {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeAnn {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn")
      .expect("Couldn't find class Swc4jAstTsTypeAnn");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeAnn");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAnn::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAnn.getTypeAnn");
    JavaSwc4jAstTsTypeAnn {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsTypeAnn construct()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeAssertion {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeAssertion {}
unsafe impl Sync for JavaSwc4jAstTsTypeAssertion {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeAssertion {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsTypeAssertion")
      .expect("Couldn't find class Swc4jAstTsTypeAssertion");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeAssertion");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAssertion::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAssertion.getExpr");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAssertion.getTypeAnn");
    JavaSwc4jAstTsTypeAssertion {
      class,
      method_construct,
      method_get_expr,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_ann, span],
        "Swc4jAstTsTypeAssertion construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeLit {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_members: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeLit {}
unsafe impl Sync for JavaSwc4jAstTsTypeLit {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeLit")
      .expect("Couldn't find class Swc4jAstTsTypeLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeLit");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeLit::new");
    let method_get_members = env
      .get_method_id(
        &class,
        "getMembers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeLit.getMembers");
    JavaSwc4jAstTsTypeLit {
      class,
      method_construct,
      method_get_members,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    members: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let members = object_to_jvalue!(members);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[members, span],
        "Swc4jAstTsTypeLit construct()"
      );
    return_value
  }

  pub fn get_members<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_members,
        &[],
        "List get_members()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeOperator {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_op: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeOperator {}
unsafe impl Sync for JavaSwc4jAstTsTypeOperator {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeOperator {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeOperator")
      .expect("Couldn't find class Swc4jAstTsTypeOperator");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeOperator");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsTypeOperatorOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeOperator::new");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsTypeOperatorOp;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeOperator.getOp");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeOperator.getTypeAnn");
    JavaSwc4jAstTsTypeOperator {
      class,
      method_construct,
      method_get_op,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, type_ann, span],
        "Swc4jAstTsTypeOperator construct()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstTsTypeOperatorOp get_op()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeParam {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_constraint: JMethodID,
  method_get_default: JMethodID,
  method_get_name: JMethodID,
  method_is_const: JMethodID,
  method_is_in: JMethodID,
  method_is_out: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeParam {}
unsafe impl Sync for JavaSwc4jAstTsTypeParam {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeParam {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam")
      .expect("Couldn't find class Swc4jAstTsTypeParam");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeParam");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam::new");
    let method_get_constraint = env
      .get_method_id(
        &class,
        "getConstraint",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.getConstraint");
    let method_get_default = env
      .get_method_id(
        &class,
        "getDefault",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.getDefault");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.getName");
    let method_is_const = env
      .get_method_id(
        &class,
        "isConst",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.isConst");
    let method_is_in = env
      .get_method_id(
        &class,
        "isIn",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.isIn");
    let method_is_out = env
      .get_method_id(
        &class,
        "isOut",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.isOut");
    JavaSwc4jAstTsTypeParam {
      class,
      method_construct,
      method_get_constraint,
      method_get_default,
      method_get_name,
      method_is_const,
      method_is_in,
      method_is_out,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    is_in: bool,
    is_out: bool,
    is_count: bool,
    constraint: &Option<JObject>,
    default: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let is_in = boolean_to_jvalue!(is_in);
    let is_out = boolean_to_jvalue!(is_out);
    let is_count = boolean_to_jvalue!(is_count);
    let constraint = optional_object_to_jvalue!(constraint);
    let default = optional_object_to_jvalue!(default);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, is_in, is_out, is_count, constraint, default, span],
        "Swc4jAstTsTypeParam construct()"
      );
    return_value
  }

  pub fn get_constraint<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_constraint,
        &[],
        "Optional get_constraint()"
      );
    return_value
  }

  pub fn get_default<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_default,
        &[],
        "Optional get_default()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "Swc4jAstIdent get_name()"
      );
    return_value
  }

  pub fn is_const<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_const,
        &[],
        "boolean is_const()"
      );
    return_value
  }

  pub fn is_in<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_in,
        &[],
        "boolean is_in()"
      );
    return_value
  }

  pub fn is_out<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_out,
        &[],
        "boolean is_out()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeParamDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeParamDecl {}
unsafe impl Sync for JavaSwc4jAstTsTypeParamDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeParamDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl")
      .expect("Couldn't find class Swc4jAstTsTypeParamDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeParamDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamDecl::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamDecl.getParams");
    JavaSwc4jAstTsTypeParamDecl {
      class,
      method_construct,
      method_get_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, span],
        "Swc4jAstTsTypeParamDecl construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeParamInstantiation {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeParamInstantiation {}
unsafe impl Sync for JavaSwc4jAstTsTypeParamInstantiation {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeParamInstantiation {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation")
      .expect("Couldn't find class Swc4jAstTsTypeParamInstantiation");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeParamInstantiation");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamInstantiation::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamInstantiation.getParams");
    JavaSwc4jAstTsTypeParamInstantiation {
      class,
      method_construct,
      method_get_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, span],
        "Swc4jAstTsTypeParamInstantiation construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypePredicate {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_param_name: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_asserts: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypePredicate {}
unsafe impl Sync for JavaSwc4jAstTsTypePredicate {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypePredicate {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypePredicate")
      .expect("Couldn't find class Swc4jAstTsTypePredicate");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypePredicate");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsThisTypeOrIdent;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate::new");
    let method_get_param_name = env
      .get_method_id(
        &class,
        "getParamName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsThisTypeOrIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate.getParamName");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate.getTypeAnn");
    let method_is_asserts = env
      .get_method_id(
        &class,
        "isAsserts",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate.isAsserts");
    JavaSwc4jAstTsTypePredicate {
      class,
      method_construct,
      method_get_param_name,
      method_get_type_ann,
      method_is_asserts,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    asserts: bool,
    param_name: &JObject<'_>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let asserts = boolean_to_jvalue!(asserts);
    let param_name = object_to_jvalue!(param_name);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[asserts, param_name, type_ann, span],
        "Swc4jAstTsTypePredicate construct()"
      );
    return_value
  }

  pub fn get_param_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param_name,
        &[],
        "ISwc4jAstTsThisTypeOrIdent get_param_name()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_asserts<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_asserts,
        &[],
        "boolean is_asserts()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeQuery {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr_name: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeQuery {}
unsafe impl Sync for JavaSwc4jAstTsTypeQuery {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeQuery {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeQuery")
      .expect("Couldn't find class Swc4jAstTsTypeQuery");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeQuery");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsTypeQueryExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeQuery::new");
    let method_get_expr_name = env
      .get_method_id(
        &class,
        "getExprName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsTypeQueryExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeQuery.getExprName");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeQuery.getTypeArgs");
    JavaSwc4jAstTsTypeQuery {
      class,
      method_construct,
      method_get_expr_name,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr_name: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr_name = object_to_jvalue!(expr_name);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr_name, type_args, span],
        "Swc4jAstTsTypeQuery construct()"
      );
    return_value
  }

  pub fn get_expr_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr_name,
        &[],
        "ISwc4jAstTsTypeQueryExpr get_expr_name()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeRef {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_name: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeRef {}
unsafe impl Sync for JavaSwc4jAstTsTypeRef {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeRef {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeRef")
      .expect("Couldn't find class Swc4jAstTsTypeRef");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeRef");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeRef::new");
    let method_get_type_name = env
      .get_method_id(
        &class,
        "getTypeName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeRef.getTypeName");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeRef.getTypeParams");
    JavaSwc4jAstTsTypeRef {
      class,
      method_construct,
      method_get_type_name,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_name: &JObject<'_>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_name = object_to_jvalue!(type_name);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_name, type_params, span],
        "Swc4jAstTsTypeRef construct()"
      );
    return_value
  }

  pub fn get_type_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_name,
        &[],
        "ISwc4jAstTsEntityName get_type_name()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsUnionType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsUnionType {}
unsafe impl Sync for JavaSwc4jAstTsUnionType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsUnionType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsUnionType")
      .expect("Couldn't find class Swc4jAstTsUnionType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsUnionType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsUnionType::new");
    let method_get_types = env
      .get_method_id(
        &class,
        "getTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsUnionType.getTypes");
    JavaSwc4jAstTsUnionType {
      class,
      method_construct,
      method_get_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    types: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let types = object_to_jvalue!(types);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[types, span],
        "Swc4jAstTsUnionType construct()"
      );
    return_value
  }

  pub fn get_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_types,
        &[],
        "List get_types()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstUnaryExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_op: JMethodID,
}
unsafe impl Send for JavaSwc4jAstUnaryExpr {}
unsafe impl Sync for JavaSwc4jAstUnaryExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstUnaryExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstUnaryExpr")
      .expect("Couldn't find class Swc4jAstUnaryExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstUnaryExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUnaryOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstUnaryExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstUnaryExpr.getArg");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUnaryOp;",
      )
      .expect("Couldn't find method Swc4jAstUnaryExpr.getOp");
    JavaSwc4jAstUnaryExpr {
      class,
      method_construct,
      method_get_arg,
      method_get_op,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, arg, span],
        "Swc4jAstUnaryExpr construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstUnaryOp get_op()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstUpdateExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_op: JMethodID,
  method_is_prefix: JMethodID,
}
unsafe impl Send for JavaSwc4jAstUpdateExpr {}
unsafe impl Sync for JavaSwc4jAstUpdateExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstUpdateExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstUpdateExpr")
      .expect("Couldn't find class Swc4jAstUpdateExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstUpdateExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUpdateOp;ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr.getArg");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUpdateOp;",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr.getOp");
    let method_is_prefix = env
      .get_method_id(
        &class,
        "isPrefix",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr.isPrefix");
    JavaSwc4jAstUpdateExpr {
      class,
      method_construct,
      method_get_arg,
      method_get_op,
      method_is_prefix,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    prefix: bool,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let prefix = boolean_to_jvalue!(prefix);
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, prefix, arg, span],
        "Swc4jAstUpdateExpr construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstUpdateOp get_op()"
      );
    return_value
  }

  pub fn is_prefix<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_prefix,
        &[],
        "boolean is_prefix()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstUsingDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decls: JMethodID,
  method_is_await: JMethodID,
}
unsafe impl Send for JavaSwc4jAstUsingDecl {}
unsafe impl Sync for JavaSwc4jAstUsingDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstUsingDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstUsingDecl")
      .expect("Couldn't find class Swc4jAstUsingDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstUsingDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLjava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstUsingDecl::new");
    let method_get_decls = env
      .get_method_id(
        &class,
        "getDecls",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstUsingDecl.getDecls");
    let method_is_await = env
      .get_method_id(
        &class,
        "isAwait",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstUsingDecl.isAwait");
    JavaSwc4jAstUsingDecl {
      class,
      method_construct,
      method_get_decls,
      method_is_await,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    is_await: bool,
    decls: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let is_await = boolean_to_jvalue!(is_await);
    let decls = object_to_jvalue!(decls);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[is_await, decls, span],
        "Swc4jAstUsingDecl construct()"
      );
    return_value
  }

  pub fn get_decls<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decls,
        &[],
        "List get_decls()"
      );
    return_value
  }

  pub fn is_await<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_await,
        &[],
        "boolean is_await()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstVarDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decls: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstVarDecl {}
unsafe impl Sync for JavaSwc4jAstVarDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstVarDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstVarDecl")
      .expect("Couldn't find class Swc4jAstVarDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstVarDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstVarDeclKind;ZLjava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstVarDecl::new");
    let method_get_decls = env
      .get_method_id(
        &class,
        "getDecls",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstVarDecl.getDecls");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstVarDecl.isDeclare");
    JavaSwc4jAstVarDecl {
      class,
      method_construct,
      method_get_decls,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    kind: &JObject<'_>,
    declare: bool,
    decls: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let kind = object_to_jvalue!(kind);
    let declare = boolean_to_jvalue!(declare);
    let decls = object_to_jvalue!(decls);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[kind, declare, decls, span],
        "Swc4jAstVarDecl construct()"
      );
    return_value
  }

  pub fn get_decls<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decls,
        &[],
        "List get_decls()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstVarDeclarator {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_init: JMethodID,
  method_get_name: JMethodID,
  method_is_definite: JMethodID,
}
unsafe impl Send for JavaSwc4jAstVarDeclarator {}
unsafe impl Sync for JavaSwc4jAstVarDeclarator {}

#[allow(dead_code)]
impl JavaSwc4jAstVarDeclarator {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstVarDeclarator")
      .expect("Couldn't find class Swc4jAstVarDeclarator");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstVarDeclarator");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator::new");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator.getInit");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator.getName");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator.isDefinite");
    JavaSwc4jAstVarDeclarator {
      class,
      method_construct,
      method_get_init,
      method_get_name,
      method_is_definite,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    init: &Option<JObject>,
    definite: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let init = optional_object_to_jvalue!(init);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, init, definite, span],
        "Swc4jAstVarDeclarator construct()"
      );
    return_value
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstPat get_name()"
      );
    return_value
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstWhileStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstWhileStmt {}
unsafe impl Sync for JavaSwc4jAstWhileStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstWhileStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstWhileStmt")
      .expect("Couldn't find class Swc4jAstWhileStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstWhileStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstWhileStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstWhileStmt.getBody");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstWhileStmt.getTest");
    JavaSwc4jAstWhileStmt {
      class,
      method_construct,
      method_get_body,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, body, span],
        "Swc4jAstWhileStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstWithStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_obj: JMethodID,
}
unsafe impl Send for JavaSwc4jAstWithStmt {}
unsafe impl Sync for JavaSwc4jAstWithStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstWithStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstWithStmt")
      .expect("Couldn't find class Swc4jAstWithStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstWithStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstWithStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstWithStmt.getBody");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstWithStmt.getObj");
    JavaSwc4jAstWithStmt {
      class,
      method_construct,
      method_get_body,
      method_get_obj,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, body, span],
        "Swc4jAstWithStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "ISwc4jAstExpr get_obj()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstYieldExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_is_delegate: JMethodID,
}
unsafe impl Send for JavaSwc4jAstYieldExpr {}
unsafe impl Sync for JavaSwc4jAstYieldExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstYieldExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstYieldExpr")
      .expect("Couldn't find class Swc4jAstYieldExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstYieldExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstYieldExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstYieldExpr.getArg");
    let method_is_delegate = env
      .get_method_id(
        &class,
        "isDelegate",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstYieldExpr.isDelegate");
    JavaSwc4jAstYieldExpr {
      class,
      method_construct,
      method_get_arg,
      method_is_delegate,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &Option<JObject>,
    delegate: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = optional_object_to_jvalue!(arg);
    let delegate = boolean_to_jvalue!(delegate);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, delegate, span],
        "Swc4jAstYieldExpr construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "Optional get_arg()"
      );
    return_value
  }

  pub fn is_delegate<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_delegate,
        &[],
        "boolean is_delegate()"
      );
    return_value
  }
}

static mut JAVA_CLASS_ARRAY_LIT: Option<JavaSwc4jAstArrayLit> = None;
static mut JAVA_CLASS_ARRAY_PAT: Option<JavaSwc4jAstArrayPat> = None;
static mut JAVA_CLASS_ARROW_EXPR: Option<JavaSwc4jAstArrowExpr> = None;
static mut JAVA_CLASS_ASSIGN_EXPR: Option<JavaSwc4jAstAssignExpr> = None;
static mut JAVA_CLASS_ASSIGN_PAT: Option<JavaSwc4jAstAssignPat> = None;
static mut JAVA_CLASS_ASSIGN_PAT_PROP: Option<JavaSwc4jAstAssignPatProp> = None;
static mut JAVA_CLASS_ASSIGN_PROP: Option<JavaSwc4jAstAssignProp> = None;
static mut JAVA_CLASS_AUTO_ACCESSOR: Option<JavaSwc4jAstAutoAccessor> = None;
static mut JAVA_CLASS_AWAIT_EXPR: Option<JavaSwc4jAstAwaitExpr> = None;
static mut JAVA_CLASS_BIG_INT: Option<JavaSwc4jAstBigInt> = None;
static mut JAVA_CLASS_BIN_EXPR: Option<JavaSwc4jAstBinExpr> = None;
static mut JAVA_CLASS_BINDING_IDENT: Option<JavaSwc4jAstBindingIdent> = None;
static mut JAVA_CLASS_BLOCK_STMT: Option<JavaSwc4jAstBlockStmt> = None;
static mut JAVA_CLASS_BOOL: Option<JavaSwc4jAstBool> = None;
static mut JAVA_CLASS_BREAK_STMT: Option<JavaSwc4jAstBreakStmt> = None;
static mut JAVA_CLASS_CALL_EXPR: Option<JavaSwc4jAstCallExpr> = None;
static mut JAVA_CLASS_CATCH_CLAUSE: Option<JavaSwc4jAstCatchClause> = None;
static mut JAVA_CLASS_CLASS: Option<JavaSwc4jAstClass> = None;
static mut JAVA_CLASS_CLASS_DECL: Option<JavaSwc4jAstClassDecl> = None;
static mut JAVA_CLASS_CLASS_EXPR: Option<JavaSwc4jAstClassExpr> = None;
static mut JAVA_CLASS_CLASS_METHOD: Option<JavaSwc4jAstClassMethod> = None;
static mut JAVA_CLASS_CLASS_PROP: Option<JavaSwc4jAstClassProp> = None;
static mut JAVA_CLASS_COMPUTED_PROP_NAME: Option<JavaSwc4jAstComputedPropName> = None;
static mut JAVA_CLASS_COND_EXPR: Option<JavaSwc4jAstCondExpr> = None;
static mut JAVA_CLASS_CONSTRUCTOR: Option<JavaSwc4jAstConstructor> = None;
static mut JAVA_CLASS_CONTINUE_STMT: Option<JavaSwc4jAstContinueStmt> = None;
static mut JAVA_CLASS_DEBUGGER_STMT: Option<JavaSwc4jAstDebuggerStmt> = None;
static mut JAVA_CLASS_DECORATOR: Option<JavaSwc4jAstDecorator> = None;
static mut JAVA_CLASS_DO_WHILE_STMT: Option<JavaSwc4jAstDoWhileStmt> = None;
static mut JAVA_CLASS_EMPTY_STMT: Option<JavaSwc4jAstEmptyStmt> = None;
static mut JAVA_CLASS_EXPORT_ALL: Option<JavaSwc4jAstExportAll> = None;
static mut JAVA_CLASS_EXPORT_DECL: Option<JavaSwc4jAstExportDecl> = None;
static mut JAVA_CLASS_EXPORT_DEFAULT_DECL: Option<JavaSwc4jAstExportDefaultDecl> = None;
static mut JAVA_CLASS_EXPORT_DEFAULT_EXPR: Option<JavaSwc4jAstExportDefaultExpr> = None;
static mut JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER: Option<JavaSwc4jAstExportDefaultSpecifier> = None;
static mut JAVA_CLASS_EXPORT_NAMED_SPECIFIER: Option<JavaSwc4jAstExportNamedSpecifier> = None;
static mut JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER: Option<JavaSwc4jAstExportNamespaceSpecifier> = None;
static mut JAVA_CLASS_EXPR_OR_SPREAD: Option<JavaSwc4jAstExprOrSpread> = None;
static mut JAVA_CLASS_EXPR_STMT: Option<JavaSwc4jAstExprStmt> = None;
static mut JAVA_CLASS_FN_DECL: Option<JavaSwc4jAstFnDecl> = None;
static mut JAVA_CLASS_FN_EXPR: Option<JavaSwc4jAstFnExpr> = None;
static mut JAVA_CLASS_FOR_IN_STMT: Option<JavaSwc4jAstForInStmt> = None;
static mut JAVA_CLASS_FOR_OF_STMT: Option<JavaSwc4jAstForOfStmt> = None;
static mut JAVA_CLASS_FOR_STMT: Option<JavaSwc4jAstForStmt> = None;
static mut JAVA_CLASS_FUNCTION: Option<JavaSwc4jAstFunction> = None;
static mut JAVA_CLASS_GETTER_PROP: Option<JavaSwc4jAstGetterProp> = None;
static mut JAVA_CLASS_IDENT: Option<JavaSwc4jAstIdent> = None;
static mut JAVA_CLASS_IF_STMT: Option<JavaSwc4jAstIfStmt> = None;
static mut JAVA_CLASS_IMPORT: Option<JavaSwc4jAstImport> = None;
static mut JAVA_CLASS_IMPORT_DECL: Option<JavaSwc4jAstImportDecl> = None;
static mut JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER: Option<JavaSwc4jAstImportDefaultSpecifier> = None;
static mut JAVA_CLASS_IMPORT_NAMED_SPECIFIER: Option<JavaSwc4jAstImportNamedSpecifier> = None;
static mut JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER: Option<JavaSwc4jAstImportStarAsSpecifier> = None;
static mut JAVA_CLASS_INVALID: Option<JavaSwc4jAstInvalid> = None;
static mut JAVA_CLASS_JSX_ATTR: Option<JavaSwc4jAstJsxAttr> = None;
static mut JAVA_CLASS_JSX_CLOSING_ELEMENT: Option<JavaSwc4jAstJsxClosingElement> = None;
static mut JAVA_CLASS_JSX_CLOSING_FRAGMENT: Option<JavaSwc4jAstJsxClosingFragment> = None;
static mut JAVA_CLASS_JSX_ELEMENT: Option<JavaSwc4jAstJsxElement> = None;
static mut JAVA_CLASS_JSX_EMPTY_EXPR: Option<JavaSwc4jAstJsxEmptyExpr> = None;
static mut JAVA_CLASS_JSX_EXPR_CONTAINER: Option<JavaSwc4jAstJsxExprContainer> = None;
static mut JAVA_CLASS_JSX_FRAGMENT: Option<JavaSwc4jAstJsxFragment> = None;
static mut JAVA_CLASS_JSX_MEMBER_EXPR: Option<JavaSwc4jAstJsxMemberExpr> = None;
static mut JAVA_CLASS_JSX_NAMESPACED_NAME: Option<JavaSwc4jAstJsxNamespacedName> = None;
static mut JAVA_CLASS_JSX_OPENING_ELEMENT: Option<JavaSwc4jAstJsxOpeningElement> = None;
static mut JAVA_CLASS_JSX_OPENING_FRAGMENT: Option<JavaSwc4jAstJsxOpeningFragment> = None;
static mut JAVA_CLASS_JSX_SPREAD_CHILD: Option<JavaSwc4jAstJsxSpreadChild> = None;
static mut JAVA_CLASS_JSX_TEXT: Option<JavaSwc4jAstJsxText> = None;
static mut JAVA_CLASS_KEY_VALUE_PAT_PROP: Option<JavaSwc4jAstKeyValuePatProp> = None;
static mut JAVA_CLASS_KEY_VALUE_PROP: Option<JavaSwc4jAstKeyValueProp> = None;
static mut JAVA_CLASS_LABELED_STMT: Option<JavaSwc4jAstLabeledStmt> = None;
static mut JAVA_CLASS_MEMBER_EXPR: Option<JavaSwc4jAstMemberExpr> = None;
static mut JAVA_CLASS_META_PROP_EXPR: Option<JavaSwc4jAstMetaPropExpr> = None;
static mut JAVA_CLASS_METHOD_PROP: Option<JavaSwc4jAstMethodProp> = None;
static mut JAVA_CLASS_MODULE: Option<JavaSwc4jAstModule> = None;
static mut JAVA_CLASS_NAMED_EXPORT: Option<JavaSwc4jAstNamedExport> = None;
static mut JAVA_CLASS_NEW_EXPR: Option<JavaSwc4jAstNewExpr> = None;
static mut JAVA_CLASS_NULL: Option<JavaSwc4jAstNull> = None;
static mut JAVA_CLASS_NUMBER: Option<JavaSwc4jAstNumber> = None;
static mut JAVA_CLASS_OBJECT_LIT: Option<JavaSwc4jAstObjectLit> = None;
static mut JAVA_CLASS_OBJECT_PAT: Option<JavaSwc4jAstObjectPat> = None;
static mut JAVA_CLASS_OPT_CALL: Option<JavaSwc4jAstOptCall> = None;
static mut JAVA_CLASS_OPT_CHAIN_EXPR: Option<JavaSwc4jAstOptChainExpr> = None;
static mut JAVA_CLASS_PARAM: Option<JavaSwc4jAstParam> = None;
static mut JAVA_CLASS_PAREN_EXPR: Option<JavaSwc4jAstParenExpr> = None;
static mut JAVA_CLASS_PRIVATE_METHOD: Option<JavaSwc4jAstPrivateMethod> = None;
static mut JAVA_CLASS_PRIVATE_NAME: Option<JavaSwc4jAstPrivateName> = None;
static mut JAVA_CLASS_PRIVATE_PROP: Option<JavaSwc4jAstPrivateProp> = None;
static mut JAVA_CLASS_REGEX: Option<JavaSwc4jAstRegex> = None;
static mut JAVA_CLASS_REST_PAT: Option<JavaSwc4jAstRestPat> = None;
static mut JAVA_CLASS_RETURN_STMT: Option<JavaSwc4jAstReturnStmt> = None;
static mut JAVA_CLASS_SCRIPT: Option<JavaSwc4jAstScript> = None;
static mut JAVA_CLASS_SEQ_EXPR: Option<JavaSwc4jAstSeqExpr> = None;
static mut JAVA_CLASS_SETTER_PROP: Option<JavaSwc4jAstSetterProp> = None;
static mut JAVA_CLASS_SPREAD_ELEMENT: Option<JavaSwc4jAstSpreadElement> = None;
static mut JAVA_CLASS_STATIC_BLOCK: Option<JavaSwc4jAstStaticBlock> = None;
static mut JAVA_CLASS_STR: Option<JavaSwc4jAstStr> = None;
static mut JAVA_CLASS_SUPER: Option<JavaSwc4jAstSuper> = None;
static mut JAVA_CLASS_SUPER_PROP_EXPR: Option<JavaSwc4jAstSuperPropExpr> = None;
static mut JAVA_CLASS_SWITCH_CASE: Option<JavaSwc4jAstSwitchCase> = None;
static mut JAVA_CLASS_SWITCH_STMT: Option<JavaSwc4jAstSwitchStmt> = None;
static mut JAVA_CLASS_TAGGED_TPL: Option<JavaSwc4jAstTaggedTpl> = None;
static mut JAVA_CLASS_THIS_EXPR: Option<JavaSwc4jAstThisExpr> = None;
static mut JAVA_CLASS_THROW_STMT: Option<JavaSwc4jAstThrowStmt> = None;
static mut JAVA_CLASS_TPL: Option<JavaSwc4jAstTpl> = None;
static mut JAVA_CLASS_TPL_ELEMENT: Option<JavaSwc4jAstTplElement> = None;
static mut JAVA_CLASS_TRY_STMT: Option<JavaSwc4jAstTryStmt> = None;
static mut JAVA_CLASS_TS_ARRAY_TYPE: Option<JavaSwc4jAstTsArrayType> = None;
static mut JAVA_CLASS_TS_AS_EXPR: Option<JavaSwc4jAstTsAsExpr> = None;
static mut JAVA_CLASS_TS_CALL_SIGNATURE_DECL: Option<JavaSwc4jAstTsCallSignatureDecl> = None;
static mut JAVA_CLASS_TS_CONDITIONAL_TYPE: Option<JavaSwc4jAstTsConditionalType> = None;
static mut JAVA_CLASS_TS_CONST_ASSERTION: Option<JavaSwc4jAstTsConstAssertion> = None;
static mut JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL: Option<JavaSwc4jAstTsConstructSignatureDecl> = None;
static mut JAVA_CLASS_TS_CONSTRUCTOR_TYPE: Option<JavaSwc4jAstTsConstructorType> = None;
static mut JAVA_CLASS_TS_ENUM_DECL: Option<JavaSwc4jAstTsEnumDecl> = None;
static mut JAVA_CLASS_TS_ENUM_MEMBER: Option<JavaSwc4jAstTsEnumMember> = None;
static mut JAVA_CLASS_TS_EXPORT_ASSIGNMENT: Option<JavaSwc4jAstTsExportAssignment> = None;
static mut JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS: Option<JavaSwc4jAstTsExprWithTypeArgs> = None;
static mut JAVA_CLASS_TS_EXTERNAL_MODULE_REF: Option<JavaSwc4jAstTsExternalModuleRef> = None;
static mut JAVA_CLASS_TS_FN_TYPE: Option<JavaSwc4jAstTsFnType> = None;
static mut JAVA_CLASS_TS_GETTER_SIGNATURE: Option<JavaSwc4jAstTsGetterSignature> = None;
static mut JAVA_CLASS_TS_IMPORT_EQUALS_DECL: Option<JavaSwc4jAstTsImportEqualsDecl> = None;
static mut JAVA_CLASS_TS_IMPORT_TYPE: Option<JavaSwc4jAstTsImportType> = None;
static mut JAVA_CLASS_TS_INDEX_SIGNATURE: Option<JavaSwc4jAstTsIndexSignature> = None;
static mut JAVA_CLASS_TS_INDEXED_ACCESS_TYPE: Option<JavaSwc4jAstTsIndexedAccessType> = None;
static mut JAVA_CLASS_TS_INFER_TYPE: Option<JavaSwc4jAstTsInferType> = None;
static mut JAVA_CLASS_TS_INSTANTIATION: Option<JavaSwc4jAstTsInstantiation> = None;
static mut JAVA_CLASS_TS_INTERFACE_BODY: Option<JavaSwc4jAstTsInterfaceBody> = None;
static mut JAVA_CLASS_TS_INTERFACE_DECL: Option<JavaSwc4jAstTsInterfaceDecl> = None;
static mut JAVA_CLASS_TS_INTERSECTION_TYPE: Option<JavaSwc4jAstTsIntersectionType> = None;
static mut JAVA_CLASS_TS_KEYWORD_TYPE: Option<JavaSwc4jAstTsKeywordType> = None;
static mut JAVA_CLASS_TS_LIT_TYPE: Option<JavaSwc4jAstTsLitType> = None;
static mut JAVA_CLASS_TS_MAPPED_TYPE: Option<JavaSwc4jAstTsMappedType> = None;
static mut JAVA_CLASS_TS_METHOD_SIGNATURE: Option<JavaSwc4jAstTsMethodSignature> = None;
static mut JAVA_CLASS_TS_MODULE_BLOCK: Option<JavaSwc4jAstTsModuleBlock> = None;
static mut JAVA_CLASS_TS_MODULE_DECL: Option<JavaSwc4jAstTsModuleDecl> = None;
static mut JAVA_CLASS_TS_NAMESPACE_DECL: Option<JavaSwc4jAstTsNamespaceDecl> = None;
static mut JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL: Option<JavaSwc4jAstTsNamespaceExportDecl> = None;
static mut JAVA_CLASS_TS_NON_NULL_EXPR: Option<JavaSwc4jAstTsNonNullExpr> = None;
static mut JAVA_CLASS_TS_OPTIONAL_TYPE: Option<JavaSwc4jAstTsOptionalType> = None;
static mut JAVA_CLASS_TS_PARAM_PROP: Option<JavaSwc4jAstTsParamProp> = None;
static mut JAVA_CLASS_TS_PARENTHESIZED_TYPE: Option<JavaSwc4jAstTsParenthesizedType> = None;
static mut JAVA_CLASS_TS_PROPERTY_SIGNATURE: Option<JavaSwc4jAstTsPropertySignature> = None;
static mut JAVA_CLASS_TS_QUALIFIED_NAME: Option<JavaSwc4jAstTsQualifiedName> = None;
static mut JAVA_CLASS_TS_REST_TYPE: Option<JavaSwc4jAstTsRestType> = None;
static mut JAVA_CLASS_TS_SATISFIES_EXPR: Option<JavaSwc4jAstTsSatisfiesExpr> = None;
static mut JAVA_CLASS_TS_SETTER_SIGNATURE: Option<JavaSwc4jAstTsSetterSignature> = None;
static mut JAVA_CLASS_TS_THIS_TYPE: Option<JavaSwc4jAstTsThisType> = None;
static mut JAVA_CLASS_TS_TPL_LIT_TYPE: Option<JavaSwc4jAstTsTplLitType> = None;
static mut JAVA_CLASS_TS_TUPLE_ELEMENT: Option<JavaSwc4jAstTsTupleElement> = None;
static mut JAVA_CLASS_TS_TUPLE_TYPE: Option<JavaSwc4jAstTsTupleType> = None;
static mut JAVA_CLASS_TS_TYPE_ALIAS_DECL: Option<JavaSwc4jAstTsTypeAliasDecl> = None;
static mut JAVA_CLASS_TS_TYPE_ANN: Option<JavaSwc4jAstTsTypeAnn> = None;
static mut JAVA_CLASS_TS_TYPE_ASSERTION: Option<JavaSwc4jAstTsTypeAssertion> = None;
static mut JAVA_CLASS_TS_TYPE_LIT: Option<JavaSwc4jAstTsTypeLit> = None;
static mut JAVA_CLASS_TS_TYPE_OPERATOR: Option<JavaSwc4jAstTsTypeOperator> = None;
static mut JAVA_CLASS_TS_TYPE_PARAM: Option<JavaSwc4jAstTsTypeParam> = None;
static mut JAVA_CLASS_TS_TYPE_PARAM_DECL: Option<JavaSwc4jAstTsTypeParamDecl> = None;
static mut JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION: Option<JavaSwc4jAstTsTypeParamInstantiation> = None;
static mut JAVA_CLASS_TS_TYPE_PREDICATE: Option<JavaSwc4jAstTsTypePredicate> = None;
static mut JAVA_CLASS_TS_TYPE_QUERY: Option<JavaSwc4jAstTsTypeQuery> = None;
static mut JAVA_CLASS_TS_TYPE_REF: Option<JavaSwc4jAstTsTypeRef> = None;
static mut JAVA_CLASS_TS_UNION_TYPE: Option<JavaSwc4jAstTsUnionType> = None;
static mut JAVA_CLASS_UNARY_EXPR: Option<JavaSwc4jAstUnaryExpr> = None;
static mut JAVA_CLASS_UPDATE_EXPR: Option<JavaSwc4jAstUpdateExpr> = None;
static mut JAVA_CLASS_USING_DECL: Option<JavaSwc4jAstUsingDecl> = None;
static mut JAVA_CLASS_VAR_DECL: Option<JavaSwc4jAstVarDecl> = None;
static mut JAVA_CLASS_VAR_DECLARATOR: Option<JavaSwc4jAstVarDeclarator> = None;
static mut JAVA_CLASS_WHILE_STMT: Option<JavaSwc4jAstWhileStmt> = None;
static mut JAVA_CLASS_WITH_STMT: Option<JavaSwc4jAstWithStmt> = None;
static mut JAVA_CLASS_YIELD_EXPR: Option<JavaSwc4jAstYieldExpr> = None;

unsafe fn init_ast_classes<'local>(env: &mut JNIEnv<'local>) {
  JAVA_CLASS_ARRAY_LIT = Some(JavaSwc4jAstArrayLit::new(env));
  JAVA_CLASS_ARRAY_PAT = Some(JavaSwc4jAstArrayPat::new(env));
  JAVA_CLASS_ARROW_EXPR = Some(JavaSwc4jAstArrowExpr::new(env));
  JAVA_CLASS_ASSIGN_EXPR = Some(JavaSwc4jAstAssignExpr::new(env));
  JAVA_CLASS_ASSIGN_PAT = Some(JavaSwc4jAstAssignPat::new(env));
  JAVA_CLASS_ASSIGN_PAT_PROP = Some(JavaSwc4jAstAssignPatProp::new(env));
  JAVA_CLASS_ASSIGN_PROP = Some(JavaSwc4jAstAssignProp::new(env));
  JAVA_CLASS_AUTO_ACCESSOR = Some(JavaSwc4jAstAutoAccessor::new(env));
  JAVA_CLASS_AWAIT_EXPR = Some(JavaSwc4jAstAwaitExpr::new(env));
  JAVA_CLASS_BIG_INT = Some(JavaSwc4jAstBigInt::new(env));
  JAVA_CLASS_BIN_EXPR = Some(JavaSwc4jAstBinExpr::new(env));
  JAVA_CLASS_BINDING_IDENT = Some(JavaSwc4jAstBindingIdent::new(env));
  JAVA_CLASS_BLOCK_STMT = Some(JavaSwc4jAstBlockStmt::new(env));
  JAVA_CLASS_BOOL = Some(JavaSwc4jAstBool::new(env));
  JAVA_CLASS_BREAK_STMT = Some(JavaSwc4jAstBreakStmt::new(env));
  JAVA_CLASS_CALL_EXPR = Some(JavaSwc4jAstCallExpr::new(env));
  JAVA_CLASS_CATCH_CLAUSE = Some(JavaSwc4jAstCatchClause::new(env));
  JAVA_CLASS_CLASS = Some(JavaSwc4jAstClass::new(env));
  JAVA_CLASS_CLASS_DECL = Some(JavaSwc4jAstClassDecl::new(env));
  JAVA_CLASS_CLASS_EXPR = Some(JavaSwc4jAstClassExpr::new(env));
  JAVA_CLASS_CLASS_METHOD = Some(JavaSwc4jAstClassMethod::new(env));
  JAVA_CLASS_CLASS_PROP = Some(JavaSwc4jAstClassProp::new(env));
  JAVA_CLASS_COMPUTED_PROP_NAME = Some(JavaSwc4jAstComputedPropName::new(env));
  JAVA_CLASS_COND_EXPR = Some(JavaSwc4jAstCondExpr::new(env));
  JAVA_CLASS_CONSTRUCTOR = Some(JavaSwc4jAstConstructor::new(env));
  JAVA_CLASS_CONTINUE_STMT = Some(JavaSwc4jAstContinueStmt::new(env));
  JAVA_CLASS_DEBUGGER_STMT = Some(JavaSwc4jAstDebuggerStmt::new(env));
  JAVA_CLASS_DECORATOR = Some(JavaSwc4jAstDecorator::new(env));
  JAVA_CLASS_DO_WHILE_STMT = Some(JavaSwc4jAstDoWhileStmt::new(env));
  JAVA_CLASS_EMPTY_STMT = Some(JavaSwc4jAstEmptyStmt::new(env));
  JAVA_CLASS_EXPORT_ALL = Some(JavaSwc4jAstExportAll::new(env));
  JAVA_CLASS_EXPORT_DECL = Some(JavaSwc4jAstExportDecl::new(env));
  JAVA_CLASS_EXPORT_DEFAULT_DECL = Some(JavaSwc4jAstExportDefaultDecl::new(env));
  JAVA_CLASS_EXPORT_DEFAULT_EXPR = Some(JavaSwc4jAstExportDefaultExpr::new(env));
  JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER = Some(JavaSwc4jAstExportDefaultSpecifier::new(env));
  JAVA_CLASS_EXPORT_NAMED_SPECIFIER = Some(JavaSwc4jAstExportNamedSpecifier::new(env));
  JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER = Some(JavaSwc4jAstExportNamespaceSpecifier::new(env));
  JAVA_CLASS_EXPR_OR_SPREAD = Some(JavaSwc4jAstExprOrSpread::new(env));
  JAVA_CLASS_EXPR_STMT = Some(JavaSwc4jAstExprStmt::new(env));
  JAVA_CLASS_FN_DECL = Some(JavaSwc4jAstFnDecl::new(env));
  JAVA_CLASS_FN_EXPR = Some(JavaSwc4jAstFnExpr::new(env));
  JAVA_CLASS_FOR_IN_STMT = Some(JavaSwc4jAstForInStmt::new(env));
  JAVA_CLASS_FOR_OF_STMT = Some(JavaSwc4jAstForOfStmt::new(env));
  JAVA_CLASS_FOR_STMT = Some(JavaSwc4jAstForStmt::new(env));
  JAVA_CLASS_FUNCTION = Some(JavaSwc4jAstFunction::new(env));
  JAVA_CLASS_GETTER_PROP = Some(JavaSwc4jAstGetterProp::new(env));
  JAVA_CLASS_IDENT = Some(JavaSwc4jAstIdent::new(env));
  JAVA_CLASS_IF_STMT = Some(JavaSwc4jAstIfStmt::new(env));
  JAVA_CLASS_IMPORT = Some(JavaSwc4jAstImport::new(env));
  JAVA_CLASS_IMPORT_DECL = Some(JavaSwc4jAstImportDecl::new(env));
  JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER = Some(JavaSwc4jAstImportDefaultSpecifier::new(env));
  JAVA_CLASS_IMPORT_NAMED_SPECIFIER = Some(JavaSwc4jAstImportNamedSpecifier::new(env));
  JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER = Some(JavaSwc4jAstImportStarAsSpecifier::new(env));
  JAVA_CLASS_INVALID = Some(JavaSwc4jAstInvalid::new(env));
  JAVA_CLASS_JSX_ATTR = Some(JavaSwc4jAstJsxAttr::new(env));
  JAVA_CLASS_JSX_CLOSING_ELEMENT = Some(JavaSwc4jAstJsxClosingElement::new(env));
  JAVA_CLASS_JSX_CLOSING_FRAGMENT = Some(JavaSwc4jAstJsxClosingFragment::new(env));
  JAVA_CLASS_JSX_ELEMENT = Some(JavaSwc4jAstJsxElement::new(env));
  JAVA_CLASS_JSX_EMPTY_EXPR = Some(JavaSwc4jAstJsxEmptyExpr::new(env));
  JAVA_CLASS_JSX_EXPR_CONTAINER = Some(JavaSwc4jAstJsxExprContainer::new(env));
  JAVA_CLASS_JSX_FRAGMENT = Some(JavaSwc4jAstJsxFragment::new(env));
  JAVA_CLASS_JSX_MEMBER_EXPR = Some(JavaSwc4jAstJsxMemberExpr::new(env));
  JAVA_CLASS_JSX_NAMESPACED_NAME = Some(JavaSwc4jAstJsxNamespacedName::new(env));
  JAVA_CLASS_JSX_OPENING_ELEMENT = Some(JavaSwc4jAstJsxOpeningElement::new(env));
  JAVA_CLASS_JSX_OPENING_FRAGMENT = Some(JavaSwc4jAstJsxOpeningFragment::new(env));
  JAVA_CLASS_JSX_SPREAD_CHILD = Some(JavaSwc4jAstJsxSpreadChild::new(env));
  JAVA_CLASS_JSX_TEXT = Some(JavaSwc4jAstJsxText::new(env));
  JAVA_CLASS_KEY_VALUE_PAT_PROP = Some(JavaSwc4jAstKeyValuePatProp::new(env));
  JAVA_CLASS_KEY_VALUE_PROP = Some(JavaSwc4jAstKeyValueProp::new(env));
  JAVA_CLASS_LABELED_STMT = Some(JavaSwc4jAstLabeledStmt::new(env));
  JAVA_CLASS_MEMBER_EXPR = Some(JavaSwc4jAstMemberExpr::new(env));
  JAVA_CLASS_META_PROP_EXPR = Some(JavaSwc4jAstMetaPropExpr::new(env));
  JAVA_CLASS_METHOD_PROP = Some(JavaSwc4jAstMethodProp::new(env));
  JAVA_CLASS_MODULE = Some(JavaSwc4jAstModule::new(env));
  JAVA_CLASS_NAMED_EXPORT = Some(JavaSwc4jAstNamedExport::new(env));
  JAVA_CLASS_NEW_EXPR = Some(JavaSwc4jAstNewExpr::new(env));
  JAVA_CLASS_NULL = Some(JavaSwc4jAstNull::new(env));
  JAVA_CLASS_NUMBER = Some(JavaSwc4jAstNumber::new(env));
  JAVA_CLASS_OBJECT_LIT = Some(JavaSwc4jAstObjectLit::new(env));
  JAVA_CLASS_OBJECT_PAT = Some(JavaSwc4jAstObjectPat::new(env));
  JAVA_CLASS_OPT_CALL = Some(JavaSwc4jAstOptCall::new(env));
  JAVA_CLASS_OPT_CHAIN_EXPR = Some(JavaSwc4jAstOptChainExpr::new(env));
  JAVA_CLASS_PARAM = Some(JavaSwc4jAstParam::new(env));
  JAVA_CLASS_PAREN_EXPR = Some(JavaSwc4jAstParenExpr::new(env));
  JAVA_CLASS_PRIVATE_METHOD = Some(JavaSwc4jAstPrivateMethod::new(env));
  JAVA_CLASS_PRIVATE_NAME = Some(JavaSwc4jAstPrivateName::new(env));
  JAVA_CLASS_PRIVATE_PROP = Some(JavaSwc4jAstPrivateProp::new(env));
  JAVA_CLASS_REGEX = Some(JavaSwc4jAstRegex::new(env));
  JAVA_CLASS_REST_PAT = Some(JavaSwc4jAstRestPat::new(env));
  JAVA_CLASS_RETURN_STMT = Some(JavaSwc4jAstReturnStmt::new(env));
  JAVA_CLASS_SCRIPT = Some(JavaSwc4jAstScript::new(env));
  JAVA_CLASS_SEQ_EXPR = Some(JavaSwc4jAstSeqExpr::new(env));
  JAVA_CLASS_SETTER_PROP = Some(JavaSwc4jAstSetterProp::new(env));
  JAVA_CLASS_SPREAD_ELEMENT = Some(JavaSwc4jAstSpreadElement::new(env));
  JAVA_CLASS_STATIC_BLOCK = Some(JavaSwc4jAstStaticBlock::new(env));
  JAVA_CLASS_STR = Some(JavaSwc4jAstStr::new(env));
  JAVA_CLASS_SUPER = Some(JavaSwc4jAstSuper::new(env));
  JAVA_CLASS_SUPER_PROP_EXPR = Some(JavaSwc4jAstSuperPropExpr::new(env));
  JAVA_CLASS_SWITCH_CASE = Some(JavaSwc4jAstSwitchCase::new(env));
  JAVA_CLASS_SWITCH_STMT = Some(JavaSwc4jAstSwitchStmt::new(env));
  JAVA_CLASS_TAGGED_TPL = Some(JavaSwc4jAstTaggedTpl::new(env));
  JAVA_CLASS_THIS_EXPR = Some(JavaSwc4jAstThisExpr::new(env));
  JAVA_CLASS_THROW_STMT = Some(JavaSwc4jAstThrowStmt::new(env));
  JAVA_CLASS_TPL = Some(JavaSwc4jAstTpl::new(env));
  JAVA_CLASS_TPL_ELEMENT = Some(JavaSwc4jAstTplElement::new(env));
  JAVA_CLASS_TRY_STMT = Some(JavaSwc4jAstTryStmt::new(env));
  JAVA_CLASS_TS_ARRAY_TYPE = Some(JavaSwc4jAstTsArrayType::new(env));
  JAVA_CLASS_TS_AS_EXPR = Some(JavaSwc4jAstTsAsExpr::new(env));
  JAVA_CLASS_TS_CALL_SIGNATURE_DECL = Some(JavaSwc4jAstTsCallSignatureDecl::new(env));
  JAVA_CLASS_TS_CONDITIONAL_TYPE = Some(JavaSwc4jAstTsConditionalType::new(env));
  JAVA_CLASS_TS_CONST_ASSERTION = Some(JavaSwc4jAstTsConstAssertion::new(env));
  JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL = Some(JavaSwc4jAstTsConstructSignatureDecl::new(env));
  JAVA_CLASS_TS_CONSTRUCTOR_TYPE = Some(JavaSwc4jAstTsConstructorType::new(env));
  JAVA_CLASS_TS_ENUM_DECL = Some(JavaSwc4jAstTsEnumDecl::new(env));
  JAVA_CLASS_TS_ENUM_MEMBER = Some(JavaSwc4jAstTsEnumMember::new(env));
  JAVA_CLASS_TS_EXPORT_ASSIGNMENT = Some(JavaSwc4jAstTsExportAssignment::new(env));
  JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS = Some(JavaSwc4jAstTsExprWithTypeArgs::new(env));
  JAVA_CLASS_TS_EXTERNAL_MODULE_REF = Some(JavaSwc4jAstTsExternalModuleRef::new(env));
  JAVA_CLASS_TS_FN_TYPE = Some(JavaSwc4jAstTsFnType::new(env));
  JAVA_CLASS_TS_GETTER_SIGNATURE = Some(JavaSwc4jAstTsGetterSignature::new(env));
  JAVA_CLASS_TS_IMPORT_EQUALS_DECL = Some(JavaSwc4jAstTsImportEqualsDecl::new(env));
  JAVA_CLASS_TS_IMPORT_TYPE = Some(JavaSwc4jAstTsImportType::new(env));
  JAVA_CLASS_TS_INDEX_SIGNATURE = Some(JavaSwc4jAstTsIndexSignature::new(env));
  JAVA_CLASS_TS_INDEXED_ACCESS_TYPE = Some(JavaSwc4jAstTsIndexedAccessType::new(env));
  JAVA_CLASS_TS_INFER_TYPE = Some(JavaSwc4jAstTsInferType::new(env));
  JAVA_CLASS_TS_INSTANTIATION = Some(JavaSwc4jAstTsInstantiation::new(env));
  JAVA_CLASS_TS_INTERFACE_BODY = Some(JavaSwc4jAstTsInterfaceBody::new(env));
  JAVA_CLASS_TS_INTERFACE_DECL = Some(JavaSwc4jAstTsInterfaceDecl::new(env));
  JAVA_CLASS_TS_INTERSECTION_TYPE = Some(JavaSwc4jAstTsIntersectionType::new(env));
  JAVA_CLASS_TS_KEYWORD_TYPE = Some(JavaSwc4jAstTsKeywordType::new(env));
  JAVA_CLASS_TS_LIT_TYPE = Some(JavaSwc4jAstTsLitType::new(env));
  JAVA_CLASS_TS_MAPPED_TYPE = Some(JavaSwc4jAstTsMappedType::new(env));
  JAVA_CLASS_TS_METHOD_SIGNATURE = Some(JavaSwc4jAstTsMethodSignature::new(env));
  JAVA_CLASS_TS_MODULE_BLOCK = Some(JavaSwc4jAstTsModuleBlock::new(env));
  JAVA_CLASS_TS_MODULE_DECL = Some(JavaSwc4jAstTsModuleDecl::new(env));
  JAVA_CLASS_TS_NAMESPACE_DECL = Some(JavaSwc4jAstTsNamespaceDecl::new(env));
  JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL = Some(JavaSwc4jAstTsNamespaceExportDecl::new(env));
  JAVA_CLASS_TS_NON_NULL_EXPR = Some(JavaSwc4jAstTsNonNullExpr::new(env));
  JAVA_CLASS_TS_OPTIONAL_TYPE = Some(JavaSwc4jAstTsOptionalType::new(env));
  JAVA_CLASS_TS_PARAM_PROP = Some(JavaSwc4jAstTsParamProp::new(env));
  JAVA_CLASS_TS_PARENTHESIZED_TYPE = Some(JavaSwc4jAstTsParenthesizedType::new(env));
  JAVA_CLASS_TS_PROPERTY_SIGNATURE = Some(JavaSwc4jAstTsPropertySignature::new(env));
  JAVA_CLASS_TS_QUALIFIED_NAME = Some(JavaSwc4jAstTsQualifiedName::new(env));
  JAVA_CLASS_TS_REST_TYPE = Some(JavaSwc4jAstTsRestType::new(env));
  JAVA_CLASS_TS_SATISFIES_EXPR = Some(JavaSwc4jAstTsSatisfiesExpr::new(env));
  JAVA_CLASS_TS_SETTER_SIGNATURE = Some(JavaSwc4jAstTsSetterSignature::new(env));
  JAVA_CLASS_TS_THIS_TYPE = Some(JavaSwc4jAstTsThisType::new(env));
  JAVA_CLASS_TS_TPL_LIT_TYPE = Some(JavaSwc4jAstTsTplLitType::new(env));
  JAVA_CLASS_TS_TUPLE_ELEMENT = Some(JavaSwc4jAstTsTupleElement::new(env));
  JAVA_CLASS_TS_TUPLE_TYPE = Some(JavaSwc4jAstTsTupleType::new(env));
  JAVA_CLASS_TS_TYPE_ALIAS_DECL = Some(JavaSwc4jAstTsTypeAliasDecl::new(env));
  JAVA_CLASS_TS_TYPE_ANN = Some(JavaSwc4jAstTsTypeAnn::new(env));
  JAVA_CLASS_TS_TYPE_ASSERTION = Some(JavaSwc4jAstTsTypeAssertion::new(env));
  JAVA_CLASS_TS_TYPE_LIT = Some(JavaSwc4jAstTsTypeLit::new(env));
  JAVA_CLASS_TS_TYPE_OPERATOR = Some(JavaSwc4jAstTsTypeOperator::new(env));
  JAVA_CLASS_TS_TYPE_PARAM = Some(JavaSwc4jAstTsTypeParam::new(env));
  JAVA_CLASS_TS_TYPE_PARAM_DECL = Some(JavaSwc4jAstTsTypeParamDecl::new(env));
  JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION = Some(JavaSwc4jAstTsTypeParamInstantiation::new(env));
  JAVA_CLASS_TS_TYPE_PREDICATE = Some(JavaSwc4jAstTsTypePredicate::new(env));
  JAVA_CLASS_TS_TYPE_QUERY = Some(JavaSwc4jAstTsTypeQuery::new(env));
  JAVA_CLASS_TS_TYPE_REF = Some(JavaSwc4jAstTsTypeRef::new(env));
  JAVA_CLASS_TS_UNION_TYPE = Some(JavaSwc4jAstTsUnionType::new(env));
  JAVA_CLASS_UNARY_EXPR = Some(JavaSwc4jAstUnaryExpr::new(env));
  JAVA_CLASS_UPDATE_EXPR = Some(JavaSwc4jAstUpdateExpr::new(env));
  JAVA_CLASS_USING_DECL = Some(JavaSwc4jAstUsingDecl::new(env));
  JAVA_CLASS_VAR_DECL = Some(JavaSwc4jAstVarDecl::new(env));
  JAVA_CLASS_VAR_DECLARATOR = Some(JavaSwc4jAstVarDeclarator::new(env));
  JAVA_CLASS_WHILE_STMT = Some(JavaSwc4jAstWhileStmt::new(env));
  JAVA_CLASS_WITH_STMT = Some(JavaSwc4jAstWithStmt::new(env));
  JAVA_CLASS_YIELD_EXPR = Some(JavaSwc4jAstYieldExpr::new(env));
}
/* JNI End */

/* Enum Begin */
impl RegisterWithMap<ByteToIndexMap> for AssignTarget {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      AssignTarget::Pat(node) => node.register_with_map(map),
      AssignTarget::Simple(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignTarget {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      AssignTarget::Pat(node) => node.to_java_with_map(env, map),
      AssignTarget::Simple(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignTargetPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      AssignTargetPat::Array(node) => node.register_with_map(map),
      AssignTargetPat::Invalid(node) => node.register_with_map(map),
      AssignTargetPat::Object(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignTargetPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      AssignTargetPat::Array(node) => node.to_java_with_map(env, map),
      AssignTargetPat::Invalid(node) => node.to_java_with_map(env, map),
      AssignTargetPat::Object(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for BlockStmtOrExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      BlockStmtOrExpr::BlockStmt(node) => node.register_with_map(map),
      BlockStmtOrExpr::Expr(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BlockStmtOrExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      BlockStmtOrExpr::BlockStmt(node) => node.to_java_with_map(env, map),
      BlockStmtOrExpr::Expr(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for Callee {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Callee::Expr(node) => node.register_with_map(map),
      Callee::Import(node) => node.register_with_map(map),
      Callee::Super(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Callee {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      Callee::Expr(node) => node.to_java_with_map(env, map),
      Callee::Import(node) => node.to_java_with_map(env, map),
      Callee::Super(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassMember {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ClassMember::AutoAccessor(node) => node.register_with_map(map),
      ClassMember::ClassProp(node) => node.register_with_map(map),
      ClassMember::Constructor(node) => node.register_with_map(map),
      ClassMember::Empty(node) => node.register_with_map(map),
      ClassMember::Method(node) => node.register_with_map(map),
      ClassMember::PrivateMethod(node) => node.register_with_map(map),
      ClassMember::PrivateProp(node) => node.register_with_map(map),
      ClassMember::StaticBlock(node) => node.register_with_map(map),
      ClassMember::TsIndexSignature(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassMember {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      ClassMember::AutoAccessor(node) => node.to_java_with_map(env, map),
      ClassMember::ClassProp(node) => node.to_java_with_map(env, map),
      ClassMember::Constructor(node) => node.to_java_with_map(env, map),
      ClassMember::Empty(node) => node.to_java_with_map(env, map),
      ClassMember::Method(node) => node.to_java_with_map(env, map),
      ClassMember::PrivateMethod(node) => node.to_java_with_map(env, map),
      ClassMember::PrivateProp(node) => node.to_java_with_map(env, map),
      ClassMember::StaticBlock(node) => node.to_java_with_map(env, map),
      ClassMember::TsIndexSignature(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for Decl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Decl::Class(node) => node.register_with_map(map),
      Decl::Fn(node) => node.register_with_map(map),
      Decl::TsEnum(node) => node.register_with_map(map),
      Decl::TsInterface(node) => node.register_with_map(map),
      Decl::TsModule(node) => node.register_with_map(map),
      Decl::TsTypeAlias(node) => node.register_with_map(map),
      Decl::Using(node) => node.register_with_map(map),
      Decl::Var(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Decl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      Decl::Class(node) => node.to_java_with_map(env, map),
      Decl::Fn(node) => node.to_java_with_map(env, map),
      Decl::TsEnum(node) => node.to_java_with_map(env, map),
      Decl::TsInterface(node) => node.to_java_with_map(env, map),
      Decl::TsModule(node) => node.to_java_with_map(env, map),
      Decl::TsTypeAlias(node) => node.to_java_with_map(env, map),
      Decl::Using(node) => node.to_java_with_map(env, map),
      Decl::Var(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for DefaultDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      DefaultDecl::Class(node) => node.register_with_map(map),
      DefaultDecl::Fn(node) => node.register_with_map(map),
      DefaultDecl::TsInterfaceDecl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for DefaultDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      DefaultDecl::Class(node) => node.to_java_with_map(env, map),
      DefaultDecl::Fn(node) => node.to_java_with_map(env, map),
      DefaultDecl::TsInterfaceDecl(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ExportSpecifier::Default(node) => node.register_with_map(map),
      ExportSpecifier::Named(node) => node.register_with_map(map),
      ExportSpecifier::Namespace(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      ExportSpecifier::Default(node) => node.to_java_with_map(env, map),
      ExportSpecifier::Named(node) => node.to_java_with_map(env, map),
      ExportSpecifier::Namespace(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for Expr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Expr::Array(node) => node.register_with_map(map),
      Expr::Arrow(node) => node.register_with_map(map),
      Expr::Assign(node) => node.register_with_map(map),
      Expr::Await(node) => node.register_with_map(map),
      Expr::Bin(node) => node.register_with_map(map),
      Expr::Call(node) => node.register_with_map(map),
      Expr::Class(node) => node.register_with_map(map),
      Expr::Cond(node) => node.register_with_map(map),
      Expr::Fn(node) => node.register_with_map(map),
      Expr::Ident(node) => node.register_with_map(map),
      Expr::Invalid(node) => node.register_with_map(map),
      Expr::JSXElement(node) => node.register_with_map(map),
      Expr::JSXEmpty(node) => node.register_with_map(map),
      Expr::JSXFragment(node) => node.register_with_map(map),
      Expr::JSXMember(node) => node.register_with_map(map),
      Expr::JSXNamespacedName(node) => node.register_with_map(map),
      Expr::Lit(node) => node.register_with_map(map),
      Expr::Member(node) => node.register_with_map(map),
      Expr::MetaProp(node) => node.register_with_map(map),
      Expr::New(node) => node.register_with_map(map),
      Expr::Object(node) => node.register_with_map(map),
      Expr::OptChain(node) => node.register_with_map(map),
      Expr::Paren(node) => node.register_with_map(map),
      Expr::PrivateName(node) => node.register_with_map(map),
      Expr::Seq(node) => node.register_with_map(map),
      Expr::SuperProp(node) => node.register_with_map(map),
      Expr::TaggedTpl(node) => node.register_with_map(map),
      Expr::This(node) => node.register_with_map(map),
      Expr::Tpl(node) => node.register_with_map(map),
      Expr::TsAs(node) => node.register_with_map(map),
      Expr::TsConstAssertion(node) => node.register_with_map(map),
      Expr::TsInstantiation(node) => node.register_with_map(map),
      Expr::TsNonNull(node) => node.register_with_map(map),
      Expr::TsSatisfies(node) => node.register_with_map(map),
      Expr::TsTypeAssertion(node) => node.register_with_map(map),
      Expr::Unary(node) => node.register_with_map(map),
      Expr::Update(node) => node.register_with_map(map),
      Expr::Yield(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Expr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      Expr::Array(node) => node.to_java_with_map(env, map),
      Expr::Arrow(node) => node.to_java_with_map(env, map),
      Expr::Assign(node) => node.to_java_with_map(env, map),
      Expr::Await(node) => node.to_java_with_map(env, map),
      Expr::Bin(node) => node.to_java_with_map(env, map),
      Expr::Call(node) => node.to_java_with_map(env, map),
      Expr::Class(node) => node.to_java_with_map(env, map),
      Expr::Cond(node) => node.to_java_with_map(env, map),
      Expr::Fn(node) => node.to_java_with_map(env, map),
      Expr::Ident(node) => node.to_java_with_map(env, map),
      Expr::Invalid(node) => node.to_java_with_map(env, map),
      Expr::JSXElement(node) => node.to_java_with_map(env, map),
      Expr::JSXEmpty(node) => node.to_java_with_map(env, map),
      Expr::JSXFragment(node) => node.to_java_with_map(env, map),
      Expr::JSXMember(node) => node.to_java_with_map(env, map),
      Expr::JSXNamespacedName(node) => node.to_java_with_map(env, map),
      Expr::Lit(node) => node.to_java_with_map(env, map),
      Expr::Member(node) => node.to_java_with_map(env, map),
      Expr::MetaProp(node) => node.to_java_with_map(env, map),
      Expr::New(node) => node.to_java_with_map(env, map),
      Expr::Object(node) => node.to_java_with_map(env, map),
      Expr::OptChain(node) => node.to_java_with_map(env, map),
      Expr::Paren(node) => node.to_java_with_map(env, map),
      Expr::PrivateName(node) => node.to_java_with_map(env, map),
      Expr::Seq(node) => node.to_java_with_map(env, map),
      Expr::SuperProp(node) => node.to_java_with_map(env, map),
      Expr::TaggedTpl(node) => node.to_java_with_map(env, map),
      Expr::This(node) => node.to_java_with_map(env, map),
      Expr::Tpl(node) => node.to_java_with_map(env, map),
      Expr::TsAs(node) => node.to_java_with_map(env, map),
      Expr::TsConstAssertion(node) => node.to_java_with_map(env, map),
      Expr::TsInstantiation(node) => node.to_java_with_map(env, map),
      Expr::TsNonNull(node) => node.to_java_with_map(env, map),
      Expr::TsSatisfies(node) => node.to_java_with_map(env, map),
      Expr::TsTypeAssertion(node) => node.to_java_with_map(env, map),
      Expr::Unary(node) => node.to_java_with_map(env, map),
      Expr::Update(node) => node.to_java_with_map(env, map),
      Expr::Yield(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for ForHead {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ForHead::Pat(node) => node.register_with_map(map),
      ForHead::UsingDecl(node) => node.register_with_map(map),
      ForHead::VarDecl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ForHead {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      ForHead::Pat(node) => node.to_java_with_map(env, map),
      ForHead::UsingDecl(node) => node.to_java_with_map(env, map),
      ForHead::VarDecl(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ImportSpecifier::Default(node) => node.register_with_map(map),
      ImportSpecifier::Named(node) => node.register_with_map(map),
      ImportSpecifier::Namespace(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      ImportSpecifier::Default(node) => node.to_java_with_map(env, map),
      ImportSpecifier::Named(node) => node.to_java_with_map(env, map),
      ImportSpecifier::Namespace(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXAttrName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXAttrName::Ident(node) => node.register_with_map(map),
      JSXAttrName::JSXNamespacedName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXAttrName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      JSXAttrName::Ident(node) => node.to_java_with_map(env, map),
      JSXAttrName::JSXNamespacedName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXAttrOrSpread {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXAttrOrSpread::JSXAttr(node) => node.register_with_map(map),
      JSXAttrOrSpread::SpreadElement(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXAttrOrSpread {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      JSXAttrOrSpread::JSXAttr(node) => node.to_java_with_map(env, map),
      JSXAttrOrSpread::SpreadElement(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXAttrValue {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXAttrValue::JSXElement(node) => node.register_with_map(map),
      JSXAttrValue::JSXExprContainer(node) => node.register_with_map(map),
      JSXAttrValue::JSXFragment(node) => node.register_with_map(map),
      JSXAttrValue::Lit(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXAttrValue {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      JSXAttrValue::JSXElement(node) => node.to_java_with_map(env, map),
      JSXAttrValue::JSXExprContainer(node) => node.to_java_with_map(env, map),
      JSXAttrValue::JSXFragment(node) => node.to_java_with_map(env, map),
      JSXAttrValue::Lit(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXElementChild {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXElementChild::JSXElement(node) => node.register_with_map(map),
      JSXElementChild::JSXExprContainer(node) => node.register_with_map(map),
      JSXElementChild::JSXFragment(node) => node.register_with_map(map),
      JSXElementChild::JSXSpreadChild(node) => node.register_with_map(map),
      JSXElementChild::JSXText(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXElementChild {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      JSXElementChild::JSXElement(node) => node.to_java_with_map(env, map),
      JSXElementChild::JSXExprContainer(node) => node.to_java_with_map(env, map),
      JSXElementChild::JSXFragment(node) => node.to_java_with_map(env, map),
      JSXElementChild::JSXSpreadChild(node) => node.to_java_with_map(env, map),
      JSXElementChild::JSXText(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXElementName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXElementName::Ident(node) => node.register_with_map(map),
      JSXElementName::JSXMemberExpr(node) => node.register_with_map(map),
      JSXElementName::JSXNamespacedName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXElementName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      JSXElementName::Ident(node) => node.to_java_with_map(env, map),
      JSXElementName::JSXMemberExpr(node) => node.to_java_with_map(env, map),
      JSXElementName::JSXNamespacedName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXExpr::Expr(node) => node.register_with_map(map),
      JSXExpr::JSXEmptyExpr(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      JSXExpr::Expr(node) => node.to_java_with_map(env, map),
      JSXExpr::JSXEmptyExpr(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXObject {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXObject::Ident(node) => node.register_with_map(map),
      JSXObject::JSXMemberExpr(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXObject {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      JSXObject::Ident(node) => node.to_java_with_map(env, map),
      JSXObject::JSXMemberExpr(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for Key {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Key::Private(node) => node.register_with_map(map),
      Key::Public(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Key {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      Key::Private(node) => node.to_java_with_map(env, map),
      Key::Public(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for Lit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Lit::BigInt(node) => node.register_with_map(map),
      Lit::Bool(node) => node.register_with_map(map),
      Lit::JSXText(node) => node.register_with_map(map),
      Lit::Null(node) => node.register_with_map(map),
      Lit::Num(node) => node.register_with_map(map),
      Lit::Regex(node) => node.register_with_map(map),
      Lit::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Lit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      Lit::BigInt(node) => node.to_java_with_map(env, map),
      Lit::Bool(node) => node.to_java_with_map(env, map),
      Lit::JSXText(node) => node.to_java_with_map(env, map),
      Lit::Null(node) => node.to_java_with_map(env, map),
      Lit::Num(node) => node.to_java_with_map(env, map),
      Lit::Regex(node) => node.to_java_with_map(env, map),
      Lit::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for MemberProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      MemberProp::Computed(node) => node.register_with_map(map),
      MemberProp::Ident(node) => node.register_with_map(map),
      MemberProp::PrivateName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for MemberProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      MemberProp::Computed(node) => node.to_java_with_map(env, map),
      MemberProp::Ident(node) => node.to_java_with_map(env, map),
      MemberProp::PrivateName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for ModuleDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ModuleDecl::ExportAll(node) => node.register_with_map(map),
      ModuleDecl::ExportDecl(node) => node.register_with_map(map),
      ModuleDecl::ExportDefaultDecl(node) => node.register_with_map(map),
      ModuleDecl::ExportDefaultExpr(node) => node.register_with_map(map),
      ModuleDecl::ExportNamed(node) => node.register_with_map(map),
      ModuleDecl::Import(node) => node.register_with_map(map),
      ModuleDecl::TsExportAssignment(node) => node.register_with_map(map),
      ModuleDecl::TsImportEquals(node) => node.register_with_map(map),
      ModuleDecl::TsNamespaceExport(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ModuleDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      ModuleDecl::ExportAll(node) => node.to_java_with_map(env, map),
      ModuleDecl::ExportDecl(node) => node.to_java_with_map(env, map),
      ModuleDecl::ExportDefaultDecl(node) => node.to_java_with_map(env, map),
      ModuleDecl::ExportDefaultExpr(node) => node.to_java_with_map(env, map),
      ModuleDecl::ExportNamed(node) => node.to_java_with_map(env, map),
      ModuleDecl::Import(node) => node.to_java_with_map(env, map),
      ModuleDecl::TsExportAssignment(node) => node.to_java_with_map(env, map),
      ModuleDecl::TsImportEquals(node) => node.to_java_with_map(env, map),
      ModuleDecl::TsNamespaceExport(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for ModuleExportName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ModuleExportName::Ident(node) => node.register_with_map(map),
      ModuleExportName::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ModuleExportName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      ModuleExportName::Ident(node) => node.to_java_with_map(env, map),
      ModuleExportName::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for ModuleItem {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ModuleItem::ModuleDecl(node) => node.register_with_map(map),
      ModuleItem::Stmt(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ModuleItem {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      ModuleItem::ModuleDecl(node) => node.to_java_with_map(env, map),
      ModuleItem::Stmt(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for ObjectPatProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ObjectPatProp::Assign(node) => node.register_with_map(map),
      ObjectPatProp::KeyValue(node) => node.register_with_map(map),
      ObjectPatProp::Rest(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ObjectPatProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      ObjectPatProp::Assign(node) => node.to_java_with_map(env, map),
      ObjectPatProp::KeyValue(node) => node.to_java_with_map(env, map),
      ObjectPatProp::Rest(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for OptChainBase {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      OptChainBase::Call(node) => node.register_with_map(map),
      OptChainBase::Member(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for OptChainBase {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      OptChainBase::Call(node) => node.to_java_with_map(env, map),
      OptChainBase::Member(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for ParamOrTsParamProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ParamOrTsParamProp::Param(node) => node.register_with_map(map),
      ParamOrTsParamProp::TsParamProp(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ParamOrTsParamProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      ParamOrTsParamProp::Param(node) => node.to_java_with_map(env, map),
      ParamOrTsParamProp::TsParamProp(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for Pat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Pat::Array(node) => node.register_with_map(map),
      Pat::Assign(node) => node.register_with_map(map),
      Pat::Expr(node) => node.register_with_map(map),
      Pat::Ident(node) => node.register_with_map(map),
      Pat::Invalid(node) => node.register_with_map(map),
      Pat::Object(node) => node.register_with_map(map),
      Pat::Rest(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Pat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      Pat::Array(node) => node.to_java_with_map(env, map),
      Pat::Assign(node) => node.to_java_with_map(env, map),
      Pat::Expr(node) => node.to_java_with_map(env, map),
      Pat::Ident(node) => node.to_java_with_map(env, map),
      Pat::Invalid(node) => node.to_java_with_map(env, map),
      Pat::Object(node) => node.to_java_with_map(env, map),
      Pat::Rest(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for Program {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Program::Module(node) => node.register_with_map(map),
      Program::Script(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Program {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      Program::Module(node) => node.to_java_with_map(env, map),
      Program::Script(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for Prop {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Prop::Assign(node) => node.register_with_map(map),
      Prop::Getter(node) => node.register_with_map(map),
      Prop::KeyValue(node) => node.register_with_map(map),
      Prop::Method(node) => node.register_with_map(map),
      Prop::Setter(node) => node.register_with_map(map),
      Prop::Shorthand(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Prop {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      Prop::Assign(node) => node.to_java_with_map(env, map),
      Prop::Getter(node) => node.to_java_with_map(env, map),
      Prop::KeyValue(node) => node.to_java_with_map(env, map),
      Prop::Method(node) => node.to_java_with_map(env, map),
      Prop::Setter(node) => node.to_java_with_map(env, map),
      Prop::Shorthand(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for PropName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      PropName::BigInt(node) => node.register_with_map(map),
      PropName::Computed(node) => node.register_with_map(map),
      PropName::Ident(node) => node.register_with_map(map),
      PropName::Num(node) => node.register_with_map(map),
      PropName::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PropName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      PropName::BigInt(node) => node.to_java_with_map(env, map),
      PropName::Computed(node) => node.to_java_with_map(env, map),
      PropName::Ident(node) => node.to_java_with_map(env, map),
      PropName::Num(node) => node.to_java_with_map(env, map),
      PropName::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for PropOrSpread {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      PropOrSpread::Prop(node) => node.register_with_map(map),
      PropOrSpread::Spread(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PropOrSpread {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      PropOrSpread::Prop(node) => node.to_java_with_map(env, map),
      PropOrSpread::Spread(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for SimpleAssignTarget {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      SimpleAssignTarget::Ident(node) => node.register_with_map(map),
      SimpleAssignTarget::Invalid(node) => node.register_with_map(map),
      SimpleAssignTarget::Member(node) => node.register_with_map(map),
      SimpleAssignTarget::OptChain(node) => node.register_with_map(map),
      SimpleAssignTarget::Paren(node) => node.register_with_map(map),
      SimpleAssignTarget::SuperProp(node) => node.register_with_map(map),
      SimpleAssignTarget::TsAs(node) => node.register_with_map(map),
      SimpleAssignTarget::TsInstantiation(node) => node.register_with_map(map),
      SimpleAssignTarget::TsNonNull(node) => node.register_with_map(map),
      SimpleAssignTarget::TsSatisfies(node) => node.register_with_map(map),
      SimpleAssignTarget::TsTypeAssertion(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SimpleAssignTarget {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      SimpleAssignTarget::Ident(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::Invalid(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::Member(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::OptChain(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::Paren(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::SuperProp(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsAs(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsInstantiation(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsNonNull(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsSatisfies(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsTypeAssertion(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for Stmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Stmt::Block(node) => node.register_with_map(map),
      Stmt::Break(node) => node.register_with_map(map),
      Stmt::Continue(node) => node.register_with_map(map),
      Stmt::Debugger(node) => node.register_with_map(map),
      Stmt::Decl(node) => node.register_with_map(map),
      Stmt::DoWhile(node) => node.register_with_map(map),
      Stmt::Empty(node) => node.register_with_map(map),
      Stmt::Expr(node) => node.register_with_map(map),
      Stmt::For(node) => node.register_with_map(map),
      Stmt::ForIn(node) => node.register_with_map(map),
      Stmt::ForOf(node) => node.register_with_map(map),
      Stmt::If(node) => node.register_with_map(map),
      Stmt::Labeled(node) => node.register_with_map(map),
      Stmt::Return(node) => node.register_with_map(map),
      Stmt::Switch(node) => node.register_with_map(map),
      Stmt::Throw(node) => node.register_with_map(map),
      Stmt::Try(node) => node.register_with_map(map),
      Stmt::While(node) => node.register_with_map(map),
      Stmt::With(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Stmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      Stmt::Block(node) => node.to_java_with_map(env, map),
      Stmt::Break(node) => node.to_java_with_map(env, map),
      Stmt::Continue(node) => node.to_java_with_map(env, map),
      Stmt::Debugger(node) => node.to_java_with_map(env, map),
      Stmt::Decl(node) => node.to_java_with_map(env, map),
      Stmt::DoWhile(node) => node.to_java_with_map(env, map),
      Stmt::Empty(node) => node.to_java_with_map(env, map),
      Stmt::Expr(node) => node.to_java_with_map(env, map),
      Stmt::For(node) => node.to_java_with_map(env, map),
      Stmt::ForIn(node) => node.to_java_with_map(env, map),
      Stmt::ForOf(node) => node.to_java_with_map(env, map),
      Stmt::If(node) => node.to_java_with_map(env, map),
      Stmt::Labeled(node) => node.to_java_with_map(env, map),
      Stmt::Return(node) => node.to_java_with_map(env, map),
      Stmt::Switch(node) => node.to_java_with_map(env, map),
      Stmt::Throw(node) => node.to_java_with_map(env, map),
      Stmt::Try(node) => node.to_java_with_map(env, map),
      Stmt::While(node) => node.to_java_with_map(env, map),
      Stmt::With(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for SuperProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      SuperProp::Computed(node) => node.register_with_map(map),
      SuperProp::Ident(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SuperProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      SuperProp::Computed(node) => node.to_java_with_map(env, map),
      SuperProp::Ident(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsEntityName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsEntityName::Ident(node) => node.register_with_map(map),
      TsEntityName::TsQualifiedName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsEntityName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsEntityName::Ident(node) => node.to_java_with_map(env, map),
      TsEntityName::TsQualifiedName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsEnumMemberId {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsEnumMemberId::Ident(node) => node.register_with_map(map),
      TsEnumMemberId::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsEnumMemberId {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsEnumMemberId::Ident(node) => node.to_java_with_map(env, map),
      TsEnumMemberId::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsFnOrConstructorType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsFnOrConstructorType::TsConstructorType(node) => node.register_with_map(map),
      TsFnOrConstructorType::TsFnType(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsFnOrConstructorType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsFnOrConstructorType::TsConstructorType(node) => node.to_java_with_map(env, map),
      TsFnOrConstructorType::TsFnType(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsFnParam {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsFnParam::Array(node) => node.register_with_map(map),
      TsFnParam::Ident(node) => node.register_with_map(map),
      TsFnParam::Object(node) => node.register_with_map(map),
      TsFnParam::Rest(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsFnParam {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsFnParam::Array(node) => node.to_java_with_map(env, map),
      TsFnParam::Ident(node) => node.to_java_with_map(env, map),
      TsFnParam::Object(node) => node.to_java_with_map(env, map),
      TsFnParam::Rest(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsLit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsLit::BigInt(node) => node.register_with_map(map),
      TsLit::Bool(node) => node.register_with_map(map),
      TsLit::Number(node) => node.register_with_map(map),
      TsLit::Str(node) => node.register_with_map(map),
      TsLit::Tpl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsLit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsLit::BigInt(node) => node.to_java_with_map(env, map),
      TsLit::Bool(node) => node.to_java_with_map(env, map),
      TsLit::Number(node) => node.to_java_with_map(env, map),
      TsLit::Str(node) => node.to_java_with_map(env, map),
      TsLit::Tpl(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsModuleName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsModuleName::Ident(node) => node.register_with_map(map),
      TsModuleName::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsModuleName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsModuleName::Ident(node) => node.to_java_with_map(env, map),
      TsModuleName::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsModuleRef {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsModuleRef::TsEntityName(node) => node.register_with_map(map),
      TsModuleRef::TsExternalModuleRef(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsModuleRef {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsModuleRef::TsEntityName(node) => node.to_java_with_map(env, map),
      TsModuleRef::TsExternalModuleRef(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsNamespaceBody {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsNamespaceBody::TsModuleBlock(node) => node.register_with_map(map),
      TsNamespaceBody::TsNamespaceDecl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsNamespaceBody {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsNamespaceBody::TsModuleBlock(node) => node.to_java_with_map(env, map),
      TsNamespaceBody::TsNamespaceDecl(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsParamPropParam {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsParamPropParam::Assign(node) => node.register_with_map(map),
      TsParamPropParam::Ident(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsParamPropParam {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsParamPropParam::Assign(node) => node.to_java_with_map(env, map),
      TsParamPropParam::Ident(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsThisTypeOrIdent {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsThisTypeOrIdent::Ident(node) => node.register_with_map(map),
      TsThisTypeOrIdent::TsThisType(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsThisTypeOrIdent {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsThisTypeOrIdent::Ident(node) => node.to_java_with_map(env, map),
      TsThisTypeOrIdent::TsThisType(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsType::TsArrayType(node) => node.register_with_map(map),
      TsType::TsConditionalType(node) => node.register_with_map(map),
      TsType::TsFnOrConstructorType(node) => node.register_with_map(map),
      TsType::TsImportType(node) => node.register_with_map(map),
      TsType::TsIndexedAccessType(node) => node.register_with_map(map),
      TsType::TsInferType(node) => node.register_with_map(map),
      TsType::TsKeywordType(node) => node.register_with_map(map),
      TsType::TsLitType(node) => node.register_with_map(map),
      TsType::TsMappedType(node) => node.register_with_map(map),
      TsType::TsOptionalType(node) => node.register_with_map(map),
      TsType::TsParenthesizedType(node) => node.register_with_map(map),
      TsType::TsRestType(node) => node.register_with_map(map),
      TsType::TsThisType(node) => node.register_with_map(map),
      TsType::TsTupleType(node) => node.register_with_map(map),
      TsType::TsTypeLit(node) => node.register_with_map(map),
      TsType::TsTypeOperator(node) => node.register_with_map(map),
      TsType::TsTypePredicate(node) => node.register_with_map(map),
      TsType::TsTypeQuery(node) => node.register_with_map(map),
      TsType::TsTypeRef(node) => node.register_with_map(map),
      TsType::TsUnionOrIntersectionType(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsType::TsArrayType(node) => node.to_java_with_map(env, map),
      TsType::TsConditionalType(node) => node.to_java_with_map(env, map),
      TsType::TsFnOrConstructorType(node) => node.to_java_with_map(env, map),
      TsType::TsImportType(node) => node.to_java_with_map(env, map),
      TsType::TsIndexedAccessType(node) => node.to_java_with_map(env, map),
      TsType::TsInferType(node) => node.to_java_with_map(env, map),
      TsType::TsKeywordType(node) => node.to_java_with_map(env, map),
      TsType::TsLitType(node) => node.to_java_with_map(env, map),
      TsType::TsMappedType(node) => node.to_java_with_map(env, map),
      TsType::TsOptionalType(node) => node.to_java_with_map(env, map),
      TsType::TsParenthesizedType(node) => node.to_java_with_map(env, map),
      TsType::TsRestType(node) => node.to_java_with_map(env, map),
      TsType::TsThisType(node) => node.to_java_with_map(env, map),
      TsType::TsTupleType(node) => node.to_java_with_map(env, map),
      TsType::TsTypeLit(node) => node.to_java_with_map(env, map),
      TsType::TsTypeOperator(node) => node.to_java_with_map(env, map),
      TsType::TsTypePredicate(node) => node.to_java_with_map(env, map),
      TsType::TsTypeQuery(node) => node.to_java_with_map(env, map),
      TsType::TsTypeRef(node) => node.to_java_with_map(env, map),
      TsType::TsUnionOrIntersectionType(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsTypeElement::TsCallSignatureDecl(node) => node.register_with_map(map),
      TsTypeElement::TsConstructSignatureDecl(node) => node.register_with_map(map),
      TsTypeElement::TsGetterSignature(node) => node.register_with_map(map),
      TsTypeElement::TsIndexSignature(node) => node.register_with_map(map),
      TsTypeElement::TsMethodSignature(node) => node.register_with_map(map),
      TsTypeElement::TsPropertySignature(node) => node.register_with_map(map),
      TsTypeElement::TsSetterSignature(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsTypeElement::TsCallSignatureDecl(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsConstructSignatureDecl(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsGetterSignature(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsIndexSignature(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsMethodSignature(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsPropertySignature(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsSetterSignature(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeQueryExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsTypeQueryExpr::Import(node) => node.register_with_map(map),
      TsTypeQueryExpr::TsEntityName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeQueryExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsTypeQueryExpr::Import(node) => node.to_java_with_map(env, map),
      TsTypeQueryExpr::TsEntityName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsUnionOrIntersectionType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsUnionOrIntersectionType::TsIntersectionType(node) => node.register_with_map(map),
      TsUnionOrIntersectionType::TsUnionType(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsUnionOrIntersectionType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      TsUnionOrIntersectionType::TsIntersectionType(node) => node.to_java_with_map(env, map),
      TsUnionOrIntersectionType::TsUnionType(node) => node.to_java_with_map(env, map),
    }
  }
}

impl RegisterWithMap<ByteToIndexMap> for VarDeclOrExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      VarDeclOrExpr::Expr(node) => node.register_with_map(map),
      VarDeclOrExpr::VarDecl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for VarDeclOrExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    match self {
      VarDeclOrExpr::Expr(node) => node.to_java_with_map(env, map),
      VarDeclOrExpr::VarDecl(node) => node.to_java_with_map(env, map),
    }
  }
}
/* Enum End */

/* AST Begin */
impl RegisterWithMap<ByteToIndexMap> for ArrayLit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.elems.iter().for_each(|node| {
      node.as_ref().map(|node| node.register_with_map(map));
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ArrayLit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_elems = list_new(env, self.elems.len());
    self.elems.iter().for_each(|node| {
      let java_node = node.as_ref().map_or_else(
        || Default::default(),
        |node| node.to_java_with_map(env, map));
    list_add(env, &java_elems, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_ARRAY_LIT.as_ref().unwrap() }
      .construct(env, &java_elems, &java_span_ex);
    delete_local_ref!(env, java_elems);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ArrayPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.elems.iter().for_each(|node| {
      node.as_ref().map(|node| node.register_with_map(map));
    });
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ArrayPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_elems = list_new(env, self.elems.len());
    self.elems.iter().for_each(|node| {
      let java_node = node.as_ref().map_or_else(
        || Default::default(),
        |node| node.to_java_with_map(env, map));
    list_add(env, &java_elems, &java_node);
      delete_local_ref!(env, java_node);
    });
    let optional = self.optional;
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_ARRAY_PAT.as_ref().unwrap() }
      .construct(env, &java_elems, optional, &java_optional_type_ann, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_elems);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ArrowExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.body.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.return_type.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ArrowExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_body = self.body.to_java_with_map(env, map);
    let is_async = self.is_async;
    let is_generator = self.is_generator;
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_return_type = self.return_type.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_ARROW_EXPR.as_ref().unwrap() }
      .construct(env, &java_params, &java_body, is_async, is_generator, &java_optional_type_params, &java_optional_return_type, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_optional_ref!(env, java_optional_return_type);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_op = self.op.to_java(env);
    let java_left = self.left.to_java_with_map(env, map);
    let java_right = self.right.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_ASSIGN_EXPR.as_ref().unwrap() }
      .construct(env, &java_op, &java_left, &java_right, &java_span_ex);
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_left = self.left.to_java_with_map(env, map);
    let java_right = self.right.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_ASSIGN_PAT.as_ref().unwrap() }
      .construct(env, &java_left, &java_right, &java_span_ex);
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignPatProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignPatProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_optional_value = self.value.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_ASSIGN_PAT_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_value, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.key.register_with_map(map);
    self.value.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_value = self.value.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_ASSIGN_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_value, &java_span_ex);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for AutoAccessor {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.decorators.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AutoAccessor {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_optional_value = self.value.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let is_static = self.is_static;
    let java_decorators = list_new(env, self.decorators.len());
    self.decorators.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_decorators, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_accessibility = self.accessibility.as_ref().map(|node| node.to_java(env));
    let is_override = self.is_override;
    let definite = self.definite;
    let return_value = unsafe { JAVA_CLASS_AUTO_ACCESSOR.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_value, &java_optional_type_ann, is_static, &java_decorators, &java_optional_accessibility, is_override, definite, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for AwaitExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AwaitExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_arg = self.arg.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_AWAIT_EXPR.as_ref().unwrap() }
      .construct(env, &java_arg, &java_span_ex);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for BigInt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl RegisterWithMap<ByteToIndexMap> for BinExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BinExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_op = self.op.to_java(env);
    let java_left = self.left.to_java_with_map(env, map);
    let java_right = self.right.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_BIN_EXPR.as_ref().unwrap() }
      .construct(env, &java_op, &java_left, &java_right, &java_span_ex);
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for BindingIdent {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.id.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BindingIdent {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_id = self.id.to_java_with_map(env, map);
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_BINDING_IDENT.as_ref().unwrap() }
      .construct(env, &java_id, &java_optional_type_ann, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for BlockStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.stmts.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BlockStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_stmts = list_new(env, self.stmts.len());
    self.stmts.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_stmts, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_BLOCK_STMT.as_ref().unwrap() }
      .construct(env, &java_stmts, &java_span_ex);
    delete_local_ref!(env, java_stmts);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Bool {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Bool {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let value = self.value;
    let return_value = unsafe { JAVA_CLASS_BOOL.as_ref().unwrap() }
      .construct(env, value, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for BreakStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.label.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BreakStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_optional_label = self.label.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_BREAK_STMT.as_ref().unwrap() }
      .construct(env, &java_optional_label, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_label);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for CallExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.callee.register_with_map(map);
    self.args.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for CallExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_callee = self.callee.to_java_with_map(env, map);
    let java_args = list_new(env, self.args.len());
    self.args.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_args, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_type_args = self.type_args.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_CALL_EXPR.as_ref().unwrap() }
      .construct(env, &java_callee, &java_args, &java_optional_type_args, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_callee);
    delete_local_ref!(env, java_args);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for CatchClause {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.param.as_ref().map(|node| node.register_with_map(map));
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for CatchClause {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_optional_param = self.param.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_CATCH_CLAUSE.as_ref().unwrap() }
      .construct(env, &java_optional_param, &java_body, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_param);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Class {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.decorators.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.body.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.super_class.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.super_type_params.as_ref().map(|node| node.register_with_map(map));
    self.implements.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Class {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_decorators = list_new(env, self.decorators.len());
    self.decorators.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_decorators, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_body = list_new(env, self.body.len());
    self.body.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_body, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_super_class = self.super_class.as_ref().map(|node| node.to_java_with_map(env, map));
    let is_abstract = self.is_abstract;
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_super_type_params = self.super_type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_implements = list_new(env, self.implements.len());
    self.implements.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_implements, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_CLASS.as_ref().unwrap() }
      .construct(env, &java_decorators, &java_body, &java_optional_super_class, is_abstract, &java_optional_type_params, &java_optional_super_type_params, &java_implements, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_super_class);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_optional_ref!(env, java_optional_super_type_params);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_implements);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.ident.register_with_map(map);
    self.class.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_ident = self.ident.to_java_with_map(env, map);
    let declare = self.declare;
    let java_class = self.class.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_CLASS_DECL.as_ref().unwrap() }
      .construct(env, &java_ident, declare, &java_class, &java_span_ex);
    delete_local_ref!(env, java_ident);
    delete_local_ref!(env, java_class);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.ident.as_ref().map(|node| node.register_with_map(map));
    self.class.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_optional_ident = self.ident.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_class = self.class.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_CLASS_EXPR.as_ref().unwrap() }
      .construct(env, &java_optional_ident, &java_class, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_ident);
    delete_local_ref!(env, java_class);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassMethod {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassMethod {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_function = self.function.to_java_with_map(env, map);
    let java_kind = self.kind.to_java(env);
    let is_static = self.is_static;
    let java_optional_accessibility = self.accessibility.as_ref().map(|node| node.to_java(env));
    let is_abstract = self.is_abstract;
    let is_optional = self.is_optional;
    let is_override = self.is_override;
    let return_value = unsafe { JAVA_CLASS_CLASS_METHOD.as_ref().unwrap() }
      .construct(env, &java_key, &java_function, &java_kind, is_static, &java_optional_accessibility, is_abstract, is_optional, is_override, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.decorators.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_optional_value = self.value.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let is_static = self.is_static;
    let java_decorators = list_new(env, self.decorators.len());
    self.decorators.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_decorators, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_accessibility = self.accessibility.as_ref().map(|node| node.to_java(env));
    let is_abstract = self.is_abstract;
    let is_optional = self.is_optional;
    let is_override = self.is_override;
    let readonly = self.readonly;
    let declare = self.declare;
    let definite = self.definite;
    let return_value = unsafe { JAVA_CLASS_CLASS_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_value, &java_optional_type_ann, is_static, &java_decorators, &java_optional_accessibility, is_abstract, is_optional, is_override, readonly, declare, definite, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ComputedPropName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ComputedPropName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_COMPUTED_PROP_NAME.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for CondExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.register_with_map(map);
    self.cons.register_with_map(map);
    self.alt.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for CondExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_test = self.test.to_java_with_map(env, map);
    let java_cons = self.cons.to_java_with_map(env, map);
    let java_alt = self.alt.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_COND_EXPR.as_ref().unwrap() }
      .construct(env, &java_test, &java_cons, &java_alt, &java_span_ex);
    delete_local_ref!(env, java_test);
    delete_local_ref!(env, java_cons);
    delete_local_ref!(env, java_alt);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Constructor {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.body.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Constructor {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_body = self.body.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_accessibility = self.accessibility.as_ref().map(|node| node.to_java(env));
    let is_optional = self.is_optional;
    let return_value = unsafe { JAVA_CLASS_CONSTRUCTOR.as_ref().unwrap() }
      .construct(env, &java_key, &java_params, &java_optional_body, &java_optional_accessibility, is_optional, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ContinueStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.label.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ContinueStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_optional_label = self.label.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_CONTINUE_STMT.as_ref().unwrap() }
      .construct(env, &java_optional_label, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_label);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for DebuggerStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for DebuggerStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_DEBUGGER_STMT.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Decorator {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Decorator {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_DECORATOR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for DoWhileStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for DoWhileStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_test = self.test.to_java_with_map(env, map);
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_DO_WHILE_STMT.as_ref().unwrap() }
      .construct(env, &java_test, &java_body, &java_span_ex);
    delete_local_ref!(env, java_test);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for EmptyStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for EmptyStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_EMPTY_STMT.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportAll {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.src.register_with_map(map);
    self.with.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportAll {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_src = self.src.to_java_with_map(env, map);
    let type_only = self.type_only;
    let java_optional_with = self.with.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_EXPORT_ALL.as_ref().unwrap() }
      .construct(env, &java_src, type_only, &java_optional_with, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_with);
    delete_local_ref!(env, java_src);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.decl.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_decl = self.decl.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_EXPORT_DECL.as_ref().unwrap() }
      .construct(env, &java_decl, &java_span_ex);
    delete_local_ref!(env, java_decl);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportDefaultDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.decl.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportDefaultDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_decl = self.decl.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_EXPORT_DEFAULT_DECL.as_ref().unwrap() }
      .construct(env, &java_decl, &java_span_ex);
    delete_local_ref!(env, java_decl);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportDefaultExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportDefaultExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_EXPORT_DEFAULT_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportDefaultSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.exported.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportDefaultSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_exported = self.exported.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_exported, &java_span_ex);
    delete_local_ref!(env, java_exported);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportNamedSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.orig.register_with_map(map);
    self.exported.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportNamedSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_orig = self.orig.to_java_with_map(env, map);
    let java_optional_exported = self.exported.as_ref().map(|node| node.to_java_with_map(env, map));
    let is_type_only = self.is_type_only;
    let return_value = unsafe { JAVA_CLASS_EXPORT_NAMED_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_orig, &java_optional_exported, is_type_only, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_exported);
    delete_local_ref!(env, java_orig);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportNamespaceSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportNamespaceSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_name = self.name.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_name, &java_span_ex);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExprOrSpread {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExprOrSpread {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_optional_spread = self.spread.as_ref().map(|node| map.get_span_ex_by_span(node).to_java(env));
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_EXPR_OR_SPREAD.as_ref().unwrap() }
      .construct(env, &java_optional_spread, &java_expr, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_spread);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExprStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExprStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_EXPR_STMT.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for FnDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.ident.register_with_map(map);
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for FnDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_ident = self.ident.to_java_with_map(env, map);
    let declare = self.declare;
    let java_function = self.function.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_FN_DECL.as_ref().unwrap() }
      .construct(env, &java_ident, declare, &java_function, &java_span_ex);
    delete_local_ref!(env, java_ident);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for FnExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.ident.as_ref().map(|node| node.register_with_map(map));
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for FnExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_optional_ident = self.ident.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_function = self.function.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_FN_EXPR.as_ref().unwrap() }
      .construct(env, &java_optional_ident, &java_function, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_ident);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ForInStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ForInStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_left = self.left.to_java_with_map(env, map);
    let java_right = self.right.to_java_with_map(env, map);
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_FOR_IN_STMT.as_ref().unwrap() }
      .construct(env, &java_left, &java_right, &java_body, &java_span_ex);
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ForOfStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ForOfStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let is_await = self.is_await;
    let java_left = self.left.to_java_with_map(env, map);
    let java_right = self.right.to_java_with_map(env, map);
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_FOR_OF_STMT.as_ref().unwrap() }
      .construct(env, is_await, &java_left, &java_right, &java_body, &java_span_ex);
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ForStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.init.as_ref().map(|node| node.register_with_map(map));
    self.test.as_ref().map(|node| node.register_with_map(map));
    self.update.as_ref().map(|node| node.register_with_map(map));
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ForStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_optional_init = self.init.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_test = self.test.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_update = self.update.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_FOR_STMT.as_ref().unwrap() }
      .construct(env, &java_optional_init, &java_optional_test, &java_optional_update, &java_body, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_init);
    delete_local_optional_ref!(env, java_optional_test);
    delete_local_optional_ref!(env, java_optional_update);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Function {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.decorators.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.body.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.return_type.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Function {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_decorators = list_new(env, self.decorators.len());
    self.decorators.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_decorators, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_body = self.body.as_ref().map(|node| node.to_java_with_map(env, map));
    let is_generator = self.is_generator;
    let is_async = self.is_async;
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_return_type = self.return_type.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_FUNCTION.as_ref().unwrap() }
      .construct(env, &java_params, &java_decorators, &java_optional_body, is_generator, is_async, &java_optional_type_params, &java_optional_return_type, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_optional_ref!(env, java_optional_return_type);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for GetterProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.body.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for GetterProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_body = self.body.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_GETTER_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_type_ann, &java_optional_body, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Ident {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Ident {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let sym = self.sym.as_str();
    let optional = self.optional;
    let return_value = unsafe { JAVA_CLASS_IDENT.as_ref().unwrap() }
      .construct(env, sym, optional, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for IfStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.register_with_map(map);
    self.cons.register_with_map(map);
    self.alt.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for IfStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_test = self.test.to_java_with_map(env, map);
    let java_cons = self.cons.to_java_with_map(env, map);
    let java_optional_alt = self.alt.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_IF_STMT.as_ref().unwrap() }
      .construct(env, &java_test, &java_cons, &java_optional_alt, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_alt);
    delete_local_ref!(env, java_test);
    delete_local_ref!(env, java_cons);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Import {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Import {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_phase = self.phase.to_java(env);
    let return_value = unsafe { JAVA_CLASS_IMPORT.as_ref().unwrap() }
      .construct(env, &java_phase, &java_span_ex);
    delete_local_ref!(env, java_phase);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.specifiers.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.src.register_with_map(map);
    self.with.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_specifiers = list_new(env, self.specifiers.len());
    self.specifiers.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_specifiers, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_src = self.src.to_java_with_map(env, map);
    let type_only = self.type_only;
    let java_optional_with = self.with.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_phase = self.phase.to_java(env);
    let return_value = unsafe { JAVA_CLASS_IMPORT_DECL.as_ref().unwrap() }
      .construct(env, &java_specifiers, &java_src, type_only, &java_optional_with, &java_phase, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_with);
    delete_local_ref!(env, java_specifiers);
    delete_local_ref!(env, java_src);
    delete_local_ref!(env, java_phase);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportDefaultSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.local.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportDefaultSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_local = self.local.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_local, &java_span_ex);
    delete_local_ref!(env, java_local);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportNamedSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.local.register_with_map(map);
    self.imported.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportNamedSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_local = self.local.to_java_with_map(env, map);
    let java_optional_imported = self.imported.as_ref().map(|node| node.to_java_with_map(env, map));
    let is_type_only = self.is_type_only;
    let return_value = unsafe { JAVA_CLASS_IMPORT_NAMED_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_local, &java_optional_imported, is_type_only, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_imported);
    delete_local_ref!(env, java_local);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportStarAsSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.local.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportStarAsSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_local = self.local.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_local, &java_span_ex);
    delete_local_ref!(env, java_local);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Invalid {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Invalid {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_INVALID.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXAttr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXAttr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_name = self.name.to_java_with_map(env, map);
    let java_optional_value = self.value.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_JSX_ATTR.as_ref().unwrap() }
      .construct(env, &java_name, &java_optional_value, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXClosingElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXClosingElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_name = self.name.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_JSX_CLOSING_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_name, &java_span_ex);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXClosingFragment {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXClosingFragment {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_JSX_CLOSING_FRAGMENT.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.opening.register_with_map(map);
    self.children.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.closing.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_opening = self.opening.to_java_with_map(env, map);
    let java_children = list_new(env, self.children.len());
    self.children.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_children, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_closing = self.closing.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_JSX_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_opening, &java_children, &java_optional_closing, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_closing);
    delete_local_ref!(env, java_opening);
    delete_local_ref!(env, java_children);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXEmptyExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXEmptyExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_JSX_EMPTY_EXPR.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXExprContainer {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXExprContainer {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_JSX_EXPR_CONTAINER.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXFragment {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.opening.register_with_map(map);
    self.children.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.closing.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXFragment {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_opening = self.opening.to_java_with_map(env, map);
    let java_children = list_new(env, self.children.len());
    self.children.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_children, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_closing = self.closing.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_JSX_FRAGMENT.as_ref().unwrap() }
      .construct(env, &java_opening, &java_children, &java_closing, &java_span_ex);
    delete_local_ref!(env, java_opening);
    delete_local_ref!(env, java_children);
    delete_local_ref!(env, java_closing);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXMemberExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.obj.register_with_map(map);
    self.prop.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXMemberExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_obj = self.obj.to_java_with_map(env, map);
    let java_prop = self.prop.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_JSX_MEMBER_EXPR.as_ref().unwrap() }
      .construct(env, &java_obj, &java_prop, &java_span_ex);
    delete_local_ref!(env, java_obj);
    delete_local_ref!(env, java_prop);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXNamespacedName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.ns.register_with_map(map);
    self.name.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXNamespacedName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_ns = self.ns.to_java_with_map(env, map);
    let java_name = self.name.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_JSX_NAMESPACED_NAME.as_ref().unwrap() }
      .construct(env, &java_ns, &java_name, &java_span_ex);
    delete_local_ref!(env, java_ns);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXOpeningElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
    self.attrs.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXOpeningElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_name = self.name.to_java_with_map(env, map);
    let java_attrs = list_new(env, self.attrs.len());
    self.attrs.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_attrs, &java_node);
      delete_local_ref!(env, java_node);
    });
    let self_closing = self.self_closing;
    let java_optional_type_args = self.type_args.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_JSX_OPENING_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_name, &java_attrs, self_closing, &java_optional_type_args, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_attrs);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXOpeningFragment {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXOpeningFragment {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_JSX_OPENING_FRAGMENT.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXSpreadChild {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXSpreadChild {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_JSX_SPREAD_CHILD.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXText {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXText {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let value = self.value.as_str();
    let raw = self.raw.as_str();
    let return_value = unsafe { JAVA_CLASS_JSX_TEXT.as_ref().unwrap() }
      .construct(env, value, raw, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for KeyValuePatProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.key.register_with_map(map);
    self.value.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for KeyValuePatProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_value = self.value.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_KEY_VALUE_PAT_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_value, &java_span_ex);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for KeyValueProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.key.register_with_map(map);
    self.value.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for KeyValueProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_value = self.value.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_KEY_VALUE_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_value, &java_span_ex);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for LabeledStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.label.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for LabeledStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_label = self.label.to_java_with_map(env, map);
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_LABELED_STMT.as_ref().unwrap() }
      .construct(env, &java_label, &java_body, &java_span_ex);
    delete_local_ref!(env, java_label);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for MemberExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.obj.register_with_map(map);
    self.prop.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for MemberExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_obj = self.obj.to_java_with_map(env, map);
    let java_prop = self.prop.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_MEMBER_EXPR.as_ref().unwrap() }
      .construct(env, &java_obj, &java_prop, &java_span_ex);
    delete_local_ref!(env, java_obj);
    delete_local_ref!(env, java_prop);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for MetaPropExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for MetaPropExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_kind = self.kind.to_java(env);
    let return_value = unsafe { JAVA_CLASS_META_PROP_EXPR.as_ref().unwrap() }
      .construct(env, &java_kind, &java_span_ex);
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for MethodProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.key.register_with_map(map);
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for MethodProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_function = self.function.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_METHOD_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_function, &java_span_ex);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Module {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.body.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Module {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_body = list_new(env, self.body.len());
    self.body.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_body, &java_node);
      delete_local_ref!(env, java_node);
    });
    let optional_shebang = self.shebang.as_ref().map(|node| node.to_string());
    let return_value = unsafe { JAVA_CLASS_MODULE.as_ref().unwrap() }
      .construct(env, &java_body, &optional_shebang, &java_span_ex);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for NamedExport {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.specifiers.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.src.as_ref().map(|node| node.register_with_map(map));
    self.with.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for NamedExport {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_specifiers = list_new(env, self.specifiers.len());
    self.specifiers.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_specifiers, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_src = self.src.as_ref().map(|node| node.to_java_with_map(env, map));
    let type_only = self.type_only;
    let java_optional_with = self.with.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_NAMED_EXPORT.as_ref().unwrap() }
      .construct(env, &java_specifiers, &java_optional_src, type_only, &java_optional_with, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_src);
    delete_local_optional_ref!(env, java_optional_with);
    delete_local_ref!(env, java_specifiers);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for NewExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.callee.register_with_map(map);
    self.args.as_ref().map(|nodes| nodes.iter().for_each(|node| node.register_with_map(map)));
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for NewExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_callee = self.callee.to_java_with_map(env, map);
    let java_optional_args = self.args.as_ref().map(|nodes| {
      let java_args = list_new(env, nodes.len());
      nodes.iter().for_each(|node| {
        let java_node = node.to_java_with_map(env, map);
        list_add(env, &java_args, &java_node);
        delete_local_ref!(env, java_node);
      });
      java_args
    });
    let java_optional_type_args = self.type_args.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_NEW_EXPR.as_ref().unwrap() }
      .construct(env, &java_callee, &java_optional_args, &java_optional_type_args, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_args);
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_callee);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Null {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Null {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_NULL.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Number {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Number {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let value = self.value;
    let optional_raw = self.raw.as_ref().map(|node| node.to_string());
    let return_value = unsafe { JAVA_CLASS_NUMBER.as_ref().unwrap() }
      .construct(env, value, &optional_raw, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ObjectLit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.props.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ObjectLit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_props = list_new(env, self.props.len());
    self.props.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_props, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_OBJECT_LIT.as_ref().unwrap() }
      .construct(env, &java_props, &java_span_ex);
    delete_local_ref!(env, java_props);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ObjectPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.props.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ObjectPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_props = list_new(env, self.props.len());
    self.props.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_props, &java_node);
      delete_local_ref!(env, java_node);
    });
    let optional = self.optional;
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_OBJECT_PAT.as_ref().unwrap() }
      .construct(env, &java_props, optional, &java_optional_type_ann, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_props);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for OptCall {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.callee.register_with_map(map);
    self.args.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for OptCall {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_callee = self.callee.to_java_with_map(env, map);
    let java_args = list_new(env, self.args.len());
    self.args.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_args, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_type_args = self.type_args.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_OPT_CALL.as_ref().unwrap() }
      .construct(env, &java_callee, &java_args, &java_optional_type_args, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_callee);
    delete_local_ref!(env, java_args);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for OptChainExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.base.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for OptChainExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let optional = self.optional;
    let java_base = self.base.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_OPT_CHAIN_EXPR.as_ref().unwrap() }
      .construct(env, optional, &java_base, &java_span_ex);
    delete_local_ref!(env, java_base);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Param {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.decorators.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.pat.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Param {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_decorators = list_new(env, self.decorators.len());
    self.decorators.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_decorators, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_pat = self.pat.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_PARAM.as_ref().unwrap() }
      .construct(env, &java_decorators, &java_pat, &java_span_ex);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_pat);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ParenExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ParenExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_PAREN_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for PrivateMethod {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PrivateMethod {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_function = self.function.to_java_with_map(env, map);
    let java_kind = self.kind.to_java(env);
    let is_static = self.is_static;
    let java_optional_accessibility = self.accessibility.as_ref().map(|node| node.to_java(env));
    let is_abstract = self.is_abstract;
    let is_optional = self.is_optional;
    let is_override = self.is_override;
    let return_value = unsafe { JAVA_CLASS_PRIVATE_METHOD.as_ref().unwrap() }
      .construct(env, &java_key, &java_function, &java_kind, is_static, &java_optional_accessibility, is_abstract, is_optional, is_override, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for PrivateName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PrivateName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_id = self.id.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_PRIVATE_NAME.as_ref().unwrap() }
      .construct(env, &java_id, &java_span_ex);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for PrivateProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.decorators.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PrivateProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_optional_value = self.value.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let is_static = self.is_static;
    let java_decorators = list_new(env, self.decorators.len());
    self.decorators.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_decorators, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_accessibility = self.accessibility.as_ref().map(|node| node.to_java(env));
    let is_optional = self.is_optional;
    let is_override = self.is_override;
    let readonly = self.readonly;
    let definite = self.definite;
    let return_value = unsafe { JAVA_CLASS_PRIVATE_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_value, &java_optional_type_ann, is_static, &java_decorators, &java_optional_accessibility, is_optional, is_override, readonly, definite, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Regex {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Regex {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let exp = self.exp.as_str();
    let flags = self.flags.as_str();
    let return_value = unsafe { JAVA_CLASS_REGEX.as_ref().unwrap() }
      .construct(env, exp, flags, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for RestPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    map.register_by_span(&self.dot3_token);
    self.arg.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for RestPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_dot3_token = map.get_span_ex_by_span(&self.dot3_token).to_java(env);
    let java_arg = self.arg.to_java_with_map(env, map);
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_REST_PAT.as_ref().unwrap() }
      .construct(env, &java_dot3_token, &java_arg, &java_optional_type_ann, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_dot3_token);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ReturnStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ReturnStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_optional_arg = self.arg.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_RETURN_STMT.as_ref().unwrap() }
      .construct(env, &java_optional_arg, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_arg);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Script {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.body.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Script {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_body = list_new(env, self.body.len());
    self.body.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_body, &java_node);
      delete_local_ref!(env, java_node);
    });
    let optional_shebang = self.shebang.as_ref().map(|node| node.to_string());
    let return_value = unsafe { JAVA_CLASS_SCRIPT.as_ref().unwrap() }
      .construct(env, &java_body, &optional_shebang, &java_span_ex);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for SeqExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.exprs.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SeqExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_exprs = list_new(env, self.exprs.len());
    self.exprs.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_exprs, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_SEQ_EXPR.as_ref().unwrap() }
      .construct(env, &java_exprs, &java_span_ex);
    delete_local_ref!(env, java_exprs);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for SetterProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.this_param.as_ref().map(|node| node.register_with_map(map));
    self.param.register_with_map(map);
    self.body.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SetterProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_key = self.key.to_java_with_map(env, map);
    let java_optional_this_param = self.this_param.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_param = self.param.to_java_with_map(env, map);
    let java_optional_body = self.body.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_SETTER_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_this_param, &java_param, &java_optional_body, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_this_param);
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_param);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for SpreadElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    map.register_by_span(&self.dot3_token);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SpreadElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_dot3_token = map.get_span_ex_by_span(&self.dot3_token).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_SPREAD_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_dot3_token, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_dot3_token);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for StaticBlock {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for StaticBlock {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_STATIC_BLOCK.as_ref().unwrap() }
      .construct(env, &java_body, &java_span_ex);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Str {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Str {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let value = self.value.as_str();
    let optional_raw = self.raw.as_ref().map(|node| node.to_string());
    let return_value = unsafe { JAVA_CLASS_STR.as_ref().unwrap() }
      .construct(env, value, &optional_raw, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Super {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Super {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_SUPER.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for SuperPropExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.obj.register_with_map(map);
    self.prop.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SuperPropExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_obj = self.obj.to_java_with_map(env, map);
    let java_prop = self.prop.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_SUPER_PROP_EXPR.as_ref().unwrap() }
      .construct(env, &java_obj, &java_prop, &java_span_ex);
    delete_local_ref!(env, java_obj);
    delete_local_ref!(env, java_prop);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for SwitchCase {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.as_ref().map(|node| node.register_with_map(map));
    self.cons.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SwitchCase {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_optional_test = self.test.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_cons = list_new(env, self.cons.len());
    self.cons.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_cons, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_SWITCH_CASE.as_ref().unwrap() }
      .construct(env, &java_optional_test, &java_cons, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_test);
    delete_local_ref!(env, java_cons);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for SwitchStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.discriminant.register_with_map(map);
    self.cases.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SwitchStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_discriminant = self.discriminant.to_java_with_map(env, map);
    let java_cases = list_new(env, self.cases.len());
    self.cases.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_cases, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_SWITCH_STMT.as_ref().unwrap() }
      .construct(env, &java_discriminant, &java_cases, &java_span_ex);
    delete_local_ref!(env, java_discriminant);
    delete_local_ref!(env, java_cases);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TaggedTpl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.tag.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.tpl.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TaggedTpl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_tag = self.tag.to_java_with_map(env, map);
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_tpl = self.tpl.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TAGGED_TPL.as_ref().unwrap() }
      .construct(env, &java_tag, &java_optional_type_params, &java_tpl, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_tag);
    delete_local_ref!(env, java_tpl);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ThisExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ThisExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_THIS_EXPR.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for ThrowStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ThrowStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_arg = self.arg.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_THROW_STMT.as_ref().unwrap() }
      .construct(env, &java_arg, &java_span_ex);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for Tpl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.exprs.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.quasis.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Tpl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_exprs = list_new(env, self.exprs.len());
    self.exprs.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_exprs, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_quasis = list_new(env, self.quasis.len());
    self.quasis.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_quasis, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TPL.as_ref().unwrap() }
      .construct(env, &java_exprs, &java_quasis, &java_span_ex);
    delete_local_ref!(env, java_exprs);
    delete_local_ref!(env, java_quasis);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TplElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TplElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let tail = self.tail;
    let optional_cooked = self.cooked.as_ref().map(|node| node.to_string());
    let raw = self.raw.as_str();
    let return_value = unsafe { JAVA_CLASS_TPL_ELEMENT.as_ref().unwrap() }
      .construct(env, tail, &optional_cooked, raw, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TryStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.block.register_with_map(map);
    self.handler.as_ref().map(|node| node.register_with_map(map));
    self.finalizer.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TryStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_block = self.block.to_java_with_map(env, map);
    let java_optional_handler = self.handler.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_finalizer = self.finalizer.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TRY_STMT.as_ref().unwrap() }
      .construct(env, &java_block, &java_optional_handler, &java_optional_finalizer, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_handler);
    delete_local_optional_ref!(env, java_optional_finalizer);
    delete_local_ref!(env, java_block);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsArrayType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.elem_type.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsArrayType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_elem_type = self.elem_type.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_ARRAY_TYPE.as_ref().unwrap() }
      .construct(env, &java_elem_type, &java_span_ex);
    delete_local_ref!(env, java_elem_type);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsAsExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsAsExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_AS_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_type_ann, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsCallSignatureDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsCallSignatureDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_CALL_SIGNATURE_DECL.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsConditionalType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.check_type.register_with_map(map);
    self.extends_type.register_with_map(map);
    self.true_type.register_with_map(map);
    self.false_type.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsConditionalType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_check_type = self.check_type.to_java_with_map(env, map);
    let java_extends_type = self.extends_type.to_java_with_map(env, map);
    let java_true_type = self.true_type.to_java_with_map(env, map);
    let java_false_type = self.false_type.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_CONDITIONAL_TYPE.as_ref().unwrap() }
      .construct(env, &java_check_type, &java_extends_type, &java_true_type, &java_false_type, &java_span_ex);
    delete_local_ref!(env, java_check_type);
    delete_local_ref!(env, java_extends_type);
    delete_local_ref!(env, java_true_type);
    delete_local_ref!(env, java_false_type);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsConstAssertion {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsConstAssertion {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_CONST_ASSERTION.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsConstructSignatureDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsConstructSignatureDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsConstructorType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsConstructorType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let is_abstract = self.is_abstract;
    let return_value = unsafe { JAVA_CLASS_TS_CONSTRUCTOR_TYPE.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_params, &java_type_ann, is_abstract, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsEnumDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.members.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsEnumDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let declare = self.declare;
    let is_const = self.is_const;
    let java_id = self.id.to_java_with_map(env, map);
    let java_members = list_new(env, self.members.len());
    self.members.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_members, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_ENUM_DECL.as_ref().unwrap() }
      .construct(env, declare, is_const, &java_id, &java_members, &java_span_ex);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_members);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsEnumMember {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.init.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsEnumMember {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_id = self.id.to_java_with_map(env, map);
    let java_optional_init = self.init.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_ENUM_MEMBER.as_ref().unwrap() }
      .construct(env, &java_id, &java_optional_init, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_init);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsExportAssignment {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsExportAssignment {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_EXPORT_ASSIGNMENT.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsExprWithTypeArgs {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsExprWithTypeArgs {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let java_optional_type_args = self.type_args.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS.as_ref().unwrap() }
      .construct(env, &java_expr, &java_optional_type_args, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsExternalModuleRef {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsExternalModuleRef {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_EXTERNAL_MODULE_REF.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsFnType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsFnType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_FN_TYPE.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_params, &java_type_ann, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsGetterSignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsGetterSignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let readonly = self.readonly;
    let java_key = self.key.to_java_with_map(env, map);
    let computed = self.computed;
    let optional = self.optional;
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_GETTER_SIGNATURE.as_ref().unwrap() }
      .construct(env, readonly, &java_key, computed, optional, &java_optional_type_ann, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsImportEqualsDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.module_ref.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsImportEqualsDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let is_export = self.is_export;
    let is_type_only = self.is_type_only;
    let java_id = self.id.to_java_with_map(env, map);
    let java_module_ref = self.module_ref.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_IMPORT_EQUALS_DECL.as_ref().unwrap() }
      .construct(env, is_export, is_type_only, &java_id, &java_module_ref, &java_span_ex);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_module_ref);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsImportType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
    self.qualifier.as_ref().map(|node| node.register_with_map(map));
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsImportType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_arg = self.arg.to_java_with_map(env, map);
    let java_optional_qualifier = self.qualifier.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_type_args = self.type_args.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_IMPORT_TYPE.as_ref().unwrap() }
      .construct(env, &java_arg, &java_optional_qualifier, &java_optional_type_args, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_qualifier);
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsIndexSignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsIndexSignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let readonly = self.readonly;
    let is_static = self.is_static;
    let return_value = unsafe { JAVA_CLASS_TS_INDEX_SIGNATURE.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_ann, readonly, is_static, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsIndexedAccessType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.obj_type.register_with_map(map);
    self.index_type.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsIndexedAccessType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let readonly = self.readonly;
    let java_obj_type = self.obj_type.to_java_with_map(env, map);
    let java_index_type = self.index_type.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_INDEXED_ACCESS_TYPE.as_ref().unwrap() }
      .construct(env, readonly, &java_obj_type, &java_index_type, &java_span_ex);
    delete_local_ref!(env, java_obj_type);
    delete_local_ref!(env, java_index_type);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsInferType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_param.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsInferType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_type_param = self.type_param.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_INFER_TYPE.as_ref().unwrap() }
      .construct(env, &java_type_param, &java_span_ex);
    delete_local_ref!(env, java_type_param);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsInstantiation {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_args.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsInstantiation {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let java_type_args = self.type_args.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_INSTANTIATION.as_ref().unwrap() }
      .construct(env, &java_expr, &java_type_args, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_type_args);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsInterfaceBody {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.body.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsInterfaceBody {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_body = list_new(env, self.body.len());
    self.body.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_body, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_INTERFACE_BODY.as_ref().unwrap() }
      .construct(env, &java_body, &java_span_ex);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsInterfaceDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.extends.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsInterfaceDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_id = self.id.to_java_with_map(env, map);
    let declare = self.declare;
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_extends = list_new(env, self.extends.len());
    self.extends.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_extends, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_INTERFACE_DECL.as_ref().unwrap() }
      .construct(env, &java_id, declare, &java_optional_type_params, &java_extends, &java_body, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_extends);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsIntersectionType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.types.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsIntersectionType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_types = list_new(env, self.types.len());
    self.types.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_types, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_INTERSECTION_TYPE.as_ref().unwrap() }
      .construct(env, &java_types, &java_span_ex);
    delete_local_ref!(env, java_types);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsKeywordType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsKeywordType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_kind = self.kind.to_java(env);
    let return_value = unsafe { JAVA_CLASS_TS_KEYWORD_TYPE.as_ref().unwrap() }
      .construct(env, &java_kind, &java_span_ex);
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsLitType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.lit.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsLitType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_lit = self.lit.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_LIT_TYPE.as_ref().unwrap() }
      .construct(env, &java_lit, &java_span_ex);
    delete_local_ref!(env, java_lit);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsMappedType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_param.register_with_map(map);
    self.name_type.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsMappedType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_optional_readonly = self.readonly.as_ref().map(|node| node.to_java(env));
    let java_type_param = self.type_param.to_java_with_map(env, map);
    let java_optional_name_type = self.name_type.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_optional = self.optional.as_ref().map(|node| node.to_java(env));
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_MAPPED_TYPE.as_ref().unwrap() }
      .construct(env, &java_optional_readonly, &java_type_param, &java_optional_name_type, &java_optional_optional, &java_optional_type_ann, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_readonly);
    delete_local_optional_ref!(env, java_optional_name_type);
    delete_local_optional_ref!(env, java_optional_optional);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_type_param);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsMethodSignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsMethodSignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let readonly = self.readonly;
    let java_key = self.key.to_java_with_map(env, map);
    let computed = self.computed;
    let optional = self.optional;
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_METHOD_SIGNATURE.as_ref().unwrap() }
      .construct(env, readonly, &java_key, computed, optional, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsModuleBlock {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.body.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsModuleBlock {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_body = list_new(env, self.body.len());
    self.body.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_body, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_MODULE_BLOCK.as_ref().unwrap() }
      .construct(env, &java_body, &java_span_ex);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsModuleDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.body.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsModuleDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let declare = self.declare;
    let global = self.global;
    let java_id = self.id.to_java_with_map(env, map);
    let java_optional_body = self.body.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_MODULE_DECL.as_ref().unwrap() }
      .construct(env, declare, global, &java_id, &java_optional_body, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsNamespaceDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsNamespaceDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let declare = self.declare;
    let global = self.global;
    let java_id = self.id.to_java_with_map(env, map);
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_NAMESPACE_DECL.as_ref().unwrap() }
      .construct(env, declare, global, &java_id, &java_body, &java_span_ex);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsNamespaceExportDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsNamespaceExportDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_id = self.id.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL.as_ref().unwrap() }
      .construct(env, &java_id, &java_span_ex);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsNonNullExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsNonNullExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_NON_NULL_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsOptionalType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsOptionalType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_OPTIONAL_TYPE.as_ref().unwrap() }
      .construct(env, &java_type_ann, &java_span_ex);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsParamProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.decorators.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.param.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsParamProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_decorators = list_new(env, self.decorators.len());
    self.decorators.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_decorators, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_accessibility = self.accessibility.as_ref().map(|node| node.to_java(env));
    let is_override = self.is_override;
    let readonly = self.readonly;
    let java_param = self.param.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_PARAM_PROP.as_ref().unwrap() }
      .construct(env, &java_decorators, &java_optional_accessibility, is_override, readonly, &java_param, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_param);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsParenthesizedType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsParenthesizedType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_PARENTHESIZED_TYPE.as_ref().unwrap() }
      .construct(env, &java_type_ann, &java_span_ex);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsPropertySignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.init.as_ref().map(|node| node.register_with_map(map));
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsPropertySignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let readonly = self.readonly;
    let java_key = self.key.to_java_with_map(env, map);
    let computed = self.computed;
    let optional = self.optional;
    let java_optional_init = self.init.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_PROPERTY_SIGNATURE.as_ref().unwrap() }
      .construct(env, readonly, &java_key, computed, optional, &java_optional_init, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_init);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsQualifiedName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.left.register_with_map(map);
    self.right.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsQualifiedName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env);
    let java_left = self.left.to_java_with_map(env, map);
    let java_right = self.right.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_QUALIFIED_NAME.as_ref().unwrap() }
      .construct(env, &java_left, &java_right, &java_span_ex);
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsRestType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsRestType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_REST_TYPE.as_ref().unwrap() }
      .construct(env, &java_type_ann, &java_span_ex);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsSatisfiesExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsSatisfiesExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_SATISFIES_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_type_ann, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsSetterSignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.param.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsSetterSignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let readonly = self.readonly;
    let java_key = self.key.to_java_with_map(env, map);
    let computed = self.computed;
    let optional = self.optional;
    let java_param = self.param.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_SETTER_SIGNATURE.as_ref().unwrap() }
      .construct(env, readonly, &java_key, computed, optional, &java_param, &java_span_ex);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_param);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsThisType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsThisType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let return_value = unsafe { JAVA_CLASS_TS_THIS_TYPE.as_ref().unwrap() }
      .construct(env, &java_span_ex);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTplLitType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.types.iter().for_each(|node| {
      node.register_with_map(map);
    });
    self.quasis.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTplLitType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_types = list_new(env, self.types.len());
    self.types.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_types, &java_node);
      delete_local_ref!(env, java_node);
    });
    let java_quasis = list_new(env, self.quasis.len());
    self.quasis.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_quasis, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_TPL_LIT_TYPE.as_ref().unwrap() }
      .construct(env, &java_types, &java_quasis, &java_span_ex);
    delete_local_ref!(env, java_types);
    delete_local_ref!(env, java_quasis);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTupleElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.label.as_ref().map(|node| node.register_with_map(map));
    self.ty.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTupleElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_optional_label = self.label.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_ty = self.ty.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_TUPLE_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_optional_label, &java_ty, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_label);
    delete_local_ref!(env, java_ty);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTupleType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.elem_types.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTupleType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_elem_types = list_new(env, self.elem_types.len());
    self.elem_types.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_elem_types, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_TUPLE_TYPE.as_ref().unwrap() }
      .construct(env, &java_elem_types, &java_span_ex);
    delete_local_ref!(env, java_elem_types);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeAliasDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeAliasDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_id = self.id.to_java_with_map(env, map);
    let declare = self.declare;
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_ALIAS_DECL.as_ref().unwrap() }
      .construct(env, &java_id, declare, &java_optional_type_params, &java_type_ann, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeAnn {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeAnn {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_ANN.as_ref().unwrap() }
      .construct(env, &java_type_ann, &java_span_ex);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeAssertion {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeAssertion {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr = self.expr.to_java_with_map(env, map);
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_ASSERTION.as_ref().unwrap() }
      .construct(env, &java_expr, &java_type_ann, &java_span_ex);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeLit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.members.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeLit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_members = list_new(env, self.members.len());
    self.members.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_members, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_LIT.as_ref().unwrap() }
      .construct(env, &java_members, &java_span_ex);
    delete_local_ref!(env, java_members);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeOperator {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeOperator {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_op = self.op.to_java(env);
    let java_type_ann = self.type_ann.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_OPERATOR.as_ref().unwrap() }
      .construct(env, &java_op, &java_type_ann, &java_span_ex);
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeParam {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
    self.constraint.as_ref().map(|node| node.register_with_map(map));
    self.default.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeParam {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_name = self.name.to_java_with_map(env, map);
    let is_in = self.is_in;
    let is_out = self.is_out;
    let is_const = self.is_const;
    let java_optional_constraint = self.constraint.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_default = self.default.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_PARAM.as_ref().unwrap() }
      .construct(env, &java_name, is_in, is_out, is_const, &java_optional_constraint, &java_optional_default, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_constraint);
    delete_local_optional_ref!(env, java_optional_default);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeParamDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeParamDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_PARAM_DECL.as_ref().unwrap() }
      .construct(env, &java_params, &java_span_ex);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeParamInstantiation {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.params.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeParamInstantiation {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_params = list_new(env, self.params.len());
    self.params.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_params, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION.as_ref().unwrap() }
      .construct(env, &java_params, &java_span_ex);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypePredicate {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.param_name.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypePredicate {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let asserts = self.asserts;
    let java_param_name = self.param_name.to_java_with_map(env, map);
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_PREDICATE.as_ref().unwrap() }
      .construct(env, asserts, &java_param_name, &java_optional_type_ann, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_param_name);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeQuery {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr_name.register_with_map(map);
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeQuery {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_expr_name = self.expr_name.to_java_with_map(env, map);
    let java_optional_type_args = self.type_args.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_QUERY.as_ref().unwrap() }
      .construct(env, &java_expr_name, &java_optional_type_args, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_expr_name);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeRef {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_name.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeRef {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_type_name = self.type_name.to_java_with_map(env, map);
    let java_optional_type_params = self.type_params.as_ref().map(|node| node.to_java_with_map(env, map));
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_REF.as_ref().unwrap() }
      .construct(env, &java_type_name, &java_optional_type_params, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_type_name);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsUnionType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.types.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsUnionType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_types = list_new(env, self.types.len());
    self.types.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_types, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_TS_UNION_TYPE.as_ref().unwrap() }
      .construct(env, &java_types, &java_span_ex);
    delete_local_ref!(env, java_types);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for UnaryExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for UnaryExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_op = self.op.to_java(env);
    let java_arg = self.arg.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_UNARY_EXPR.as_ref().unwrap() }
      .construct(env, &java_op, &java_arg, &java_span_ex);
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for UpdateExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for UpdateExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_op = self.op.to_java(env);
    let prefix = self.prefix;
    let java_arg = self.arg.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_UPDATE_EXPR.as_ref().unwrap() }
      .construct(env, &java_op, prefix, &java_arg, &java_span_ex);
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for UsingDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.decls.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for UsingDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let is_await = self.is_await;
    let java_decls = list_new(env, self.decls.len());
    self.decls.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_decls, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_USING_DECL.as_ref().unwrap() }
      .construct(env, is_await, &java_decls, &java_span_ex);
    delete_local_ref!(env, java_decls);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for VarDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.decls.iter().for_each(|node| {
      node.register_with_map(map);
    });
  }
}

impl ToJavaWithMap<ByteToIndexMap> for VarDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_kind = self.kind.to_java(env);
    let declare = self.declare;
    let java_decls = list_new(env, self.decls.len());
    self.decls.iter().for_each(|node| {
      let java_node = node.to_java_with_map(env, map);
      list_add(env, &java_decls, &java_node);
      delete_local_ref!(env, java_node);
    });
    let return_value = unsafe { JAVA_CLASS_VAR_DECL.as_ref().unwrap() }
      .construct(env, &java_kind, declare, &java_decls, &java_span_ex);
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_decls);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for VarDeclarator {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
    self.init.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for VarDeclarator {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_name = self.name.to_java_with_map(env, map);
    let java_optional_init = self.init.as_ref().map(|node| node.to_java_with_map(env, map));
    let definite = self.definite;
    let return_value = unsafe { JAVA_CLASS_VAR_DECLARATOR.as_ref().unwrap() }
      .construct(env, &java_name, &java_optional_init, definite, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_init);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for WhileStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for WhileStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_test = self.test.to_java_with_map(env, map);
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_WHILE_STMT.as_ref().unwrap() }
      .construct(env, &java_test, &java_body, &java_span_ex);
    delete_local_ref!(env, java_test);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for WithStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.obj.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for WithStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_obj = self.obj.to_java_with_map(env, map);
    let java_body = self.body.to_java_with_map(env, map);
    let return_value = unsafe { JAVA_CLASS_WITH_STMT.as_ref().unwrap() }
      .construct(env, &java_obj, &java_body, &java_span_ex);
    delete_local_ref!(env, java_obj);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl RegisterWithMap<ByteToIndexMap> for YieldExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for YieldExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env);
    let java_optional_arg = self.arg.as_ref().map(|node| node.to_java_with_map(env, map));
    let delegate = self.delegate;
    let return_value = unsafe { JAVA_CLASS_YIELD_EXPR.as_ref().unwrap() }
      .construct(env, &java_optional_arg, delegate, &java_span_ex);
    delete_local_optional_ref!(env, java_optional_arg);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}
/* AST End */
