/*
* Copyright (c) 2024. caoccao.com Sam Cao
* All rights reserved.

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

* http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

use jni::objects::{GlobalRef, JMethodID, JObject, JString};
use jni::signature::{Primitive, ReturnType};
use jni::sys::jvalue;
use jni::JNIEnv;

use crate::jni_utils::*;
use crate::span_utils::ByteToIndexMap;

use deno_ast::swc::ast::*;
use deno_ast::swc::common::Spanned;

use std::ptr::null_mut;

/*
 * This file is 99% code generated.
 * Do not edit this file unless you know what you are doing.
 */

/* JNI Begin */
#[allow(dead_code)]
struct JavaSwc4jAstArrayLit {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elems: JMethodID,
}
unsafe impl Send for JavaSwc4jAstArrayLit {}
unsafe impl Sync for JavaSwc4jAstArrayLit {}

#[allow(dead_code)]
impl JavaSwc4jAstArrayLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstArrayLit")
      .expect("Couldn't find class Swc4jAstArrayLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstArrayLit");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstArrayLit::new");
    let method_get_elems = env
      .get_method_id(
        &class,
        "getElems",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstArrayLit.getElems");
    JavaSwc4jAstArrayLit {
      class,
      method_construct,
      method_get_elems,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elems: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let elems = object_to_jvalue!(elems);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elems, span],
        "Swc4jAstArrayLit construct()"
      );
    return_value
  }

  pub fn get_elems<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elems,
        &[],
        "List get_elems()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstArrayPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elems: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstArrayPat {}
unsafe impl Sync for JavaSwc4jAstArrayPat {}

#[allow(dead_code)]
impl JavaSwc4jAstArrayPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstArrayPat")
      .expect("Couldn't find class Swc4jAstArrayPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstArrayPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstArrayPat::new");
    let method_get_elems = env
      .get_method_id(
        &class,
        "getElems",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstArrayPat.getElems");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstArrayPat.getTypeAnn");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstArrayPat.isOptional");
    JavaSwc4jAstArrayPat {
      class,
      method_construct,
      method_get_elems,
      method_get_type_ann,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elems: &JObject<'_>,
    optional: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let elems = object_to_jvalue!(elems);
    let optional = boolean_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elems, optional, type_ann, span],
        "Swc4jAstArrayPat construct()"
      );
    return_value
  }

  pub fn get_elems<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elems,
        &[],
        "List get_elems()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstArrowExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_params: JMethodID,
  method_get_return_type: JMethodID,
  method_get_type_params: JMethodID,
  method_is_async: JMethodID,
  method_is_generator: JMethodID,
}
unsafe impl Send for JavaSwc4jAstArrowExpr {}
unsafe impl Sync for JavaSwc4jAstArrowExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstArrowExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstArrowExpr")
      .expect("Couldn't find class Swc4jAstArrowExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstArrowExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstBlockStmtOrExpr;ZZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstBlockStmtOrExpr;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getBody");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getParams");
    let method_get_return_type = env
      .get_method_id(
        &class,
        "getReturnType",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getReturnType");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getTypeParams");
    let method_is_async = env
      .get_method_id(
        &class,
        "isAsync",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.isAsync");
    let method_is_generator = env
      .get_method_id(
        &class,
        "isGenerator",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.isGenerator");
    JavaSwc4jAstArrowExpr {
      class,
      method_construct,
      method_get_body,
      method_get_params,
      method_get_return_type,
      method_get_type_params,
      method_is_async,
      method_is_generator,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    body: &JObject<'_>,
    is_async: bool,
    generator: bool,
    type_params: &Option<JObject>,
    return_type: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let body = object_to_jvalue!(body);
    let is_async = boolean_to_jvalue!(is_async);
    let generator = boolean_to_jvalue!(generator);
    let type_params = optional_object_to_jvalue!(type_params);
    let return_type = optional_object_to_jvalue!(return_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, body, is_async, generator, type_params, return_type, span],
        "Swc4jAstArrowExpr construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstBlockStmtOrExpr get_body()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_return_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_return_type,
        &[],
        "Optional get_return_type()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_async<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_async,
        &[],
        "boolean is_async()"
      );
    return_value
  }

  pub fn is_generator<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_generator,
        &[],
        "boolean is_generator()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_op: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignExpr {}
unsafe impl Sync for JavaSwc4jAstAssignExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstAssignExpr")
      .expect("Couldn't find class Swc4jAstAssignExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAssignOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstAssignTarget;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstAssignTarget;",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr.getLeft");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAssignOp;",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr.getOp");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr.getRight");
    JavaSwc4jAstAssignExpr {
      class,
      method_construct,
      method_get_left,
      method_get_op,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, left, right, span],
        "Swc4jAstAssignExpr construct()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstAssignTarget get_left()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstAssignOp get_op()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignPat {}
unsafe impl Sync for JavaSwc4jAstAssignPat {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstAssignPat")
      .expect("Couldn't find class Swc4jAstAssignPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignPat::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstAssignPat.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAssignPat.getRight");
    JavaSwc4jAstAssignPat {
      class,
      method_construct,
      method_get_left,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[left, right, span],
        "Swc4jAstAssignPat construct()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstPat get_left()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignPatProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignPatProp {}
unsafe impl Sync for JavaSwc4jAstAssignPatProp {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignPatProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstAssignPatProp")
      .expect("Couldn't find class Swc4jAstAssignPatProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignPatProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/pat/Swc4jAstBindingIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignPatProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/pat/Swc4jAstBindingIdent;",
      )
      .expect("Couldn't find method Swc4jAstAssignPatProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAssignPatProp.getValue");
    JavaSwc4jAstAssignPatProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstAssignPatProp construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstBindingIdent get_key()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignProp {}
unsafe impl Sync for JavaSwc4jAstAssignProp {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstAssignProp")
      .expect("Couldn't find class Swc4jAstAssignProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstAssignProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAssignProp.getValue");
    JavaSwc4jAstAssignProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstAssignProp construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstIdent get_key()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "ISwc4jAstExpr get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAutoAccessor {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_value: JMethodID,
  method_is_definite: JMethodID,
  method_is_override: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAutoAccessor {}
unsafe impl Sync for JavaSwc4jAstAutoAccessor {}

#[allow(dead_code)]
impl JavaSwc4jAstAutoAccessor {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstAutoAccessor")
      .expect("Couldn't find class Swc4jAstAutoAccessor");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAutoAccessor");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstKey;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getDecorators");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstKey;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getTypeAnn");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getValue");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isDefinite");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isOverride");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isStatic");
    JavaSwc4jAstAutoAccessor {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_key,
      method_get_type_ann,
      method_get_value,
      method_is_definite,
      method_is_override,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    type_ann: &Option<JObject>,
    is_static: bool,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    is_override: bool,
    definite: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let is_static = boolean_to_jvalue!(is_static);
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_override = boolean_to_jvalue!(is_override);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, type_ann, is_static, decorators, accessibility, is_override, definite, span],
        "Swc4jAstAutoAccessor construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstKey get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAwaitExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAwaitExpr {}
unsafe impl Sync for JavaSwc4jAstAwaitExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstAwaitExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstAwaitExpr")
      .expect("Couldn't find class Swc4jAstAwaitExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAwaitExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAwaitExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAwaitExpr.getArg");
    JavaSwc4jAstAwaitExpr {
      class,
      method_construct,
      method_get_arg,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, span],
        "Swc4jAstAwaitExpr construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBigInt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_sign: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBigInt {}
unsafe impl Sync for JavaSwc4jAstBigInt {}

#[allow(dead_code)]
impl JavaSwc4jAstBigInt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstBigInt")
      .expect("Couldn't find class Swc4jAstBigInt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBigInt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBigIntSign;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBigInt::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstBigInt.getRaw");
    let method_get_sign = env
      .get_method_id(
        &class,
        "getSign",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBigIntSign;",
      )
      .expect("Couldn't find method Swc4jAstBigInt.getSign");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/math/BigInteger;",
      )
      .expect("Couldn't find method Swc4jAstBigInt.getValue");
    JavaSwc4jAstBigInt {
      class,
      method_construct,
      method_get_raw,
      method_get_sign,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    sign: &JObject<'_>,
    raw: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let sign = object_to_jvalue!(sign);
    let java_raw = optional_string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[sign, raw, span],
        "Swc4jAstBigInt construct()"
      );
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_raw<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "Optional get_raw()"
      );
    return_value
  }

  pub fn get_sign<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_sign,
        &[],
        "Swc4jAstBigIntSign get_sign()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "BigInteger get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBinExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_op: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBinExpr {}
unsafe impl Sync for JavaSwc4jAstBinExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstBinExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstBinExpr")
      .expect("Couldn't find class Swc4jAstBinExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBinExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBinaryOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBinExpr::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstBinExpr.getLeft");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBinaryOp;",
      )
      .expect("Couldn't find method Swc4jAstBinExpr.getOp");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstBinExpr.getRight");
    JavaSwc4jAstBinExpr {
      class,
      method_construct,
      method_get_left,
      method_get_op,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, left, right, span],
        "Swc4jAstBinExpr construct()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstExpr get_left()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstBinaryOp get_op()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBindingIdent {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBindingIdent {}
unsafe impl Sync for JavaSwc4jAstBindingIdent {}

#[allow(dead_code)]
impl JavaSwc4jAstBindingIdent {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstBindingIdent")
      .expect("Couldn't find class Swc4jAstBindingIdent");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBindingIdent");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBindingIdent::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstBindingIdent.getId");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstBindingIdent.getTypeAnn");
    JavaSwc4jAstBindingIdent {
      class,
      method_construct,
      method_get_id,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, type_ann, span],
        "Swc4jAstBindingIdent construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBlockStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_stmts: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBlockStmt {}
unsafe impl Sync for JavaSwc4jAstBlockStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstBlockStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt")
      .expect("Couldn't find class Swc4jAstBlockStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBlockStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBlockStmt::new");
    let method_get_stmts = env
      .get_method_id(
        &class,
        "getStmts",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstBlockStmt.getStmts");
    JavaSwc4jAstBlockStmt {
      class,
      method_construct,
      method_get_stmts,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    stmts: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let stmts = object_to_jvalue!(stmts);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[stmts, span],
        "Swc4jAstBlockStmt construct()"
      );
    return_value
  }

  pub fn get_stmts<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_stmts,
        &[],
        "List get_stmts()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBool {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBool {}
unsafe impl Sync for JavaSwc4jAstBool {}

#[allow(dead_code)]
impl JavaSwc4jAstBool {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstBool")
      .expect("Couldn't find class Swc4jAstBool");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBool");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBool::new");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstBool.getValue");
    JavaSwc4jAstBool {
      class,
      method_construct,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let value = boolean_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, span],
        "Swc4jAstBool construct()"
      );
    return_value
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_get_value,
        &[],
        "boolean get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBreakStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_label: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBreakStmt {}
unsafe impl Sync for JavaSwc4jAstBreakStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstBreakStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstBreakStmt")
      .expect("Couldn't find class Swc4jAstBreakStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBreakStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBreakStmt::new");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstBreakStmt.getLabel");
    JavaSwc4jAstBreakStmt {
      class,
      method_construct,
      method_get_label,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let label = optional_object_to_jvalue!(label);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, span],
        "Swc4jAstBreakStmt construct()"
      );
    return_value
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Optional get_label()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstCallExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_args: JMethodID,
  method_get_callee: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstCallExpr {}
unsafe impl Sync for JavaSwc4jAstCallExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstCallExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstCallExpr")
      .expect("Couldn't find class Swc4jAstCallExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstCallExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstCallee;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstCallExpr::new");
    let method_get_args = env
      .get_method_id(
        &class,
        "getArgs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getArgs");
    let method_get_callee = env
      .get_method_id(
        &class,
        "getCallee",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstCallee;",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getCallee");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getTypeArgs");
    JavaSwc4jAstCallExpr {
      class,
      method_construct,
      method_get_args,
      method_get_callee,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    callee: &JObject<'_>,
    args: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let callee = object_to_jvalue!(callee);
    let args = object_to_jvalue!(args);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[callee, args, type_args, span],
        "Swc4jAstCallExpr construct()"
      );
    return_value
  }

  pub fn get_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_args,
        &[],
        "List get_args()"
      );
    return_value
  }

  pub fn get_callee<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_callee,
        &[],
        "ISwc4jAstCallee get_callee()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstCatchClause {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstCatchClause {}
unsafe impl Sync for JavaSwc4jAstCatchClause {}

#[allow(dead_code)]
impl JavaSwc4jAstCatchClause {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstCatchClause")
      .expect("Couldn't find class Swc4jAstCatchClause");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstCatchClause");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstCatchClause::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;",
      )
      .expect("Couldn't find method Swc4jAstCatchClause.getBody");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstCatchClause.getParam");
    JavaSwc4jAstCatchClause {
      class,
      method_construct,
      method_get_body,
      method_get_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    param: &Option<JObject>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let param = optional_object_to_jvalue!(param);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[param, body, span],
        "Swc4jAstCatchClause construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Swc4jAstBlockStmt get_body()"
      );
    return_value
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "Optional get_param()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClass {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_decorators: JMethodID,
  method_get_implements: JMethodID,
  method_get_super_class: JMethodID,
  method_get_super_type_params: JMethodID,
  method_get_type_params: JMethodID,
  method_is_abstract: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClass {}
unsafe impl Sync for JavaSwc4jAstClass {}

#[allow(dead_code)]
impl JavaSwc4jAstClass {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass")
      .expect("Couldn't find class Swc4jAstClass");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClass");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClass::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClass.getBody");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClass.getDecorators");
    let method_get_implements = env
      .get_method_id(
        &class,
        "getImplements",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClass.getImplements");
    let method_get_super_class = env
      .get_method_id(
        &class,
        "getSuperClass",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClass.getSuperClass");
    let method_get_super_type_params = env
      .get_method_id(
        &class,
        "getSuperTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClass.getSuperTypeParams");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClass.getTypeParams");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClass.isAbstract");
    JavaSwc4jAstClass {
      class,
      method_construct,
      method_get_body,
      method_get_decorators,
      method_get_implements,
      method_get_super_class,
      method_get_super_type_params,
      method_get_type_params,
      method_is_abstract,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decorators: &JObject<'_>,
    body: &JObject<'_>,
    super_class: &Option<JObject>,
    is_abstract: bool,
    type_params: &Option<JObject>,
    super_type_params: &Option<JObject>,
    implements: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decorators = object_to_jvalue!(decorators);
    let body = object_to_jvalue!(body);
    let super_class = optional_object_to_jvalue!(super_class);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let type_params = optional_object_to_jvalue!(type_params);
    let super_type_params = optional_object_to_jvalue!(super_type_params);
    let implements = object_to_jvalue!(implements);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decorators, body, super_class, is_abstract, type_params, super_type_params, implements, span],
        "Swc4jAstClass construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_implements<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_implements,
        &[],
        "List get_implements()"
      );
    return_value
  }

  pub fn get_super_class<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_super_class,
        &[],
        "Optional get_super_class()"
      );
    return_value
  }

  pub fn get_super_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_super_type_params,
        &[],
        "Optional get_super_type_params()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_clazz: JMethodID,
  method_get_ident: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassDecl {}
unsafe impl Sync for JavaSwc4jAstClassDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstClassDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstClassDecl")
      .expect("Couldn't find class Swc4jAstClassDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassDecl::new");
    let method_get_clazz = env
      .get_method_id(
        &class,
        "getClazz",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;",
      )
      .expect("Couldn't find method Swc4jAstClassDecl.getClazz");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstClassDecl.getIdent");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassDecl.isDeclare");
    JavaSwc4jAstClassDecl {
      class,
      method_construct,
      method_get_clazz,
      method_get_ident,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &JObject<'_>,
    declare: bool,
    clazz: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ident = object_to_jvalue!(ident);
    let declare = boolean_to_jvalue!(declare);
    let clazz = object_to_jvalue!(clazz);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, declare, clazz, span],
        "Swc4jAstClassDecl construct()"
      );
    return_value
  }

  pub fn get_clazz<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_clazz,
        &[],
        "Swc4jAstClass get_clazz()"
      );
    return_value
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Swc4jAstIdent get_ident()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_clazz: JMethodID,
  method_get_ident: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassExpr {}
unsafe impl Sync for JavaSwc4jAstClassExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstClassExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstClassExpr")
      .expect("Couldn't find class Swc4jAstClassExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassExpr::new");
    let method_get_clazz = env
      .get_method_id(
        &class,
        "getClazz",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;",
      )
      .expect("Couldn't find method Swc4jAstClassExpr.getClazz");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassExpr.getIdent");
    JavaSwc4jAstClassExpr {
      class,
      method_construct,
      method_get_clazz,
      method_get_ident,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &Option<JObject>,
    clazz: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ident = optional_object_to_jvalue!(ident);
    let clazz = object_to_jvalue!(clazz);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, clazz, span],
        "Swc4jAstClassExpr construct()"
      );
    return_value
  }

  pub fn get_clazz<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_clazz,
        &[],
        "Swc4jAstClass get_clazz()"
      );
    return_value
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Optional get_ident()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassMethod {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_function: JMethodID,
  method_get_key: JMethodID,
  method_get_kind: JMethodID,
  method_is_abstract: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassMethod {}
unsafe impl Sync for JavaSwc4jAstClassMethod {}

#[allow(dead_code)]
impl JavaSwc4jAstClassMethod {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstClassMethod")
      .expect("Couldn't find class Swc4jAstClassMethod");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassMethod");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;ZLcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassMethod::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getAccessibility");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getFunction");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getKey");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getKind");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isAbstract");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isOverride");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isStatic");
    JavaSwc4jAstClassMethod {
      class,
      method_construct,
      method_get_accessibility,
      method_get_function,
      method_get_key,
      method_get_kind,
      method_is_abstract,
      method_is_optional,
      method_is_override,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    function: &JObject<'_>,
    kind: &JObject<'_>,
    is_static: bool,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    optional: bool,
    is_override: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let function = object_to_jvalue!(function);
    let kind = object_to_jvalue!(kind);
    let is_static = boolean_to_jvalue!(is_static);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, function, kind, is_static, accessibility, is_abstract, optional, is_override, span],
        "Swc4jAstClassMethod construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstMethodKind get_kind()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_value: JMethodID,
  method_is_abstract: JMethodID,
  method_is_declare: JMethodID,
  method_is_definite: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_readonly: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassProp {}
unsafe impl Sync for JavaSwc4jAstClassProp {}

#[allow(dead_code)]
impl JavaSwc4jAstClassProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstClassProp")
      .expect("Couldn't find class Swc4jAstClassProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassProp::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getDecorators");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getTypeAnn");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getValue");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isAbstract");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isDeclare");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isDefinite");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isOverride");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isReadonly");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isStatic");
    JavaSwc4jAstClassProp {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_key,
      method_get_type_ann,
      method_get_value,
      method_is_abstract,
      method_is_declare,
      method_is_definite,
      method_is_optional,
      method_is_override,
      method_is_readonly,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    type_ann: &Option<JObject>,
    is_static: bool,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    optional: bool,
    is_override: bool,
    readonly: bool,
    declare: bool,
    definite: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let is_static = boolean_to_jvalue!(is_static);
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let readonly = boolean_to_jvalue!(readonly);
    let declare = boolean_to_jvalue!(declare);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, type_ann, is_static, decorators, accessibility, is_abstract, optional, is_override, readonly, declare, definite, span],
        "Swc4jAstClassProp construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstComputedPropName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstComputedPropName {}
unsafe impl Sync for JavaSwc4jAstComputedPropName {}

#[allow(dead_code)]
impl JavaSwc4jAstComputedPropName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstComputedPropName")
      .expect("Couldn't find class Swc4jAstComputedPropName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstComputedPropName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstComputedPropName::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstComputedPropName.getExpr");
    JavaSwc4jAstComputedPropName {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstComputedPropName construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstCondExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_alt: JMethodID,
  method_get_cons: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstCondExpr {}
unsafe impl Sync for JavaSwc4jAstCondExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstCondExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstCondExpr")
      .expect("Couldn't find class Swc4jAstCondExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstCondExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstCondExpr::new");
    let method_get_alt = env
      .get_method_id(
        &class,
        "getAlt",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstCondExpr.getAlt");
    let method_get_cons = env
      .get_method_id(
        &class,
        "getCons",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstCondExpr.getCons");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstCondExpr.getTest");
    JavaSwc4jAstCondExpr {
      class,
      method_construct,
      method_get_alt,
      method_get_cons,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    cons: &JObject<'_>,
    alt: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let cons = object_to_jvalue!(cons);
    let alt = object_to_jvalue!(alt);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, cons, alt, span],
        "Swc4jAstCondExpr construct()"
      );
    return_value
  }

  pub fn get_alt<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_alt,
        &[],
        "ISwc4jAstExpr get_alt()"
      );
    return_value
  }

  pub fn get_cons<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cons,
        &[],
        "ISwc4jAstExpr get_cons()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstConstructor {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_body: JMethodID,
  method_get_key: JMethodID,
  method_get_params: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstConstructor {}
unsafe impl Sync for JavaSwc4jAstConstructor {}

#[allow(dead_code)]
impl JavaSwc4jAstConstructor {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstConstructor")
      .expect("Couldn't find class Swc4jAstConstructor");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstConstructor");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstConstructor::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getAccessibility");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getBody");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getKey");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getParams");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstConstructor.isOptional");
    JavaSwc4jAstConstructor {
      class,
      method_construct,
      method_get_accessibility,
      method_get_body,
      method_get_key,
      method_get_params,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    params: &JObject<'_>,
    body: &Option<JObject>,
    accessibility: &Option<JObject>,
    optional: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let params = object_to_jvalue!(params);
    let body = optional_object_to_jvalue!(body);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let optional = boolean_to_jvalue!(optional);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, params, body, accessibility, optional, span],
        "Swc4jAstConstructor construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstContinueStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_label: JMethodID,
}
unsafe impl Send for JavaSwc4jAstContinueStmt {}
unsafe impl Sync for JavaSwc4jAstContinueStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstContinueStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstContinueStmt")
      .expect("Couldn't find class Swc4jAstContinueStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstContinueStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstContinueStmt::new");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstContinueStmt.getLabel");
    JavaSwc4jAstContinueStmt {
      class,
      method_construct,
      method_get_label,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let label = optional_object_to_jvalue!(label);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, span],
        "Swc4jAstContinueStmt construct()"
      );
    return_value
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Optional get_label()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstDebuggerStmt {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstDebuggerStmt {}
unsafe impl Sync for JavaSwc4jAstDebuggerStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstDebuggerStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstDebuggerStmt")
      .expect("Couldn't find class Swc4jAstDebuggerStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstDebuggerStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstDebuggerStmt::new");
    JavaSwc4jAstDebuggerStmt {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstDebuggerStmt construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstDecorator {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstDecorator {}
unsafe impl Sync for JavaSwc4jAstDecorator {}

#[allow(dead_code)]
impl JavaSwc4jAstDecorator {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstDecorator")
      .expect("Couldn't find class Swc4jAstDecorator");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstDecorator");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstDecorator::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstDecorator.getExpr");
    JavaSwc4jAstDecorator {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstDecorator construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstDoWhileStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstDoWhileStmt {}
unsafe impl Sync for JavaSwc4jAstDoWhileStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstDoWhileStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstDoWhileStmt")
      .expect("Couldn't find class Swc4jAstDoWhileStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstDoWhileStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstDoWhileStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstDoWhileStmt.getBody");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstDoWhileStmt.getTest");
    JavaSwc4jAstDoWhileStmt {
      class,
      method_construct,
      method_get_body,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, body, span],
        "Swc4jAstDoWhileStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstEmptyStmt {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstEmptyStmt {}
unsafe impl Sync for JavaSwc4jAstEmptyStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstEmptyStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstEmptyStmt")
      .expect("Couldn't find class Swc4jAstEmptyStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstEmptyStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstEmptyStmt::new");
    JavaSwc4jAstEmptyStmt {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstEmptyStmt construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportAll {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_src: JMethodID,
  method_get_with: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportAll {}
unsafe impl Sync for JavaSwc4jAstExportAll {}

#[allow(dead_code)]
impl JavaSwc4jAstExportAll {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportAll")
      .expect("Couldn't find class Swc4jAstExportAll");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportAll");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;ZLcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportAll::new");
    let method_get_src = env
      .get_method_id(
        &class,
        "getSrc",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstExportAll.getSrc");
    let method_get_with = env
      .get_method_id(
        &class,
        "getWith",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstExportAll.getWith");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstExportAll.isTypeOnly");
    JavaSwc4jAstExportAll {
      class,
      method_construct,
      method_get_src,
      method_get_with,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    src: &JObject<'_>,
    type_only: bool,
    with: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let src = object_to_jvalue!(src);
    let type_only = boolean_to_jvalue!(type_only);
    let with = optional_object_to_jvalue!(with);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[src, type_only, with, span],
        "Swc4jAstExportAll construct()"
      );
    return_value
  }

  pub fn get_src<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_src,
        &[],
        "Swc4jAstStr get_src()"
      );
    return_value
  }

  pub fn get_with<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_with,
        &[],
        "Optional get_with()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decl: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDecl {}
unsafe impl Sync for JavaSwc4jAstExportDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDecl")
      .expect("Couldn't find class Swc4jAstExportDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDecl::new");
    let method_get_decl = env
      .get_method_id(
        &class,
        "getDecl",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDecl;",
      )
      .expect("Couldn't find method Swc4jAstExportDecl.getDecl");
    JavaSwc4jAstExportDecl {
      class,
      method_construct,
      method_get_decl,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decl: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decl = object_to_jvalue!(decl);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decl, span],
        "Swc4jAstExportDecl construct()"
      );
    return_value
  }

  pub fn get_decl<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decl,
        &[],
        "ISwc4jAstDecl get_decl()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDefaultDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decl: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDefaultDecl {}
unsafe impl Sync for JavaSwc4jAstExportDefaultDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDefaultDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDefaultDecl")
      .expect("Couldn't find class Swc4jAstExportDefaultDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDefaultDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDefaultDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultDecl::new");
    let method_get_decl = env
      .get_method_id(
        &class,
        "getDecl",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDefaultDecl;",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultDecl.getDecl");
    JavaSwc4jAstExportDefaultDecl {
      class,
      method_construct,
      method_get_decl,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decl: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decl = object_to_jvalue!(decl);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decl, span],
        "Swc4jAstExportDefaultDecl construct()"
      );
    return_value
  }

  pub fn get_decl<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decl,
        &[],
        "ISwc4jAstDefaultDecl get_decl()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDefaultExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDefaultExpr {}
unsafe impl Sync for JavaSwc4jAstExportDefaultExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDefaultExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDefaultExpr")
      .expect("Couldn't find class Swc4jAstExportDefaultExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDefaultExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultExpr.getExpr");
    JavaSwc4jAstExportDefaultExpr {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstExportDefaultExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDefaultSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exported: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDefaultSpecifier {}
unsafe impl Sync for JavaSwc4jAstExportDefaultSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDefaultSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDefaultSpecifier")
      .expect("Couldn't find class Swc4jAstExportDefaultSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDefaultSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultSpecifier::new");
    let method_get_exported = env
      .get_method_id(
        &class,
        "getExported",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultSpecifier.getExported");
    JavaSwc4jAstExportDefaultSpecifier {
      class,
      method_construct,
      method_get_exported,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exported: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let exported = object_to_jvalue!(exported);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exported, span],
        "Swc4jAstExportDefaultSpecifier construct()"
      );
    return_value
  }

  pub fn get_exported<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exported,
        &[],
        "Swc4jAstIdent get_exported()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportNamedSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exported: JMethodID,
  method_get_orig: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportNamedSpecifier {}
unsafe impl Sync for JavaSwc4jAstExportNamedSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstExportNamedSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportNamedSpecifier")
      .expect("Couldn't find class Swc4jAstExportNamedSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportNamedSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier::new");
    let method_get_exported = env
      .get_method_id(
        &class,
        "getExported",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier.getExported");
    let method_get_orig = env
      .get_method_id(
        &class,
        "getOrig",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier.getOrig");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier.isTypeOnly");
    JavaSwc4jAstExportNamedSpecifier {
      class,
      method_construct,
      method_get_exported,
      method_get_orig,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    orig: &JObject<'_>,
    exported: &Option<JObject>,
    type_only: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let orig = object_to_jvalue!(orig);
    let exported = optional_object_to_jvalue!(exported);
    let type_only = boolean_to_jvalue!(type_only);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[orig, exported, type_only, span],
        "Swc4jAstExportNamedSpecifier construct()"
      );
    return_value
  }

  pub fn get_exported<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exported,
        &[],
        "Optional get_exported()"
      );
    return_value
  }

  pub fn get_orig<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_orig,
        &[],
        "ISwc4jAstModuleExportName get_orig()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportNamespaceSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportNamespaceSpecifier {}
unsafe impl Sync for JavaSwc4jAstExportNamespaceSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstExportNamespaceSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportNamespaceSpecifier")
      .expect("Couldn't find class Swc4jAstExportNamespaceSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportNamespaceSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportNamespaceSpecifier::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;",
      )
      .expect("Couldn't find method Swc4jAstExportNamespaceSpecifier.getName");
    JavaSwc4jAstExportNamespaceSpecifier {
      class,
      method_construct,
      method_get_name,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, span],
        "Swc4jAstExportNamespaceSpecifier construct()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstModuleExportName get_name()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExprOrSpread {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_spread: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExprOrSpread {}
unsafe impl Sync for JavaSwc4jAstExprOrSpread {}

#[allow(dead_code)]
impl JavaSwc4jAstExprOrSpread {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstExprOrSpread")
      .expect("Couldn't find class Swc4jAstExprOrSpread");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExprOrSpread");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExprOrSpread::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstExprOrSpread.getExpr");
    let method_get_spread = env
      .get_method_id(
        &class,
        "getSpread",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstExprOrSpread.getSpread");
    JavaSwc4jAstExprOrSpread {
      class,
      method_construct,
      method_get_expr,
      method_get_spread,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    spread: &Option<JObject>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let spread = optional_object_to_jvalue!(spread);
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[spread, expr, span],
        "Swc4jAstExprOrSpread construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_spread<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_spread,
        &[],
        "Optional get_spread()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExprStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExprStmt {}
unsafe impl Sync for JavaSwc4jAstExprStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstExprStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstExprStmt")
      .expect("Couldn't find class Swc4jAstExprStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExprStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExprStmt::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstExprStmt.getExpr");
    JavaSwc4jAstExprStmt {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstExprStmt construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstFnDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_function: JMethodID,
  method_get_ident: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstFnDecl {}
unsafe impl Sync for JavaSwc4jAstFnDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstFnDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstFnDecl")
      .expect("Couldn't find class Swc4jAstFnDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstFnDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstFnDecl::new");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstFnDecl.getFunction");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstFnDecl.getIdent");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstFnDecl.isDeclare");
    JavaSwc4jAstFnDecl {
      class,
      method_construct,
      method_get_function,
      method_get_ident,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &JObject<'_>,
    declare: bool,
    function: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ident = object_to_jvalue!(ident);
    let declare = boolean_to_jvalue!(declare);
    let function = object_to_jvalue!(function);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, declare, function, span],
        "Swc4jAstFnDecl construct()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Swc4jAstIdent get_ident()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstFnExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_function: JMethodID,
  method_get_ident: JMethodID,
}
unsafe impl Send for JavaSwc4jAstFnExpr {}
unsafe impl Sync for JavaSwc4jAstFnExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstFnExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstFnExpr")
      .expect("Couldn't find class Swc4jAstFnExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstFnExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstFnExpr::new");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstFnExpr.getFunction");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFnExpr.getIdent");
    JavaSwc4jAstFnExpr {
      class,
      method_construct,
      method_get_function,
      method_get_ident,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &Option<JObject>,
    function: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ident = optional_object_to_jvalue!(ident);
    let function = object_to_jvalue!(function);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, function, span],
        "Swc4jAstFnExpr construct()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Optional get_ident()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstForInStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstForInStmt {}
unsafe impl Sync for JavaSwc4jAstForInStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstForInStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstForInStmt")
      .expect("Couldn't find class Swc4jAstForInStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstForInStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstForInStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstForInStmt.getBody");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;",
      )
      .expect("Couldn't find method Swc4jAstForInStmt.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstForInStmt.getRight");
    JavaSwc4jAstForInStmt {
      class,
      method_construct,
      method_get_body,
      method_get_left,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[left, right, body, span],
        "Swc4jAstForInStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstForHead get_left()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstForOfStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
  method_is_await: JMethodID,
}
unsafe impl Send for JavaSwc4jAstForOfStmt {}
unsafe impl Sync for JavaSwc4jAstForOfStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstForOfStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstForOfStmt")
      .expect("Couldn't find class Swc4jAstForOfStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstForOfStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.getBody");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.getRight");
    let method_is_await = env
      .get_method_id(
        &class,
        "isAwait",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.isAwait");
    JavaSwc4jAstForOfStmt {
      class,
      method_construct,
      method_get_body,
      method_get_left,
      method_get_right,
      method_is_await,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    is_await: bool,
    left: &JObject<'_>,
    right: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let is_await = boolean_to_jvalue!(is_await);
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[is_await, left, right, body, span],
        "Swc4jAstForOfStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstForHead get_left()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      );
    return_value
  }

  pub fn is_await<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_await,
        &[],
        "boolean is_await()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstForStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_init: JMethodID,
  method_get_test: JMethodID,
  method_get_update: JMethodID,
}
unsafe impl Send for JavaSwc4jAstForStmt {}
unsafe impl Sync for JavaSwc4jAstForStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstForStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstForStmt")
      .expect("Couldn't find class Swc4jAstForStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstForStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstVarDeclOrExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstForStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getBody");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getInit");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getTest");
    let method_get_update = env
      .get_method_id(
        &class,
        "getUpdate",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getUpdate");
    JavaSwc4jAstForStmt {
      class,
      method_construct,
      method_get_body,
      method_get_init,
      method_get_test,
      method_get_update,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    init: &Option<JObject>,
    test: &Option<JObject>,
    update: &Option<JObject>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let init = optional_object_to_jvalue!(init);
    let test = optional_object_to_jvalue!(test);
    let update = optional_object_to_jvalue!(update);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[init, test, update, body, span],
        "Swc4jAstForStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "Optional get_test()"
      );
    return_value
  }

  pub fn get_update<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_update,
        &[],
        "Optional get_update()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstFunction {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_decorators: JMethodID,
  method_get_params: JMethodID,
  method_get_return_type: JMethodID,
  method_get_type_params: JMethodID,
  method_is_async: JMethodID,
  method_is_generator: JMethodID,
}
unsafe impl Send for JavaSwc4jAstFunction {}
unsafe impl Sync for JavaSwc4jAstFunction {}

#[allow(dead_code)]
impl JavaSwc4jAstFunction {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction")
      .expect("Couldn't find class Swc4jAstFunction");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstFunction");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;ZZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstFunction::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getBody");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getDecorators");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getParams");
    let method_get_return_type = env
      .get_method_id(
        &class,
        "getReturnType",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getReturnType");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getTypeParams");
    let method_is_async = env
      .get_method_id(
        &class,
        "isAsync",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstFunction.isAsync");
    let method_is_generator = env
      .get_method_id(
        &class,
        "isGenerator",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstFunction.isGenerator");
    JavaSwc4jAstFunction {
      class,
      method_construct,
      method_get_body,
      method_get_decorators,
      method_get_params,
      method_get_return_type,
      method_get_type_params,
      method_is_async,
      method_is_generator,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    decorators: &JObject<'_>,
    body: &Option<JObject>,
    is_generator: bool,
    is_async: bool,
    type_params: &Option<JObject>,
    return_type: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let decorators = object_to_jvalue!(decorators);
    let body = optional_object_to_jvalue!(body);
    let is_generator = boolean_to_jvalue!(is_generator);
    let is_async = boolean_to_jvalue!(is_async);
    let type_params = optional_object_to_jvalue!(type_params);
    let return_type = optional_object_to_jvalue!(return_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, decorators, body, is_generator, is_async, type_params, return_type, span],
        "Swc4jAstFunction construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_return_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_return_type,
        &[],
        "Optional get_return_type()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_async<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_async,
        &[],
        "boolean is_async()"
      );
    return_value
  }

  pub fn is_generator<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_generator,
        &[],
        "boolean is_generator()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstGetterProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstGetterProp {}
unsafe impl Sync for JavaSwc4jAstGetterProp {}

#[allow(dead_code)]
impl JavaSwc4jAstGetterProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstGetterProp")
      .expect("Couldn't find class Swc4jAstGetterProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstGetterProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstGetterProp::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstGetterProp.getBody");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstGetterProp.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstGetterProp.getTypeAnn");
    JavaSwc4jAstGetterProp {
      class,
      method_construct,
      method_get_body,
      method_get_key,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    type_ann: &Option<JObject>,
    body: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let body = optional_object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, type_ann, body, span],
        "Swc4jAstGetterProp construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstIdent {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_sym: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstIdent {}
unsafe impl Sync for JavaSwc4jAstIdent {}

#[allow(dead_code)]
impl JavaSwc4jAstIdent {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent")
      .expect("Couldn't find class Swc4jAstIdent");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstIdent");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstIdent::new");
    let method_get_sym = env
      .get_method_id(
        &class,
        "getSym",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstIdent.getSym");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstIdent.isOptional");
    JavaSwc4jAstIdent {
      class,
      method_construct,
      method_get_sym,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    sym: &str,
    optional: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_sym = string_to_jstring!(env, &sym);
    let sym = object_to_jvalue!(java_sym);
    let optional = boolean_to_jvalue!(optional);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[sym, optional, span],
        "Swc4jAstIdent construct()"
      );
    delete_local_ref!(env, java_sym);
    return_value
  }

  pub fn get_sym<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_sym,
        &[],
        "String get_sym()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstIfStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_alt: JMethodID,
  method_get_cons: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstIfStmt {}
unsafe impl Sync for JavaSwc4jAstIfStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstIfStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstIfStmt")
      .expect("Couldn't find class Swc4jAstIfStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstIfStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstIfStmt::new");
    let method_get_alt = env
      .get_method_id(
        &class,
        "getAlt",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstIfStmt.getAlt");
    let method_get_cons = env
      .get_method_id(
        &class,
        "getCons",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstIfStmt.getCons");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstIfStmt.getTest");
    JavaSwc4jAstIfStmt {
      class,
      method_construct,
      method_get_alt,
      method_get_cons,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    cons: &JObject<'_>,
    alt: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let cons = object_to_jvalue!(cons);
    let alt = optional_object_to_jvalue!(alt);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, cons, alt, span],
        "Swc4jAstIfStmt construct()"
      );
    return_value
  }

  pub fn get_alt<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_alt,
        &[],
        "Optional get_alt()"
      );
    return_value
  }

  pub fn get_cons<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cons,
        &[],
        "ISwc4jAstStmt get_cons()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImport {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_phase: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImport {}
unsafe impl Sync for JavaSwc4jAstImport {}

#[allow(dead_code)]
impl JavaSwc4jAstImport {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImport")
      .expect("Couldn't find class Swc4jAstImport");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImport");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImport::new");
    let method_get_phase = env
      .get_method_id(
        &class,
        "getPhase",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;",
      )
      .expect("Couldn't find method Swc4jAstImport.getPhase");
    JavaSwc4jAstImport {
      class,
      method_construct,
      method_get_phase,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    phase: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let phase = object_to_jvalue!(phase);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[phase, span],
        "Swc4jAstImport construct()"
      );
    return_value
  }

  pub fn get_phase<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_phase,
        &[],
        "Swc4jAstImportPhase get_phase()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_phase: JMethodID,
  method_get_specifiers: JMethodID,
  method_get_src: JMethodID,
  method_get_with: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportDecl {}
unsafe impl Sync for JavaSwc4jAstImportDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstImportDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportDecl")
      .expect("Couldn't find class Swc4jAstImportDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;ZLcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportDecl::new");
    let method_get_phase = env
      .get_method_id(
        &class,
        "getPhase",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getPhase");
    let method_get_specifiers = env
      .get_method_id(
        &class,
        "getSpecifiers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getSpecifiers");
    let method_get_src = env
      .get_method_id(
        &class,
        "getSrc",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getSrc");
    let method_get_with = env
      .get_method_id(
        &class,
        "getWith",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getWith");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.isTypeOnly");
    JavaSwc4jAstImportDecl {
      class,
      method_construct,
      method_get_phase,
      method_get_specifiers,
      method_get_src,
      method_get_with,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    specifiers: &JObject<'_>,
    src: &JObject<'_>,
    type_only: bool,
    with: &Option<JObject>,
    phase: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let specifiers = object_to_jvalue!(specifiers);
    let src = object_to_jvalue!(src);
    let type_only = boolean_to_jvalue!(type_only);
    let with = optional_object_to_jvalue!(with);
    let phase = object_to_jvalue!(phase);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[specifiers, src, type_only, with, phase, span],
        "Swc4jAstImportDecl construct()"
      );
    return_value
  }

  pub fn get_phase<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_phase,
        &[],
        "Swc4jAstImportPhase get_phase()"
      );
    return_value
  }

  pub fn get_specifiers<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_specifiers,
        &[],
        "List get_specifiers()"
      );
    return_value
  }

  pub fn get_src<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_src,
        &[],
        "Swc4jAstStr get_src()"
      );
    return_value
  }

  pub fn get_with<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_with,
        &[],
        "Optional get_with()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportDefaultSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_local: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportDefaultSpecifier {}
unsafe impl Sync for JavaSwc4jAstImportDefaultSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstImportDefaultSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportDefaultSpecifier")
      .expect("Couldn't find class Swc4jAstImportDefaultSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportDefaultSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportDefaultSpecifier::new");
    let method_get_local = env
      .get_method_id(
        &class,
        "getLocal",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstImportDefaultSpecifier.getLocal");
    JavaSwc4jAstImportDefaultSpecifier {
      class,
      method_construct,
      method_get_local,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    local: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let local = object_to_jvalue!(local);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[local, span],
        "Swc4jAstImportDefaultSpecifier construct()"
      );
    return_value
  }

  pub fn get_local<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_local,
        &[],
        "Swc4jAstIdent get_local()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportNamedSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_imported: JMethodID,
  method_get_local: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportNamedSpecifier {}
unsafe impl Sync for JavaSwc4jAstImportNamedSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstImportNamedSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportNamedSpecifier")
      .expect("Couldn't find class Swc4jAstImportNamedSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportNamedSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier::new");
    let method_get_imported = env
      .get_method_id(
        &class,
        "getImported",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier.getImported");
    let method_get_local = env
      .get_method_id(
        &class,
        "getLocal",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier.getLocal");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier.isTypeOnly");
    JavaSwc4jAstImportNamedSpecifier {
      class,
      method_construct,
      method_get_imported,
      method_get_local,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    local: &JObject<'_>,
    imported: &Option<JObject>,
    type_only: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let local = object_to_jvalue!(local);
    let imported = optional_object_to_jvalue!(imported);
    let type_only = boolean_to_jvalue!(type_only);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[local, imported, type_only, span],
        "Swc4jAstImportNamedSpecifier construct()"
      );
    return_value
  }

  pub fn get_imported<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_imported,
        &[],
        "Optional get_imported()"
      );
    return_value
  }

  pub fn get_local<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_local,
        &[],
        "Swc4jAstIdent get_local()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportStarAsSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_local: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportStarAsSpecifier {}
unsafe impl Sync for JavaSwc4jAstImportStarAsSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstImportStarAsSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportStarAsSpecifier")
      .expect("Couldn't find class Swc4jAstImportStarAsSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportStarAsSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportStarAsSpecifier::new");
    let method_get_local = env
      .get_method_id(
        &class,
        "getLocal",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstImportStarAsSpecifier.getLocal");
    JavaSwc4jAstImportStarAsSpecifier {
      class,
      method_construct,
      method_get_local,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    local: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let local = object_to_jvalue!(local);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[local, span],
        "Swc4jAstImportStarAsSpecifier construct()"
      );
    return_value
  }

  pub fn get_local<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_local,
        &[],
        "Swc4jAstIdent get_local()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstInvalid {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstInvalid {}
unsafe impl Sync for JavaSwc4jAstInvalid {}

#[allow(dead_code)]
impl JavaSwc4jAstInvalid {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstInvalid")
      .expect("Couldn't find class Swc4jAstInvalid");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstInvalid");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstInvalid::new");
    JavaSwc4jAstInvalid {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstInvalid construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxAttr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxAttr {}
unsafe impl Sync for JavaSwc4jAstJsxAttr {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxAttr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxAttr")
      .expect("Couldn't find class Swc4jAstJsxAttr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxAttr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrValue;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxAttr::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrName;",
      )
      .expect("Couldn't find method Swc4jAstJsxAttr.getName");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstJsxAttr.getValue");
    JavaSwc4jAstJsxAttr {
      class,
      method_construct,
      method_get_name,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    value: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let value = optional_object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, value, span],
        "Swc4jAstJsxAttr construct()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstJsxAttrName get_name()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxClosingElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxClosingElement {}
unsafe impl Sync for JavaSwc4jAstJsxClosingElement {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxClosingElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingElement")
      .expect("Couldn't find class Swc4jAstJsxClosingElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxClosingElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxClosingElement::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;",
      )
      .expect("Couldn't find method Swc4jAstJsxClosingElement.getName");
    JavaSwc4jAstJsxClosingElement {
      class,
      method_construct,
      method_get_name,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, span],
        "Swc4jAstJsxClosingElement construct()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstJsxElementName get_name()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxClosingFragment {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxClosingFragment {}
unsafe impl Sync for JavaSwc4jAstJsxClosingFragment {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxClosingFragment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingFragment")
      .expect("Couldn't find class Swc4jAstJsxClosingFragment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxClosingFragment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxClosingFragment::new");
    JavaSwc4jAstJsxClosingFragment {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstJsxClosingFragment construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_children: JMethodID,
  method_get_closing: JMethodID,
  method_get_opening: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxElement {}
unsafe impl Sync for JavaSwc4jAstJsxElement {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxElement")
      .expect("Couldn't find class Swc4jAstJsxElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningElement;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingElement;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxElement::new");
    let method_get_children = env
      .get_method_id(
        &class,
        "getChildren",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstJsxElement.getChildren");
    let method_get_closing = env
      .get_method_id(
        &class,
        "getClosing",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstJsxElement.getClosing");
    let method_get_opening = env
      .get_method_id(
        &class,
        "getOpening",
        "()Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningElement;",
      )
      .expect("Couldn't find method Swc4jAstJsxElement.getOpening");
    JavaSwc4jAstJsxElement {
      class,
      method_construct,
      method_get_children,
      method_get_closing,
      method_get_opening,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    opening: &JObject<'_>,
    children: &JObject<'_>,
    closing: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let opening = object_to_jvalue!(opening);
    let children = object_to_jvalue!(children);
    let closing = optional_object_to_jvalue!(closing);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[opening, children, closing, span],
        "Swc4jAstJsxElement construct()"
      );
    return_value
  }

  pub fn get_children<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_children,
        &[],
        "List get_children()"
      );
    return_value
  }

  pub fn get_closing<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_closing,
        &[],
        "Optional get_closing()"
      );
    return_value
  }

  pub fn get_opening<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_opening,
        &[],
        "Swc4jAstJsxOpeningElement get_opening()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxEmptyExpr {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxEmptyExpr {}
unsafe impl Sync for JavaSwc4jAstJsxEmptyExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxEmptyExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxEmptyExpr")
      .expect("Couldn't find class Swc4jAstJsxEmptyExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxEmptyExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxEmptyExpr::new");
    JavaSwc4jAstJsxEmptyExpr {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstJsxEmptyExpr construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxExprContainer {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxExprContainer {}
unsafe impl Sync for JavaSwc4jAstJsxExprContainer {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxExprContainer {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxExprContainer")
      .expect("Couldn't find class Swc4jAstJsxExprContainer");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxExprContainer");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxExprContainer::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxExpr;",
      )
      .expect("Couldn't find method Swc4jAstJsxExprContainer.getExpr");
    JavaSwc4jAstJsxExprContainer {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstJsxExprContainer construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstJsxExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxFragment {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_children: JMethodID,
  method_get_closing: JMethodID,
  method_get_opening: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxFragment {}
unsafe impl Sync for JavaSwc4jAstJsxFragment {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxFragment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxFragment")
      .expect("Couldn't find class Swc4jAstJsxFragment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxFragment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningFragment;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingFragment;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment::new");
    let method_get_children = env
      .get_method_id(
        &class,
        "getChildren",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment.getChildren");
    let method_get_closing = env
      .get_method_id(
        &class,
        "getClosing",
        "()Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingFragment;",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment.getClosing");
    let method_get_opening = env
      .get_method_id(
        &class,
        "getOpening",
        "()Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningFragment;",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment.getOpening");
    JavaSwc4jAstJsxFragment {
      class,
      method_construct,
      method_get_children,
      method_get_closing,
      method_get_opening,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    opening: &JObject<'_>,
    children: &JObject<'_>,
    closing: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let opening = object_to_jvalue!(opening);
    let children = object_to_jvalue!(children);
    let closing = object_to_jvalue!(closing);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[opening, children, closing, span],
        "Swc4jAstJsxFragment construct()"
      );
    return_value
  }

  pub fn get_children<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_children,
        &[],
        "List get_children()"
      );
    return_value
  }

  pub fn get_closing<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_closing,
        &[],
        "Swc4jAstJsxClosingFragment get_closing()"
      );
    return_value
  }

  pub fn get_opening<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_opening,
        &[],
        "Swc4jAstJsxOpeningFragment get_opening()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxMemberExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_obj: JMethodID,
  method_get_prop: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxMemberExpr {}
unsafe impl Sync for JavaSwc4jAstJsxMemberExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxMemberExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxMemberExpr")
      .expect("Couldn't find class Swc4jAstJsxMemberExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxMemberExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxObject;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxMemberExpr::new");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxObject;",
      )
      .expect("Couldn't find method Swc4jAstJsxMemberExpr.getObj");
    let method_get_prop = env
      .get_method_id(
        &class,
        "getProp",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstJsxMemberExpr.getProp");
    JavaSwc4jAstJsxMemberExpr {
      class,
      method_construct,
      method_get_obj,
      method_get_prop,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    prop: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let prop = object_to_jvalue!(prop);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, prop, span],
        "Swc4jAstJsxMemberExpr construct()"
      );
    return_value
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "ISwc4jAstJsxObject get_obj()"
      );
    return_value
  }

  pub fn get_prop<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_prop,
        &[],
        "Swc4jAstIdent get_prop()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxNamespacedName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
  method_get_ns: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxNamespacedName {}
unsafe impl Sync for JavaSwc4jAstJsxNamespacedName {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxNamespacedName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxNamespacedName")
      .expect("Couldn't find class Swc4jAstJsxNamespacedName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxNamespacedName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxNamespacedName::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstJsxNamespacedName.getName");
    let method_get_ns = env
      .get_method_id(
        &class,
        "getNs",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstJsxNamespacedName.getNs");
    JavaSwc4jAstJsxNamespacedName {
      class,
      method_construct,
      method_get_name,
      method_get_ns,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ns: &JObject<'_>,
    name: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let ns = object_to_jvalue!(ns);
    let name = object_to_jvalue!(name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ns, name, span],
        "Swc4jAstJsxNamespacedName construct()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "Swc4jAstIdent get_name()"
      );
    return_value
  }

  pub fn get_ns<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ns,
        &[],
        "Swc4jAstIdent get_ns()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxOpeningElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_attrs: JMethodID,
  method_get_name: JMethodID,
  method_get_type_args: JMethodID,
  method_is_self_closing: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxOpeningElement {}
unsafe impl Sync for JavaSwc4jAstJsxOpeningElement {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxOpeningElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningElement")
      .expect("Couldn't find class Swc4jAstJsxOpeningElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxOpeningElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;Ljava/util/List;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement::new");
    let method_get_attrs = env
      .get_method_id(
        &class,
        "getAttrs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.getAttrs");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.getName");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.getTypeArgs");
    let method_is_self_closing = env
      .get_method_id(
        &class,
        "isSelfClosing",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.isSelfClosing");
    JavaSwc4jAstJsxOpeningElement {
      class,
      method_construct,
      method_get_attrs,
      method_get_name,
      method_get_type_args,
      method_is_self_closing,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    attrs: &JObject<'_>,
    self_closing: bool,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let attrs = object_to_jvalue!(attrs);
    let self_closing = boolean_to_jvalue!(self_closing);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, attrs, self_closing, type_args, span],
        "Swc4jAstJsxOpeningElement construct()"
      );
    return_value
  }

  pub fn get_attrs<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_attrs,
        &[],
        "List get_attrs()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstJsxElementName get_name()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }

  pub fn is_self_closing<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_self_closing,
        &[],
        "boolean is_self_closing()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxOpeningFragment {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxOpeningFragment {}
unsafe impl Sync for JavaSwc4jAstJsxOpeningFragment {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxOpeningFragment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningFragment")
      .expect("Couldn't find class Swc4jAstJsxOpeningFragment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxOpeningFragment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningFragment::new");
    JavaSwc4jAstJsxOpeningFragment {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstJsxOpeningFragment construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxSpreadChild {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxSpreadChild {}
unsafe impl Sync for JavaSwc4jAstJsxSpreadChild {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxSpreadChild {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxSpreadChild")
      .expect("Couldn't find class Swc4jAstJsxSpreadChild");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxSpreadChild");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxSpreadChild::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstJsxSpreadChild.getExpr");
    JavaSwc4jAstJsxSpreadChild {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstJsxSpreadChild construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxText {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxText {}
unsafe impl Sync for JavaSwc4jAstJsxText {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxText {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstJsxText")
      .expect("Couldn't find class Swc4jAstJsxText");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxText");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxText::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstJsxText.getRaw");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstJsxText.getValue");
    JavaSwc4jAstJsxText {
      class,
      method_construct,
      method_get_raw,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: &str,
    raw: &str,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_value = string_to_jstring!(env, &value);
    let value = object_to_jvalue!(java_value);
    let java_raw = string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, raw, span],
        "Swc4jAstJsxText construct()"
      );
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_raw<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "String get_raw()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "String get_value()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstKeyValuePatProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstKeyValuePatProp {}
unsafe impl Sync for JavaSwc4jAstKeyValuePatProp {}

#[allow(dead_code)]
impl JavaSwc4jAstKeyValuePatProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstKeyValuePatProp")
      .expect("Couldn't find class Swc4jAstKeyValuePatProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstKeyValuePatProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstKeyValuePatProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstKeyValuePatProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstKeyValuePatProp.getValue");
    JavaSwc4jAstKeyValuePatProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstKeyValuePatProp construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "ISwc4jAstPat get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstKeyValueProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstKeyValueProp {}
unsafe impl Sync for JavaSwc4jAstKeyValueProp {}

#[allow(dead_code)]
impl JavaSwc4jAstKeyValueProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstKeyValueProp")
      .expect("Couldn't find class Swc4jAstKeyValueProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstKeyValueProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstKeyValueProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstKeyValueProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstKeyValueProp.getValue");
    JavaSwc4jAstKeyValueProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstKeyValueProp construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "ISwc4jAstExpr get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstLabeledStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_label: JMethodID,
}
unsafe impl Send for JavaSwc4jAstLabeledStmt {}
unsafe impl Sync for JavaSwc4jAstLabeledStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstLabeledStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstLabeledStmt")
      .expect("Couldn't find class Swc4jAstLabeledStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstLabeledStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstLabeledStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstLabeledStmt.getBody");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstLabeledStmt.getLabel");
    JavaSwc4jAstLabeledStmt {
      class,
      method_construct,
      method_get_body,
      method_get_label,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let label = object_to_jvalue!(label);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, body, span],
        "Swc4jAstLabeledStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Swc4jAstIdent get_label()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstMemberExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_obj: JMethodID,
  method_get_prop: JMethodID,
}
unsafe impl Send for JavaSwc4jAstMemberExpr {}
unsafe impl Sync for JavaSwc4jAstMemberExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstMemberExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstMemberExpr")
      .expect("Couldn't find class Swc4jAstMemberExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstMemberExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstMemberProp;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstMemberExpr::new");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstMemberExpr.getObj");
    let method_get_prop = env
      .get_method_id(
        &class,
        "getProp",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstMemberProp;",
      )
      .expect("Couldn't find method Swc4jAstMemberExpr.getProp");
    JavaSwc4jAstMemberExpr {
      class,
      method_construct,
      method_get_obj,
      method_get_prop,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    prop: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let prop = object_to_jvalue!(prop);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, prop, span],
        "Swc4jAstMemberExpr construct()"
      );
    return_value
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "ISwc4jAstExpr get_obj()"
      );
    return_value
  }

  pub fn get_prop<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_prop,
        &[],
        "ISwc4jAstMemberProp get_prop()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstMetaPropExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_kind: JMethodID,
}
unsafe impl Send for JavaSwc4jAstMetaPropExpr {}
unsafe impl Sync for JavaSwc4jAstMetaPropExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstMetaPropExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstMetaPropExpr")
      .expect("Couldn't find class Swc4jAstMetaPropExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstMetaPropExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMetaPropKind;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstMetaPropExpr::new");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMetaPropKind;",
      )
      .expect("Couldn't find method Swc4jAstMetaPropExpr.getKind");
    JavaSwc4jAstMetaPropExpr {
      class,
      method_construct,
      method_get_kind,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    kind: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let kind = object_to_jvalue!(kind);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[kind, span],
        "Swc4jAstMetaPropExpr construct()"
      );
    return_value
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstMetaPropKind get_kind()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstMethodProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_function: JMethodID,
  method_get_key: JMethodID,
}
unsafe impl Send for JavaSwc4jAstMethodProp {}
unsafe impl Sync for JavaSwc4jAstMethodProp {}

#[allow(dead_code)]
impl JavaSwc4jAstMethodProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstMethodProp")
      .expect("Couldn't find class Swc4jAstMethodProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstMethodProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstMethodProp::new");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstMethodProp.getFunction");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstMethodProp.getKey");
    JavaSwc4jAstMethodProp {
      class,
      method_construct,
      method_get_function,
      method_get_key,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    function: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let function = object_to_jvalue!(function);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, function, span],
        "Swc4jAstMethodProp construct()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstModule {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_shebang: JMethodID,
}
unsafe impl Send for JavaSwc4jAstModule {}
unsafe impl Sync for JavaSwc4jAstModule {}

#[allow(dead_code)]
impl JavaSwc4jAstModule {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/program/Swc4jAstModule")
      .expect("Couldn't find class Swc4jAstModule");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstModule");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstModule::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstModule.getBody");
    let method_get_shebang = env
      .get_method_id(
        &class,
        "getShebang",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstModule.getShebang");
    JavaSwc4jAstModule {
      class,
      method_construct,
      method_get_body,
      method_get_shebang,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    shebang: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let java_shebang = optional_string_to_jstring!(env, &shebang);
    let shebang = object_to_jvalue!(java_shebang);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, shebang, span],
        "Swc4jAstModule construct()"
      );
    delete_local_ref!(env, java_shebang);
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }

  pub fn get_shebang<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_shebang,
        &[],
        "Optional get_shebang()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNamedExport {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_specifiers: JMethodID,
  method_get_src: JMethodID,
  method_get_with: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNamedExport {}
unsafe impl Sync for JavaSwc4jAstNamedExport {}

#[allow(dead_code)]
impl JavaSwc4jAstNamedExport {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstNamedExport")
      .expect("Couldn't find class Swc4jAstNamedExport");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNamedExport");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;ZLcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNamedExport::new");
    let method_get_specifiers = env
      .get_method_id(
        &class,
        "getSpecifiers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.getSpecifiers");
    let method_get_src = env
      .get_method_id(
        &class,
        "getSrc",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.getSrc");
    let method_get_with = env
      .get_method_id(
        &class,
        "getWith",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.getWith");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.isTypeOnly");
    JavaSwc4jAstNamedExport {
      class,
      method_construct,
      method_get_specifiers,
      method_get_src,
      method_get_with,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    specifiers: &JObject<'_>,
    src: &Option<JObject>,
    type_only: bool,
    with: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let specifiers = object_to_jvalue!(specifiers);
    let src = optional_object_to_jvalue!(src);
    let type_only = boolean_to_jvalue!(type_only);
    let with = optional_object_to_jvalue!(with);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[specifiers, src, type_only, with, span],
        "Swc4jAstNamedExport construct()"
      );
    return_value
  }

  pub fn get_specifiers<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_specifiers,
        &[],
        "List get_specifiers()"
      );
    return_value
  }

  pub fn get_src<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_src,
        &[],
        "Optional get_src()"
      );
    return_value
  }

  pub fn get_with<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_with,
        &[],
        "Optional get_with()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNewExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_args: JMethodID,
  method_get_callee: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNewExpr {}
unsafe impl Sync for JavaSwc4jAstNewExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstNewExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstNewExpr")
      .expect("Couldn't find class Swc4jAstNewExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNewExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNewExpr::new");
    let method_get_args = env
      .get_method_id(
        &class,
        "getArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getArgs");
    let method_get_callee = env
      .get_method_id(
        &class,
        "getCallee",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getCallee");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getTypeArgs");
    JavaSwc4jAstNewExpr {
      class,
      method_construct,
      method_get_args,
      method_get_callee,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    callee: &JObject<'_>,
    args: &Option<JObject>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let callee = object_to_jvalue!(callee);
    let args = optional_object_to_jvalue!(args);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[callee, args, type_args, span],
        "Swc4jAstNewExpr construct()"
      );
    return_value
  }

  pub fn get_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_args,
        &[],
        "Optional get_args()"
      );
    return_value
  }

  pub fn get_callee<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_callee,
        &[],
        "ISwc4jAstExpr get_callee()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNull {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNull {}
unsafe impl Sync for JavaSwc4jAstNull {}

#[allow(dead_code)]
impl JavaSwc4jAstNull {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstNull")
      .expect("Couldn't find class Swc4jAstNull");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNull");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNull::new");
    JavaSwc4jAstNull {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstNull construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNumber {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNumber {}
unsafe impl Sync for JavaSwc4jAstNumber {}

#[allow(dead_code)]
impl JavaSwc4jAstNumber {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstNumber")
      .expect("Couldn't find class Swc4jAstNumber");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNumber");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(DLjava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNumber::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNumber.getRaw");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()D",
      )
      .expect("Couldn't find method Swc4jAstNumber.getValue");
    JavaSwc4jAstNumber {
      class,
      method_construct,
      method_get_raw,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: f64,
    raw: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let value = double_to_jvalue!(value);
    let java_raw = optional_string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, raw, span],
        "Swc4jAstNumber construct()"
      );
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_raw<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "Optional get_raw()"
      );
    return_value
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> f64
  {
    let return_value = call_as_double!(
        env,
        obj,
        self.method_get_value,
        &[],
        "double get_value()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstObjectLit {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_props: JMethodID,
}
unsafe impl Send for JavaSwc4jAstObjectLit {}
unsafe impl Sync for JavaSwc4jAstObjectLit {}

#[allow(dead_code)]
impl JavaSwc4jAstObjectLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit")
      .expect("Couldn't find class Swc4jAstObjectLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstObjectLit");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstObjectLit::new");
    let method_get_props = env
      .get_method_id(
        &class,
        "getProps",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstObjectLit.getProps");
    JavaSwc4jAstObjectLit {
      class,
      method_construct,
      method_get_props,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    props: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let props = object_to_jvalue!(props);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[props, span],
        "Swc4jAstObjectLit construct()"
      );
    return_value
  }

  pub fn get_props<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_props,
        &[],
        "List get_props()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstObjectPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_props: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstObjectPat {}
unsafe impl Sync for JavaSwc4jAstObjectPat {}

#[allow(dead_code)]
impl JavaSwc4jAstObjectPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstObjectPat")
      .expect("Couldn't find class Swc4jAstObjectPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstObjectPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstObjectPat::new");
    let method_get_props = env
      .get_method_id(
        &class,
        "getProps",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstObjectPat.getProps");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstObjectPat.getTypeAnn");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstObjectPat.isOptional");
    JavaSwc4jAstObjectPat {
      class,
      method_construct,
      method_get_props,
      method_get_type_ann,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    props: &JObject<'_>,
    optional: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let props = object_to_jvalue!(props);
    let optional = boolean_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[props, optional, type_ann, span],
        "Swc4jAstObjectPat construct()"
      );
    return_value
  }

  pub fn get_props<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_props,
        &[],
        "List get_props()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstOptCall {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_args: JMethodID,
  method_get_callee: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstOptCall {}
unsafe impl Sync for JavaSwc4jAstOptCall {}

#[allow(dead_code)]
impl JavaSwc4jAstOptCall {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstOptCall")
      .expect("Couldn't find class Swc4jAstOptCall");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstOptCall");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstOptCall::new");
    let method_get_args = env
      .get_method_id(
        &class,
        "getArgs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getArgs");
    let method_get_callee = env
      .get_method_id(
        &class,
        "getCallee",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getCallee");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getTypeArgs");
    JavaSwc4jAstOptCall {
      class,
      method_construct,
      method_get_args,
      method_get_callee,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    callee: &JObject<'_>,
    args: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let callee = object_to_jvalue!(callee);
    let args = object_to_jvalue!(args);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[callee, args, type_args, span],
        "Swc4jAstOptCall construct()"
      );
    return_value
  }

  pub fn get_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_args,
        &[],
        "List get_args()"
      );
    return_value
  }

  pub fn get_callee<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_callee,
        &[],
        "ISwc4jAstExpr get_callee()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstOptChainExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_base: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstOptChainExpr {}
unsafe impl Sync for JavaSwc4jAstOptChainExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstOptChainExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstOptChainExpr")
      .expect("Couldn't find class Swc4jAstOptChainExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstOptChainExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstOptChainBase;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstOptChainExpr::new");
    let method_get_base = env
      .get_method_id(
        &class,
        "getBase",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstOptChainBase;",
      )
      .expect("Couldn't find method Swc4jAstOptChainExpr.getBase");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstOptChainExpr.isOptional");
    JavaSwc4jAstOptChainExpr {
      class,
      method_construct,
      method_get_base,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    optional: bool,
    base: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let optional = boolean_to_jvalue!(optional);
    let base = object_to_jvalue!(base);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[optional, base, span],
        "Swc4jAstOptChainExpr construct()"
      );
    return_value
  }

  pub fn get_base<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_base,
        &[],
        "ISwc4jAstOptChainBase get_base()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstParam {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decorators: JMethodID,
  method_get_pat: JMethodID,
}
unsafe impl Send for JavaSwc4jAstParam {}
unsafe impl Sync for JavaSwc4jAstParam {}

#[allow(dead_code)]
impl JavaSwc4jAstParam {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstParam")
      .expect("Couldn't find class Swc4jAstParam");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstParam");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstParam::new");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstParam.getDecorators");
    let method_get_pat = env
      .get_method_id(
        &class,
        "getPat",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstParam.getPat");
    JavaSwc4jAstParam {
      class,
      method_construct,
      method_get_decorators,
      method_get_pat,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decorators: &JObject<'_>,
    pat: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decorators = object_to_jvalue!(decorators);
    let pat = object_to_jvalue!(pat);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decorators, pat, span],
        "Swc4jAstParam construct()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_pat<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_pat,
        &[],
        "ISwc4jAstPat get_pat()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstParenExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstParenExpr {}
unsafe impl Sync for JavaSwc4jAstParenExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstParenExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstParenExpr")
      .expect("Couldn't find class Swc4jAstParenExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstParenExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstParenExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstParenExpr.getExpr");
    JavaSwc4jAstParenExpr {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstParenExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstPrivateMethod {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_function: JMethodID,
  method_get_key: JMethodID,
  method_get_kind: JMethodID,
  method_is_abstract: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstPrivateMethod {}
unsafe impl Sync for JavaSwc4jAstPrivateMethod {}

#[allow(dead_code)]
impl JavaSwc4jAstPrivateMethod {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateMethod")
      .expect("Couldn't find class Swc4jAstPrivateMethod");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstPrivateMethod");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;ZLcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getAccessibility");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getFunction");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getKey");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getKind");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isAbstract");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isOverride");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isStatic");
    JavaSwc4jAstPrivateMethod {
      class,
      method_construct,
      method_get_accessibility,
      method_get_function,
      method_get_key,
      method_get_kind,
      method_is_abstract,
      method_is_optional,
      method_is_override,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    function: &JObject<'_>,
    kind: &JObject<'_>,
    is_static: bool,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    optional: bool,
    is_override: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let function = object_to_jvalue!(function);
    let kind = object_to_jvalue!(kind);
    let is_static = boolean_to_jvalue!(is_static);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, function, kind, is_static, accessibility, is_abstract, optional, is_override, span],
        "Swc4jAstPrivateMethod construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstPrivateName get_key()"
      );
    return_value
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstMethodKind get_kind()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstPrivateName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
}
unsafe impl Send for JavaSwc4jAstPrivateName {}
unsafe impl Sync for JavaSwc4jAstPrivateName {}

#[allow(dead_code)]
impl JavaSwc4jAstPrivateName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName")
      .expect("Couldn't find class Swc4jAstPrivateName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstPrivateName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstPrivateName::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstPrivateName.getId");
    JavaSwc4jAstPrivateName {
      class,
      method_construct,
      method_get_id,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, span],
        "Swc4jAstPrivateName construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstPrivateProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_value: JMethodID,
  method_is_definite: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_readonly: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstPrivateProp {}
unsafe impl Sync for JavaSwc4jAstPrivateProp {}

#[allow(dead_code)]
impl JavaSwc4jAstPrivateProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateProp")
      .expect("Couldn't find class Swc4jAstPrivateProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstPrivateProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getDecorators");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getTypeAnn");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getValue");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isDefinite");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isOverride");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isReadonly");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isStatic");
    JavaSwc4jAstPrivateProp {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_key,
      method_get_type_ann,
      method_get_value,
      method_is_definite,
      method_is_optional,
      method_is_override,
      method_is_readonly,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    type_ann: &Option<JObject>,
    is_static: bool,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    optional: bool,
    is_override: bool,
    readonly: bool,
    definite: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let is_static = boolean_to_jvalue!(is_static);
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let readonly = boolean_to_jvalue!(readonly);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, type_ann, is_static, decorators, accessibility, optional, is_override, readonly, definite, span],
        "Swc4jAstPrivateProp construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstPrivateName get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      );
    return_value
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstRegex {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exp: JMethodID,
  method_get_flags: JMethodID,
}
unsafe impl Send for JavaSwc4jAstRegex {}
unsafe impl Sync for JavaSwc4jAstRegex {}

#[allow(dead_code)]
impl JavaSwc4jAstRegex {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstRegex")
      .expect("Couldn't find class Swc4jAstRegex");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstRegex");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstRegex::new");
    let method_get_exp = env
      .get_method_id(
        &class,
        "getExp",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstRegex.getExp");
    let method_get_flags = env
      .get_method_id(
        &class,
        "getFlags",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstRegex.getFlags");
    JavaSwc4jAstRegex {
      class,
      method_construct,
      method_get_exp,
      method_get_flags,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exp: &str,
    flags: &str,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_exp = string_to_jstring!(env, &exp);
    let exp = object_to_jvalue!(java_exp);
    let java_flags = string_to_jstring!(env, &flags);
    let flags = object_to_jvalue!(java_flags);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exp, flags, span],
        "Swc4jAstRegex construct()"
      );
    delete_local_ref!(env, java_exp);
    delete_local_ref!(env, java_flags);
    return_value
  }

  pub fn get_exp<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exp,
        &[],
        "String get_exp()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }

  pub fn get_flags<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_flags,
        &[],
        "String get_flags()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstRestPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_dot3_token: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstRestPat {}
unsafe impl Sync for JavaSwc4jAstRestPat {}

#[allow(dead_code)]
impl JavaSwc4jAstRestPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstRestPat")
      .expect("Couldn't find class Swc4jAstRestPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstRestPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstRestPat::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstRestPat.getArg");
    let method_get_dot3_token = env
      .get_method_id(
        &class,
        "getDot3Token",
        "()Lcom/caoccao/javet/swc4j/span/Swc4jSpan;",
      )
      .expect("Couldn't find method Swc4jAstRestPat.getDot3Token");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstRestPat.getTypeAnn");
    JavaSwc4jAstRestPat {
      class,
      method_construct,
      method_get_arg,
      method_get_dot3_token,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    dot3_token: &JObject<'_>,
    arg: &JObject<'_>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let dot3_token = object_to_jvalue!(dot3_token);
    let arg = object_to_jvalue!(arg);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[dot3_token, arg, type_ann, span],
        "Swc4jAstRestPat construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstPat get_arg()"
      );
    return_value
  }

  pub fn get_dot3_token<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_dot3_token,
        &[],
        "Swc4jSpan get_dot3_token()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstReturnStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
}
unsafe impl Send for JavaSwc4jAstReturnStmt {}
unsafe impl Sync for JavaSwc4jAstReturnStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstReturnStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstReturnStmt")
      .expect("Couldn't find class Swc4jAstReturnStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstReturnStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstReturnStmt::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstReturnStmt.getArg");
    JavaSwc4jAstReturnStmt {
      class,
      method_construct,
      method_get_arg,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = optional_object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, span],
        "Swc4jAstReturnStmt construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "Optional get_arg()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstScript {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_shebang: JMethodID,
}
unsafe impl Send for JavaSwc4jAstScript {}
unsafe impl Sync for JavaSwc4jAstScript {}

#[allow(dead_code)]
impl JavaSwc4jAstScript {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/program/Swc4jAstScript")
      .expect("Couldn't find class Swc4jAstScript");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstScript");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstScript::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstScript.getBody");
    let method_get_shebang = env
      .get_method_id(
        &class,
        "getShebang",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstScript.getShebang");
    JavaSwc4jAstScript {
      class,
      method_construct,
      method_get_body,
      method_get_shebang,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    shebang: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let java_shebang = optional_string_to_jstring!(env, &shebang);
    let shebang = object_to_jvalue!(java_shebang);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, shebang, span],
        "Swc4jAstScript construct()"
      );
    delete_local_ref!(env, java_shebang);
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }

  pub fn get_shebang<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_shebang,
        &[],
        "Optional get_shebang()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSeqExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exprs: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSeqExpr {}
unsafe impl Sync for JavaSwc4jAstSeqExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstSeqExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstSeqExpr")
      .expect("Couldn't find class Swc4jAstSeqExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSeqExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSeqExpr::new");
    let method_get_exprs = env
      .get_method_id(
        &class,
        "getExprs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstSeqExpr.getExprs");
    JavaSwc4jAstSeqExpr {
      class,
      method_construct,
      method_get_exprs,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exprs: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let exprs = object_to_jvalue!(exprs);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exprs, span],
        "Swc4jAstSeqExpr construct()"
      );
    return_value
  }

  pub fn get_exprs<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exprs,
        &[],
        "List get_exprs()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSetterProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_key: JMethodID,
  method_get_param: JMethodID,
  method_get_this_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSetterProp {}
unsafe impl Sync for JavaSwc4jAstSetterProp {}

#[allow(dead_code)]
impl JavaSwc4jAstSetterProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstSetterProp")
      .expect("Couldn't find class Swc4jAstSetterProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSetterProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSetterProp::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getBody");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getKey");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getParam");
    let method_get_this_param = env
      .get_method_id(
        &class,
        "getThisParam",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getThisParam");
    JavaSwc4jAstSetterProp {
      class,
      method_construct,
      method_get_body,
      method_get_key,
      method_get_param,
      method_get_this_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    this_param: &Option<JObject>,
    param: &JObject<'_>,
    body: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let this_param = optional_object_to_jvalue!(this_param);
    let param = object_to_jvalue!(param);
    let body = optional_object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, this_param, param, body, span],
        "Swc4jAstSetterProp construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      );
    return_value
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "ISwc4jAstPat get_param()"
      );
    return_value
  }

  pub fn get_this_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_this_param,
        &[],
        "Optional get_this_param()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSpreadElement {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSpreadElement {}
unsafe impl Sync for JavaSwc4jAstSpreadElement {}

#[allow(dead_code)]
impl JavaSwc4jAstSpreadElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstSpreadElement")
      .expect("Couldn't find class Swc4jAstSpreadElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSpreadElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSpreadElement::new");
    JavaSwc4jAstSpreadElement {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    dot3_token: &JObject<'_>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let dot3_token = object_to_jvalue!(dot3_token);
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[dot3_token, expr, span],
        "Swc4jAstSpreadElement construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstStaticBlock {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
}
unsafe impl Send for JavaSwc4jAstStaticBlock {}
unsafe impl Sync for JavaSwc4jAstStaticBlock {}

#[allow(dead_code)]
impl JavaSwc4jAstStaticBlock {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstStaticBlock")
      .expect("Couldn't find class Swc4jAstStaticBlock");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstStaticBlock");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstStaticBlock::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;",
      )
      .expect("Couldn't find method Swc4jAstStaticBlock.getBody");
    JavaSwc4jAstStaticBlock {
      class,
      method_construct,
      method_get_body,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, span],
        "Swc4jAstStaticBlock construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Swc4jAstBlockStmt get_body()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstStr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstStr {}
unsafe impl Sync for JavaSwc4jAstStr {}

#[allow(dead_code)]
impl JavaSwc4jAstStr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr")
      .expect("Couldn't find class Swc4jAstStr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstStr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstStr::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstStr.getRaw");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstStr.getValue");
    JavaSwc4jAstStr {
      class,
      method_construct,
      method_get_raw,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: &str,
    raw: &Option<String>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let java_value = string_to_jstring!(env, &value);
    let value = object_to_jvalue!(java_value);
    let java_raw = optional_string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, raw, span],
        "Swc4jAstStr construct()"
      );
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_raw<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "Optional get_raw()"
      );
    return_value
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "String get_value()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSuper {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSuper {}
unsafe impl Sync for JavaSwc4jAstSuper {}

#[allow(dead_code)]
impl JavaSwc4jAstSuper {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstSuper")
      .expect("Couldn't find class Swc4jAstSuper");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSuper");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSuper::new");
    JavaSwc4jAstSuper {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstSuper construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSuperPropExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_obj: JMethodID,
  method_get_prop: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSuperPropExpr {}
unsafe impl Sync for JavaSwc4jAstSuperPropExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstSuperPropExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstSuperPropExpr")
      .expect("Couldn't find class Swc4jAstSuperPropExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSuperPropExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstSuper;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstSuperProp;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSuperPropExpr::new");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstSuper;",
      )
      .expect("Couldn't find method Swc4jAstSuperPropExpr.getObj");
    let method_get_prop = env
      .get_method_id(
        &class,
        "getProp",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstSuperProp;",
      )
      .expect("Couldn't find method Swc4jAstSuperPropExpr.getProp");
    JavaSwc4jAstSuperPropExpr {
      class,
      method_construct,
      method_get_obj,
      method_get_prop,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    prop: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let prop = object_to_jvalue!(prop);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, prop, span],
        "Swc4jAstSuperPropExpr construct()"
      );
    return_value
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "Swc4jAstSuper get_obj()"
      );
    return_value
  }

  pub fn get_prop<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_prop,
        &[],
        "ISwc4jAstSuperProp get_prop()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSwitchCase {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_cons: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSwitchCase {}
unsafe impl Sync for JavaSwc4jAstSwitchCase {}

#[allow(dead_code)]
impl JavaSwc4jAstSwitchCase {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstSwitchCase")
      .expect("Couldn't find class Swc4jAstSwitchCase");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSwitchCase");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSwitchCase::new");
    let method_get_cons = env
      .get_method_id(
        &class,
        "getCons",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstSwitchCase.getCons");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstSwitchCase.getTest");
    JavaSwc4jAstSwitchCase {
      class,
      method_construct,
      method_get_cons,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &Option<JObject>,
    cons: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = optional_object_to_jvalue!(test);
    let cons = object_to_jvalue!(cons);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, cons, span],
        "Swc4jAstSwitchCase construct()"
      );
    return_value
  }

  pub fn get_cons<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cons,
        &[],
        "List get_cons()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "Optional get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSwitchStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_cases: JMethodID,
  method_get_discriminant: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSwitchStmt {}
unsafe impl Sync for JavaSwc4jAstSwitchStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstSwitchStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstSwitchStmt")
      .expect("Couldn't find class Swc4jAstSwitchStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSwitchStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSwitchStmt::new");
    let method_get_cases = env
      .get_method_id(
        &class,
        "getCases",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstSwitchStmt.getCases");
    let method_get_discriminant = env
      .get_method_id(
        &class,
        "getDiscriminant",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstSwitchStmt.getDiscriminant");
    JavaSwc4jAstSwitchStmt {
      class,
      method_construct,
      method_get_cases,
      method_get_discriminant,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    discriminant: &JObject<'_>,
    cases: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let discriminant = object_to_jvalue!(discriminant);
    let cases = object_to_jvalue!(cases);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[discriminant, cases, span],
        "Swc4jAstSwitchStmt construct()"
      );
    return_value
  }

  pub fn get_cases<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cases,
        &[],
        "List get_cases()"
      );
    return_value
  }

  pub fn get_discriminant<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_discriminant,
        &[],
        "ISwc4jAstExpr get_discriminant()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTaggedTpl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_tag: JMethodID,
  method_get_tpl: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTaggedTpl {}
unsafe impl Sync for JavaSwc4jAstTaggedTpl {}

#[allow(dead_code)]
impl JavaSwc4jAstTaggedTpl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTaggedTpl")
      .expect("Couldn't find class Swc4jAstTaggedTpl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTaggedTpl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstTpl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl::new");
    let method_get_tag = env
      .get_method_id(
        &class,
        "getTag",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getTag");
    let method_get_tpl = env
      .get_method_id(
        &class,
        "getTpl",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstTpl;",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getTpl");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getTypeParams");
    JavaSwc4jAstTaggedTpl {
      class,
      method_construct,
      method_get_tag,
      method_get_tpl,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    tag: &JObject<'_>,
    type_params: &Option<JObject>,
    tpl: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let tag = object_to_jvalue!(tag);
    let type_params = optional_object_to_jvalue!(type_params);
    let tpl = object_to_jvalue!(tpl);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[tag, type_params, tpl, span],
        "Swc4jAstTaggedTpl construct()"
      );
    return_value
  }

  pub fn get_tag<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_tag,
        &[],
        "ISwc4jAstExpr get_tag()"
      );
    return_value
  }

  pub fn get_tpl<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_tpl,
        &[],
        "Swc4jAstTpl get_tpl()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstThisExpr {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstThisExpr {}
unsafe impl Sync for JavaSwc4jAstThisExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstThisExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstThisExpr")
      .expect("Couldn't find class Swc4jAstThisExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstThisExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstThisExpr::new");
    JavaSwc4jAstThisExpr {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstThisExpr construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstThrowStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
}
unsafe impl Send for JavaSwc4jAstThrowStmt {}
unsafe impl Sync for JavaSwc4jAstThrowStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstThrowStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstThrowStmt")
      .expect("Couldn't find class Swc4jAstThrowStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstThrowStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstThrowStmt::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstThrowStmt.getArg");
    JavaSwc4jAstThrowStmt {
      class,
      method_construct,
      method_get_arg,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, span],
        "Swc4jAstThrowStmt construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTpl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exprs: JMethodID,
  method_get_quasis: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTpl {}
unsafe impl Sync for JavaSwc4jAstTpl {}

#[allow(dead_code)]
impl JavaSwc4jAstTpl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTpl")
      .expect("Couldn't find class Swc4jAstTpl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTpl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTpl::new");
    let method_get_exprs = env
      .get_method_id(
        &class,
        "getExprs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTpl.getExprs");
    let method_get_quasis = env
      .get_method_id(
        &class,
        "getQuasis",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTpl.getQuasis");
    JavaSwc4jAstTpl {
      class,
      method_construct,
      method_get_exprs,
      method_get_quasis,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exprs: &JObject<'_>,
    quasis: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let exprs = object_to_jvalue!(exprs);
    let quasis = object_to_jvalue!(quasis);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exprs, quasis, span],
        "Swc4jAstTpl construct()"
      );
    return_value
  }

  pub fn get_exprs<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exprs,
        &[],
        "List get_exprs()"
      );
    return_value
  }

  pub fn get_quasis<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_quasis,
        &[],
        "List get_quasis()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTplElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_cooked: JMethodID,
  method_get_raw: JMethodID,
  method_is_tail: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTplElement {}
unsafe impl Sync for JavaSwc4jAstTplElement {}

#[allow(dead_code)]
impl JavaSwc4jAstTplElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstTplElement")
      .expect("Couldn't find class Swc4jAstTplElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTplElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLjava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTplElement::new");
    let method_get_cooked = env
      .get_method_id(
        &class,
        "getCooked",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTplElement.getCooked");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstTplElement.getRaw");
    let method_is_tail = env
      .get_method_id(
        &class,
        "isTail",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTplElement.isTail");
    JavaSwc4jAstTplElement {
      class,
      method_construct,
      method_get_cooked,
      method_get_raw,
      method_is_tail,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    tail: bool,
    cooked: &Option<String>,
    raw: &str,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let tail = boolean_to_jvalue!(tail);
    let java_cooked = optional_string_to_jstring!(env, &cooked);
    let cooked = object_to_jvalue!(java_cooked);
    let java_raw = string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[tail, cooked, raw, span],
        "Swc4jAstTplElement construct()"
      );
    delete_local_ref!(env, java_cooked);
    delete_local_ref!(env, java_raw);
    return_value
  }

  pub fn get_cooked<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cooked,
        &[],
        "Optional get_cooked()"
      );
    return_value
  }

  pub fn get_raw<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> String
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "String get_raw()"
      );
    let java_return_value = return_value;
    let return_value = jstring_to_string!(env, java_return_value.as_raw());
    delete_local_ref!(env, java_return_value);
    return_value
  }

  pub fn is_tail<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_tail,
        &[],
        "boolean is_tail()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTryStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_block: JMethodID,
  method_get_finalizer: JMethodID,
  method_get_handler: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTryStmt {}
unsafe impl Sync for JavaSwc4jAstTryStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstTryStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTryStmt")
      .expect("Couldn't find class Swc4jAstTryStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTryStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstCatchClause;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTryStmt::new");
    let method_get_block = env
      .get_method_id(
        &class,
        "getBlock",
        "()Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;",
      )
      .expect("Couldn't find method Swc4jAstTryStmt.getBlock");
    let method_get_finalizer = env
      .get_method_id(
        &class,
        "getFinalizer",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTryStmt.getFinalizer");
    let method_get_handler = env
      .get_method_id(
        &class,
        "getHandler",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTryStmt.getHandler");
    JavaSwc4jAstTryStmt {
      class,
      method_construct,
      method_get_block,
      method_get_finalizer,
      method_get_handler,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    block: &JObject<'_>,
    handler: &Option<JObject>,
    finalizer: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let block = object_to_jvalue!(block);
    let handler = optional_object_to_jvalue!(handler);
    let finalizer = optional_object_to_jvalue!(finalizer);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[block, handler, finalizer, span],
        "Swc4jAstTryStmt construct()"
      );
    return_value
  }

  pub fn get_block<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_block,
        &[],
        "Swc4jAstBlockStmt get_block()"
      );
    return_value
  }

  pub fn get_finalizer<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_finalizer,
        &[],
        "Optional get_finalizer()"
      );
    return_value
  }

  pub fn get_handler<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_handler,
        &[],
        "Optional get_handler()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsArrayType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elem_type: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsArrayType {}
unsafe impl Sync for JavaSwc4jAstTsArrayType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsArrayType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsArrayType")
      .expect("Couldn't find class Swc4jAstTsArrayType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsArrayType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsArrayType::new");
    let method_get_elem_type = env
      .get_method_id(
        &class,
        "getElemType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsArrayType.getElemType");
    JavaSwc4jAstTsArrayType {
      class,
      method_construct,
      method_get_elem_type,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elem_type: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let elem_type = object_to_jvalue!(elem_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elem_type, span],
        "Swc4jAstTsArrayType construct()"
      );
    return_value
  }

  pub fn get_elem_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elem_type,
        &[],
        "ISwc4jAstTsType get_elem_type()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsAsExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsAsExpr {}
unsafe impl Sync for JavaSwc4jAstTsAsExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstTsAsExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsAsExpr")
      .expect("Couldn't find class Swc4jAstTsAsExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsAsExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsAsExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsAsExpr.getExpr");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsAsExpr.getTypeAnn");
    JavaSwc4jAstTsAsExpr {
      class,
      method_construct,
      method_get_expr,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_ann, span],
        "Swc4jAstTsAsExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsCallSignatureDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsCallSignatureDecl {}
unsafe impl Sync for JavaSwc4jAstTsCallSignatureDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsCallSignatureDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsCallSignatureDecl")
      .expect("Couldn't find class Swc4jAstTsCallSignatureDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsCallSignatureDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl.getTypeParams");
    JavaSwc4jAstTsCallSignatureDecl {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_ann, type_params, span],
        "Swc4jAstTsCallSignatureDecl construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConditionalType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_check_type: JMethodID,
  method_get_extends_type: JMethodID,
  method_get_false_type: JMethodID,
  method_get_true_type: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConditionalType {}
unsafe impl Sync for JavaSwc4jAstTsConditionalType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConditionalType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsConditionalType")
      .expect("Couldn't find class Swc4jAstTsConditionalType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConditionalType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType::new");
    let method_get_check_type = env
      .get_method_id(
        &class,
        "getCheckType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getCheckType");
    let method_get_extends_type = env
      .get_method_id(
        &class,
        "getExtendsType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getExtendsType");
    let method_get_false_type = env
      .get_method_id(
        &class,
        "getFalseType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getFalseType");
    let method_get_true_type = env
      .get_method_id(
        &class,
        "getTrueType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getTrueType");
    JavaSwc4jAstTsConditionalType {
      class,
      method_construct,
      method_get_check_type,
      method_get_extends_type,
      method_get_false_type,
      method_get_true_type,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    check_type: &JObject<'_>,
    extends_type: &JObject<'_>,
    true_type: &JObject<'_>,
    false_type: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let check_type = object_to_jvalue!(check_type);
    let extends_type = object_to_jvalue!(extends_type);
    let true_type = object_to_jvalue!(true_type);
    let false_type = object_to_jvalue!(false_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[check_type, extends_type, true_type, false_type, span],
        "Swc4jAstTsConditionalType construct()"
      );
    return_value
  }

  pub fn get_check_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_check_type,
        &[],
        "ISwc4jAstTsType get_check_type()"
      );
    return_value
  }

  pub fn get_extends_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_extends_type,
        &[],
        "ISwc4jAstTsType get_extends_type()"
      );
    return_value
  }

  pub fn get_false_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_false_type,
        &[],
        "ISwc4jAstTsType get_false_type()"
      );
    return_value
  }

  pub fn get_true_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_true_type,
        &[],
        "ISwc4jAstTsType get_true_type()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConstAssertion {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConstAssertion {}
unsafe impl Sync for JavaSwc4jAstTsConstAssertion {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConstAssertion {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsConstAssertion")
      .expect("Couldn't find class Swc4jAstTsConstAssertion");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConstAssertion");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConstAssertion::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsConstAssertion.getExpr");
    JavaSwc4jAstTsConstAssertion {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsConstAssertion construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConstructSignatureDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConstructSignatureDecl {}
unsafe impl Sync for JavaSwc4jAstTsConstructSignatureDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConstructSignatureDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsConstructSignatureDecl")
      .expect("Couldn't find class Swc4jAstTsConstructSignatureDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConstructSignatureDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl.getTypeParams");
    JavaSwc4jAstTsConstructSignatureDecl {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_ann, type_params, span],
        "Swc4jAstTsConstructSignatureDecl construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConstructorType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_abstract: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConstructorType {}
unsafe impl Sync for JavaSwc4jAstTsConstructorType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConstructorType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsConstructorType")
      .expect("Couldn't find class Swc4jAstTsConstructorType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConstructorType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.getTypeParams");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.isAbstract");
    JavaSwc4jAstTsConstructorType {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
      method_is_abstract,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_params: &Option<JObject>,
    type_ann: &JObject<'_>,
    is_abstract: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_params = optional_object_to_jvalue!(type_params);
    let type_ann = object_to_jvalue!(type_ann);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_params, type_ann, is_abstract, span],
        "Swc4jAstTsConstructorType construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Swc4jAstTsTypeAnn get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsEnumDecl {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsEnumDecl {}
unsafe impl Sync for JavaSwc4jAstTsEnumDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsEnumDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsEnumDecl")
      .expect("Couldn't find class Swc4jAstTsEnumDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsEnumDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsEnumDecl::new");
    JavaSwc4jAstTsEnumDecl {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    declare: bool,
    is_const: bool,
    id: &JObject<'_>,
    members: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let declare = boolean_to_jvalue!(declare);
    let is_const = boolean_to_jvalue!(is_const);
    let id = object_to_jvalue!(id);
    let members = object_to_jvalue!(members);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[declare, is_const, id, members, span],
        "Swc4jAstTsEnumDecl construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsEnumMember {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_init: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsEnumMember {}
unsafe impl Sync for JavaSwc4jAstTsEnumMember {}

#[allow(dead_code)]
impl JavaSwc4jAstTsEnumMember {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsEnumMember")
      .expect("Couldn't find class Swc4jAstTsEnumMember");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsEnumMember");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEnumMemberId;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsEnumMember::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEnumMemberId;",
      )
      .expect("Couldn't find method Swc4jAstTsEnumMember.getId");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsEnumMember.getInit");
    JavaSwc4jAstTsEnumMember {
      class,
      method_construct,
      method_get_id,
      method_get_init,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    init: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let init = optional_object_to_jvalue!(init);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, init, span],
        "Swc4jAstTsEnumMember construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "ISwc4jAstTsEnumMemberId get_id()"
      );
    return_value
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsExportAssignment {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsExportAssignment {}
unsafe impl Sync for JavaSwc4jAstTsExportAssignment {}

#[allow(dead_code)]
impl JavaSwc4jAstTsExportAssignment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsExportAssignment")
      .expect("Couldn't find class Swc4jAstTsExportAssignment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsExportAssignment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsExportAssignment::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsExportAssignment.getExpr");
    JavaSwc4jAstTsExportAssignment {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsExportAssignment construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsExprWithTypeArgs {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsExprWithTypeArgs {}
unsafe impl Sync for JavaSwc4jAstTsExprWithTypeArgs {}

#[allow(dead_code)]
impl JavaSwc4jAstTsExprWithTypeArgs {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsExprWithTypeArgs")
      .expect("Couldn't find class Swc4jAstTsExprWithTypeArgs");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsExprWithTypeArgs");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsExprWithTypeArgs::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsExprWithTypeArgs.getExpr");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsExprWithTypeArgs.getTypeArgs");
    JavaSwc4jAstTsExprWithTypeArgs {
      class,
      method_construct,
      method_get_expr,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_args, span],
        "Swc4jAstTsExprWithTypeArgs construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsExternalModuleRef {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsExternalModuleRef {}
unsafe impl Sync for JavaSwc4jAstTsExternalModuleRef {}

#[allow(dead_code)]
impl JavaSwc4jAstTsExternalModuleRef {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsExternalModuleRef")
      .expect("Couldn't find class Swc4jAstTsExternalModuleRef");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsExternalModuleRef");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsExternalModuleRef::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstTsExternalModuleRef.getExpr");
    JavaSwc4jAstTsExternalModuleRef {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsExternalModuleRef construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "Swc4jAstStr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsFnType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsFnType {}
unsafe impl Sync for JavaSwc4jAstTsFnType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsFnType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsFnType")
      .expect("Couldn't find class Swc4jAstTsFnType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsFnType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsFnType::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsFnType.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;",
      )
      .expect("Couldn't find method Swc4jAstTsFnType.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsFnType.getTypeParams");
    JavaSwc4jAstTsFnType {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_params: &Option<JObject>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_params = optional_object_to_jvalue!(type_params);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_params, type_ann, span],
        "Swc4jAstTsFnType construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Swc4jAstTsTypeAnn get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsGetterSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsGetterSignature {}
unsafe impl Sync for JavaSwc4jAstTsGetterSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsGetterSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsGetterSignature")
      .expect("Couldn't find class Swc4jAstTsGetterSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsGetterSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.getTypeAnn");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.isOptional");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.isReadonly");
    JavaSwc4jAstTsGetterSignature {
      class,
      method_construct,
      method_get_key,
      method_get_type_ann,
      method_is_computed,
      method_is_optional,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, key, computed, optional, type_ann, span],
        "Swc4jAstTsGetterSignature construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsImportEqualsDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_module_ref: JMethodID,
  method_is_export: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsImportEqualsDecl {}
unsafe impl Sync for JavaSwc4jAstTsImportEqualsDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsImportEqualsDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsImportEqualsDecl")
      .expect("Couldn't find class Swc4jAstTsImportEqualsDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsImportEqualsDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleRef;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.getId");
    let method_get_module_ref = env
      .get_method_id(
        &class,
        "getModuleRef",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleRef;",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.getModuleRef");
    let method_is_export = env
      .get_method_id(
        &class,
        "isExport",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.isExport");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.isTypeOnly");
    JavaSwc4jAstTsImportEqualsDecl {
      class,
      method_construct,
      method_get_id,
      method_get_module_ref,
      method_is_export,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    export: bool,
    type_only: bool,
    id: &JObject<'_>,
    module_ref: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let export = boolean_to_jvalue!(export);
    let type_only = boolean_to_jvalue!(type_only);
    let id = object_to_jvalue!(id);
    let module_ref = object_to_jvalue!(module_ref);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[export, type_only, id, module_ref, span],
        "Swc4jAstTsImportEqualsDecl construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn get_module_ref<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_module_ref,
        &[],
        "ISwc4jAstTsModuleRef get_module_ref()"
      );
    return_value
  }

  pub fn is_export<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_export,
        &[],
        "boolean is_export()"
      );
    return_value
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsImportType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_qualifier: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsImportType {}
unsafe impl Sync for JavaSwc4jAstTsImportType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsImportType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsImportType")
      .expect("Couldn't find class Swc4jAstTsImportType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsImportType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsImportType::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstTsImportType.getArg");
    let method_get_qualifier = env
      .get_method_id(
        &class,
        "getQualifier",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsImportType.getQualifier");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsImportType.getTypeArgs");
    JavaSwc4jAstTsImportType {
      class,
      method_construct,
      method_get_arg,
      method_get_qualifier,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &JObject<'_>,
    qualifier: &Option<JObject>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = object_to_jvalue!(arg);
    let qualifier = optional_object_to_jvalue!(qualifier);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, qualifier, type_args, span],
        "Swc4jAstTsImportType construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "Swc4jAstStr get_arg()"
      );
    return_value
  }

  pub fn get_qualifier<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_qualifier,
        &[],
        "Optional get_qualifier()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsIndexSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_readonly: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsIndexSignature {}
unsafe impl Sync for JavaSwc4jAstTsIndexSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsIndexSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsIndexSignature")
      .expect("Couldn't find class Swc4jAstTsIndexSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsIndexSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.getTypeAnn");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.isReadonly");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.isStatic");
    JavaSwc4jAstTsIndexSignature {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_is_readonly,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    readonly: bool,
    is_static: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let readonly = boolean_to_jvalue!(readonly);
    let is_static = boolean_to_jvalue!(is_static);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_ann, readonly, is_static, span],
        "Swc4jAstTsIndexSignature construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsIndexedAccessType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_index_type: JMethodID,
  method_get_obj_type: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsIndexedAccessType {}
unsafe impl Sync for JavaSwc4jAstTsIndexedAccessType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsIndexedAccessType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsIndexedAccessType")
      .expect("Couldn't find class Swc4jAstTsIndexedAccessType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsIndexedAccessType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType::new");
    let method_get_index_type = env
      .get_method_id(
        &class,
        "getIndexType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType.getIndexType");
    let method_get_obj_type = env
      .get_method_id(
        &class,
        "getObjType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType.getObjType");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType.isReadonly");
    JavaSwc4jAstTsIndexedAccessType {
      class,
      method_construct,
      method_get_index_type,
      method_get_obj_type,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    obj_type: &JObject<'_>,
    index_type: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let obj_type = object_to_jvalue!(obj_type);
    let index_type = object_to_jvalue!(index_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, obj_type, index_type, span],
        "Swc4jAstTsIndexedAccessType construct()"
      );
    return_value
  }

  pub fn get_index_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_index_type,
        &[],
        "ISwc4jAstTsType get_index_type()"
      );
    return_value
  }

  pub fn get_obj_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj_type,
        &[],
        "ISwc4jAstTsType get_obj_type()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInferType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInferType {}
unsafe impl Sync for JavaSwc4jAstTsInferType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInferType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInferType")
      .expect("Couldn't find class Swc4jAstTsInferType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInferType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInferType::new");
    let method_get_type_param = env
      .get_method_id(
        &class,
        "getTypeParam",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;",
      )
      .expect("Couldn't find method Swc4jAstTsInferType.getTypeParam");
    JavaSwc4jAstTsInferType {
      class,
      method_construct,
      method_get_type_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_param: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_param = object_to_jvalue!(type_param);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_param, span],
        "Swc4jAstTsInferType construct()"
      );
    return_value
  }

  pub fn get_type_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_param,
        &[],
        "Swc4jAstTsTypeParam get_type_param()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInstantiation {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInstantiation {}
unsafe impl Sync for JavaSwc4jAstTsInstantiation {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInstantiation {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsInstantiation")
      .expect("Couldn't find class Swc4jAstTsInstantiation");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInstantiation");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInstantiation::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsInstantiation.getExpr");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;",
      )
      .expect("Couldn't find method Swc4jAstTsInstantiation.getTypeArgs");
    JavaSwc4jAstTsInstantiation {
      class,
      method_construct,
      method_get_expr,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_args: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_args = object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_args, span],
        "Swc4jAstTsInstantiation construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Swc4jAstTsTypeParamInstantiation get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInterfaceBody {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInterfaceBody {}
unsafe impl Sync for JavaSwc4jAstTsInterfaceBody {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInterfaceBody {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInterfaceBody")
      .expect("Couldn't find class Swc4jAstTsInterfaceBody");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInterfaceBody");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceBody::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceBody.getBody");
    JavaSwc4jAstTsInterfaceBody {
      class,
      method_construct,
      method_get_body,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, span],
        "Swc4jAstTsInterfaceBody construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInterfaceDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_extends: JMethodID,
  method_get_id: JMethodID,
  method_get_type_params: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInterfaceDecl {}
unsafe impl Sync for JavaSwc4jAstTsInterfaceDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInterfaceDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsInterfaceDecl")
      .expect("Couldn't find class Swc4jAstTsInterfaceDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInterfaceDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInterfaceBody;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInterfaceBody;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getBody");
    let method_get_extends = env
      .get_method_id(
        &class,
        "getExtends",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getExtends");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getId");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getTypeParams");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.isDeclare");
    JavaSwc4jAstTsInterfaceDecl {
      class,
      method_construct,
      method_get_body,
      method_get_extends,
      method_get_id,
      method_get_type_params,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    declare: bool,
    type_params: &Option<JObject>,
    extends: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let declare = boolean_to_jvalue!(declare);
    let type_params = optional_object_to_jvalue!(type_params);
    let extends = object_to_jvalue!(extends);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, declare, type_params, extends, body, span],
        "Swc4jAstTsInterfaceDecl construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Swc4jAstTsInterfaceBody get_body()"
      );
    return_value
  }

  pub fn get_extends<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_extends,
        &[],
        "List get_extends()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsIntersectionType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsIntersectionType {}
unsafe impl Sync for JavaSwc4jAstTsIntersectionType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsIntersectionType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsIntersectionType")
      .expect("Couldn't find class Swc4jAstTsIntersectionType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsIntersectionType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsIntersectionType::new");
    let method_get_types = env
      .get_method_id(
        &class,
        "getTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsIntersectionType.getTypes");
    JavaSwc4jAstTsIntersectionType {
      class,
      method_construct,
      method_get_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    types: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let types = object_to_jvalue!(types);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[types, span],
        "Swc4jAstTsIntersectionType construct()"
      );
    return_value
  }

  pub fn get_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_types,
        &[],
        "List get_types()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsKeywordType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_kind: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsKeywordType {}
unsafe impl Sync for JavaSwc4jAstTsKeywordType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsKeywordType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsKeywordType")
      .expect("Couldn't find class Swc4jAstTsKeywordType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsKeywordType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsKeywordTypeKind;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsKeywordType::new");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsKeywordTypeKind;",
      )
      .expect("Couldn't find method Swc4jAstTsKeywordType.getKind");
    JavaSwc4jAstTsKeywordType {
      class,
      method_construct,
      method_get_kind,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    kind: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let kind = object_to_jvalue!(kind);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[kind, span],
        "Swc4jAstTsKeywordType construct()"
      );
    return_value
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstTsKeywordTypeKind get_kind()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsLitType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_lit: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsLitType {}
unsafe impl Sync for JavaSwc4jAstTsLitType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsLitType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsLitType")
      .expect("Couldn't find class Swc4jAstTsLitType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsLitType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsLit;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsLitType::new");
    let method_get_lit = env
      .get_method_id(
        &class,
        "getLit",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsLit;",
      )
      .expect("Couldn't find method Swc4jAstTsLitType.getLit");
    JavaSwc4jAstTsLitType {
      class,
      method_construct,
      method_get_lit,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    lit: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let lit = object_to_jvalue!(lit);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[lit, span],
        "Swc4jAstTsLitType construct()"
      );
    return_value
  }

  pub fn get_lit<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_lit,
        &[],
        "ISwc4jAstTsLit get_lit()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsMappedType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name_type: JMethodID,
  method_get_optional: JMethodID,
  method_get_readonly: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsMappedType {}
unsafe impl Sync for JavaSwc4jAstTsMappedType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsMappedType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsMappedType")
      .expect("Couldn't find class Swc4jAstTsMappedType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsMappedType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTruePlusMinus;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTruePlusMinus;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType::new");
    let method_get_name_type = env
      .get_method_id(
        &class,
        "getNameType",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getNameType");
    let method_get_optional = env
      .get_method_id(
        &class,
        "getOptional",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getOptional");
    let method_get_readonly = env
      .get_method_id(
        &class,
        "getReadonly",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getReadonly");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getTypeAnn");
    let method_get_type_param = env
      .get_method_id(
        &class,
        "getTypeParam",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getTypeParam");
    JavaSwc4jAstTsMappedType {
      class,
      method_construct,
      method_get_name_type,
      method_get_optional,
      method_get_readonly,
      method_get_type_ann,
      method_get_type_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: &Option<JObject>,
    type_param: &JObject<'_>,
    name_type: &Option<JObject>,
    optional: &Option<JObject>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = optional_object_to_jvalue!(readonly);
    let type_param = object_to_jvalue!(type_param);
    let name_type = optional_object_to_jvalue!(name_type);
    let optional = optional_object_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, type_param, name_type, optional, type_ann, span],
        "Swc4jAstTsMappedType construct()"
      );
    return_value
  }

  pub fn get_name_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name_type,
        &[],
        "Optional get_name_type()"
      );
    return_value
  }

  pub fn get_optional<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_optional,
        &[],
        "Optional get_optional()"
      );
    return_value
  }

  pub fn get_readonly<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_readonly,
        &[],
        "Optional get_readonly()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_param,
        &[],
        "Swc4jAstTsTypeParam get_type_param()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsMethodSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsMethodSignature {}
unsafe impl Sync for JavaSwc4jAstTsMethodSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsMethodSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsMethodSignature")
      .expect("Couldn't find class Swc4jAstTsMethodSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsMethodSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getKey");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getTypeParams");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.isOptional");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.isReadonly");
    JavaSwc4jAstTsMethodSignature {
      class,
      method_construct,
      method_get_key,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
      method_is_computed,
      method_is_optional,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, key, computed, optional, params, type_ann, type_params, span],
        "Swc4jAstTsMethodSignature construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsModuleBlock {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsModuleBlock {}
unsafe impl Sync for JavaSwc4jAstTsModuleBlock {}

#[allow(dead_code)]
impl JavaSwc4jAstTsModuleBlock {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsModuleBlock")
      .expect("Couldn't find class Swc4jAstTsModuleBlock");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsModuleBlock");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsModuleBlock::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsModuleBlock.getBody");
    JavaSwc4jAstTsModuleBlock {
      class,
      method_construct,
      method_get_body,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, span],
        "Swc4jAstTsModuleBlock construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsModuleDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_id: JMethodID,
  method_is_declare: JMethodID,
  method_is_global: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsModuleDecl {}
unsafe impl Sync for JavaSwc4jAstTsModuleDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsModuleDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsModuleDecl")
      .expect("Couldn't find class Swc4jAstTsModuleDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsModuleDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.getBody");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleName;",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.getId");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.isDeclare");
    let method_is_global = env
      .get_method_id(
        &class,
        "isGlobal",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.isGlobal");
    JavaSwc4jAstTsModuleDecl {
      class,
      method_construct,
      method_get_body,
      method_get_id,
      method_is_declare,
      method_is_global,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    declare: bool,
    global: bool,
    id: &JObject<'_>,
    body: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let declare = boolean_to_jvalue!(declare);
    let global = boolean_to_jvalue!(global);
    let id = object_to_jvalue!(id);
    let body = optional_object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[declare, global, id, body, span],
        "Swc4jAstTsModuleDecl construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "ISwc4jAstTsModuleName get_id()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }

  pub fn is_global<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_global,
        &[],
        "boolean is_global()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsNamespaceDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_id: JMethodID,
  method_is_declare: JMethodID,
  method_is_global: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsNamespaceDecl {}
unsafe impl Sync for JavaSwc4jAstTsNamespaceDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsNamespaceDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsNamespaceDecl")
      .expect("Couldn't find class Swc4jAstTsNamespaceDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsNamespaceDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody;",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.getBody");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.getId");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.isDeclare");
    let method_is_global = env
      .get_method_id(
        &class,
        "isGlobal",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.isGlobal");
    JavaSwc4jAstTsNamespaceDecl {
      class,
      method_construct,
      method_get_body,
      method_get_id,
      method_is_declare,
      method_is_global,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    declare: bool,
    global: bool,
    id: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let declare = boolean_to_jvalue!(declare);
    let global = boolean_to_jvalue!(global);
    let id = object_to_jvalue!(id);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[declare, global, id, body, span],
        "Swc4jAstTsNamespaceDecl construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstTsNamespaceBody get_body()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }

  pub fn is_global<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_global,
        &[],
        "boolean is_global()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsNamespaceExportDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsNamespaceExportDecl {}
unsafe impl Sync for JavaSwc4jAstTsNamespaceExportDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsNamespaceExportDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsNamespaceExportDecl")
      .expect("Couldn't find class Swc4jAstTsNamespaceExportDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsNamespaceExportDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceExportDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceExportDecl.getId");
    JavaSwc4jAstTsNamespaceExportDecl {
      class,
      method_construct,
      method_get_id,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, span],
        "Swc4jAstTsNamespaceExportDecl construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsNonNullExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsNonNullExpr {}
unsafe impl Sync for JavaSwc4jAstTsNonNullExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstTsNonNullExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsNonNullExpr")
      .expect("Couldn't find class Swc4jAstTsNonNullExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsNonNullExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsNonNullExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsNonNullExpr.getExpr");
    JavaSwc4jAstTsNonNullExpr {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsNonNullExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsOptionalType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsOptionalType {}
unsafe impl Sync for JavaSwc4jAstTsOptionalType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsOptionalType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsOptionalType")
      .expect("Couldn't find class Swc4jAstTsOptionalType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsOptionalType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsOptionalType::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsOptionalType.getTypeAnn");
    JavaSwc4jAstTsOptionalType {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsOptionalType construct()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsParamProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_param: JMethodID,
  method_is_override: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsParamProp {}
unsafe impl Sync for JavaSwc4jAstTsParamProp {}

#[allow(dead_code)]
impl JavaSwc4jAstTsParamProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsParamProp")
      .expect("Couldn't find class Swc4jAstTsParamProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsParamProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsParamPropParam;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.getDecorators");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsParamPropParam;",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.getParam");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.isOverride");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.isReadonly");
    JavaSwc4jAstTsParamProp {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_param,
      method_is_override,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    is_override: bool,
    readonly: bool,
    param: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_override = boolean_to_jvalue!(is_override);
    let readonly = boolean_to_jvalue!(readonly);
    let param = object_to_jvalue!(param);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decorators, accessibility, is_override, readonly, param, span],
        "Swc4jAstTsParamProp construct()"
      );
    return_value
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      );
    return_value
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      );
    return_value
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "ISwc4jAstTsParamPropParam get_param()"
      );
    return_value
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsParenthesizedType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsParenthesizedType {}
unsafe impl Sync for JavaSwc4jAstTsParenthesizedType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsParenthesizedType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsParenthesizedType")
      .expect("Couldn't find class Swc4jAstTsParenthesizedType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsParenthesizedType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsParenthesizedType::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsParenthesizedType.getTypeAnn");
    JavaSwc4jAstTsParenthesizedType {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsParenthesizedType construct()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsPropertySignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_init: JMethodID,
  method_get_key: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsPropertySignature {}
unsafe impl Sync for JavaSwc4jAstTsPropertySignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsPropertySignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsPropertySignature")
      .expect("Couldn't find class Swc4jAstTsPropertySignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsPropertySignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature::new");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getInit");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getKey");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getTypeParams");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.isOptional");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.isReadonly");
    JavaSwc4jAstTsPropertySignature {
      class,
      method_construct,
      method_get_init,
      method_get_key,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
      method_is_computed,
      method_is_optional,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    init: &Option<JObject>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let init = optional_object_to_jvalue!(init);
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, key, computed, optional, init, params, type_ann, type_params, span],
        "Swc4jAstTsPropertySignature construct()"
      );
    return_value
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsQualifiedName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsQualifiedName {}
unsafe impl Sync for JavaSwc4jAstTsQualifiedName {}

#[allow(dead_code)]
impl JavaSwc4jAstTsQualifiedName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsQualifiedName")
      .expect("Couldn't find class Swc4jAstTsQualifiedName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsQualifiedName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsQualifiedName::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;",
      )
      .expect("Couldn't find method Swc4jAstTsQualifiedName.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsQualifiedName.getRight");
    JavaSwc4jAstTsQualifiedName {
      class,
      method_construct,
      method_get_left,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[left, right, span],
        "Swc4jAstTsQualifiedName construct()"
      );
    return_value
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstTsEntityName get_left()"
      );
    return_value
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "Swc4jAstIdent get_right()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsRestType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsRestType {}
unsafe impl Sync for JavaSwc4jAstTsRestType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsRestType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsRestType")
      .expect("Couldn't find class Swc4jAstTsRestType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsRestType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsRestType::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsRestType.getTypeAnn");
    JavaSwc4jAstTsRestType {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsRestType construct()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsSatisfiesExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsSatisfiesExpr {}
unsafe impl Sync for JavaSwc4jAstTsSatisfiesExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstTsSatisfiesExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsSatisfiesExpr")
      .expect("Couldn't find class Swc4jAstTsSatisfiesExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsSatisfiesExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsSatisfiesExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsSatisfiesExpr.getExpr");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsSatisfiesExpr.getTypeAnn");
    JavaSwc4jAstTsSatisfiesExpr {
      class,
      method_construct,
      method_get_expr,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_ann, span],
        "Swc4jAstTsSatisfiesExpr construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsSetterSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_param: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsSetterSignature {}
unsafe impl Sync for JavaSwc4jAstTsSetterSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsSetterSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsSetterSignature")
      .expect("Couldn't find class Swc4jAstTsSetterSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsSetterSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsFnParam;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.getKey");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsFnParam;",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.getParam");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.isOptional");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.isReadonly");
    JavaSwc4jAstTsSetterSignature {
      class,
      method_construct,
      method_get_key,
      method_get_param,
      method_is_computed,
      method_is_optional,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    param: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let param = object_to_jvalue!(param);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, key, computed, optional, param, span],
        "Swc4jAstTsSetterSignature construct()"
      );
    return_value
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      );
    return_value
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "ISwc4jAstTsFnParam get_param()"
      );
    return_value
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      );
    return_value
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      );
    return_value
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsThisType {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsThisType {}
unsafe impl Sync for JavaSwc4jAstTsThisType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsThisType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsThisType")
      .expect("Couldn't find class Swc4jAstTsThisType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsThisType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsThisType::new");
    JavaSwc4jAstTsThisType {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstTsThisType construct()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTplLitType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_quasis: JMethodID,
  method_get_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTplLitType {}
unsafe impl Sync for JavaSwc4jAstTsTplLitType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTplLitType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTplLitType")
      .expect("Couldn't find class Swc4jAstTsTplLitType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTplLitType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTplLitType::new");
    let method_get_quasis = env
      .get_method_id(
        &class,
        "getQuasis",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTplLitType.getQuasis");
    let method_get_types = env
      .get_method_id(
        &class,
        "getTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTplLitType.getTypes");
    JavaSwc4jAstTsTplLitType {
      class,
      method_construct,
      method_get_quasis,
      method_get_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    types: &JObject<'_>,
    quasis: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let types = object_to_jvalue!(types);
    let quasis = object_to_jvalue!(quasis);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[types, quasis, span],
        "Swc4jAstTsTplLitType construct()"
      );
    return_value
  }

  pub fn get_quasis<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_quasis,
        &[],
        "List get_quasis()"
      );
    return_value
  }

  pub fn get_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_types,
        &[],
        "List get_types()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTupleElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_label: JMethodID,
  method_get_ty: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTupleElement {}
unsafe impl Sync for JavaSwc4jAstTsTupleElement {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTupleElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTupleElement")
      .expect("Couldn't find class Swc4jAstTsTupleElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTupleElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTupleElement::new");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTupleElement.getLabel");
    let method_get_ty = env
      .get_method_id(
        &class,
        "getTy",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTupleElement.getTy");
    JavaSwc4jAstTsTupleElement {
      class,
      method_construct,
      method_get_label,
      method_get_ty,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &Option<JObject>,
    ty: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let label = optional_object_to_jvalue!(label);
    let ty = object_to_jvalue!(ty);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, ty, span],
        "Swc4jAstTsTupleElement construct()"
      );
    return_value
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Optional get_label()"
      );
    return_value
  }

  pub fn get_ty<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ty,
        &[],
        "ISwc4jAstTsType get_ty()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTupleType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elem_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTupleType {}
unsafe impl Sync for JavaSwc4jAstTsTupleType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTupleType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTupleType")
      .expect("Couldn't find class Swc4jAstTsTupleType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTupleType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTupleType::new");
    let method_get_elem_types = env
      .get_method_id(
        &class,
        "getElemTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTupleType.getElemTypes");
    JavaSwc4jAstTsTupleType {
      class,
      method_construct,
      method_get_elem_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elem_types: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let elem_types = object_to_jvalue!(elem_types);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elem_types, span],
        "Swc4jAstTsTupleType construct()"
      );
    return_value
  }

  pub fn get_elem_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elem_types,
        &[],
        "List get_elem_types()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeAliasDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeAliasDecl {}
unsafe impl Sync for JavaSwc4jAstTsTypeAliasDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeAliasDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsTypeAliasDecl")
      .expect("Couldn't find class Swc4jAstTsTypeAliasDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeAliasDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.getId");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.getTypeParams");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.isDeclare");
    JavaSwc4jAstTsTypeAliasDecl {
      class,
      method_construct,
      method_get_id,
      method_get_type_ann,
      method_get_type_params,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    declare: bool,
    type_params: &Option<JObject>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let declare = boolean_to_jvalue!(declare);
    let type_params = optional_object_to_jvalue!(type_params);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, declare, type_params, type_ann, span],
        "Swc4jAstTsTypeAliasDecl construct()"
      );
    return_value
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeAnn {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeAnn {}
unsafe impl Sync for JavaSwc4jAstTsTypeAnn {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeAnn {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn")
      .expect("Couldn't find class Swc4jAstTsTypeAnn");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeAnn");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAnn::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAnn.getTypeAnn");
    JavaSwc4jAstTsTypeAnn {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsTypeAnn construct()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeAssertion {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeAssertion {}
unsafe impl Sync for JavaSwc4jAstTsTypeAssertion {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeAssertion {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsTypeAssertion")
      .expect("Couldn't find class Swc4jAstTsTypeAssertion");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeAssertion");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAssertion::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAssertion.getExpr");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAssertion.getTypeAnn");
    JavaSwc4jAstTsTypeAssertion {
      class,
      method_construct,
      method_get_expr,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_ann, span],
        "Swc4jAstTsTypeAssertion construct()"
      );
    return_value
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeLit {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_members: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeLit {}
unsafe impl Sync for JavaSwc4jAstTsTypeLit {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeLit")
      .expect("Couldn't find class Swc4jAstTsTypeLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeLit");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeLit::new");
    let method_get_members = env
      .get_method_id(
        &class,
        "getMembers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeLit.getMembers");
    JavaSwc4jAstTsTypeLit {
      class,
      method_construct,
      method_get_members,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    members: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let members = object_to_jvalue!(members);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[members, span],
        "Swc4jAstTsTypeLit construct()"
      );
    return_value
  }

  pub fn get_members<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_members,
        &[],
        "List get_members()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeOperator {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_op: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeOperator {}
unsafe impl Sync for JavaSwc4jAstTsTypeOperator {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeOperator {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeOperator")
      .expect("Couldn't find class Swc4jAstTsTypeOperator");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeOperator");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsTypeOperatorOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeOperator::new");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsTypeOperatorOp;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeOperator.getOp");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeOperator.getTypeAnn");
    JavaSwc4jAstTsTypeOperator {
      class,
      method_construct,
      method_get_op,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, type_ann, span],
        "Swc4jAstTsTypeOperator construct()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstTsTypeOperatorOp get_op()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeParam {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_constraint: JMethodID,
  method_get_default: JMethodID,
  method_get_name: JMethodID,
  method_is_const: JMethodID,
  method_is_in: JMethodID,
  method_is_out: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeParam {}
unsafe impl Sync for JavaSwc4jAstTsTypeParam {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeParam {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam")
      .expect("Couldn't find class Swc4jAstTsTypeParam");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeParam");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam::new");
    let method_get_constraint = env
      .get_method_id(
        &class,
        "getConstraint",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.getConstraint");
    let method_get_default = env
      .get_method_id(
        &class,
        "getDefault",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.getDefault");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.getName");
    let method_is_const = env
      .get_method_id(
        &class,
        "isConst",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.isConst");
    let method_is_in = env
      .get_method_id(
        &class,
        "isIn",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.isIn");
    let method_is_out = env
      .get_method_id(
        &class,
        "isOut",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.isOut");
    JavaSwc4jAstTsTypeParam {
      class,
      method_construct,
      method_get_constraint,
      method_get_default,
      method_get_name,
      method_is_const,
      method_is_in,
      method_is_out,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    is_in: bool,
    is_out: bool,
    is_count: bool,
    constraint: &Option<JObject>,
    default: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let is_in = boolean_to_jvalue!(is_in);
    let is_out = boolean_to_jvalue!(is_out);
    let is_count = boolean_to_jvalue!(is_count);
    let constraint = optional_object_to_jvalue!(constraint);
    let default = optional_object_to_jvalue!(default);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, is_in, is_out, is_count, constraint, default, span],
        "Swc4jAstTsTypeParam construct()"
      );
    return_value
  }

  pub fn get_constraint<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_constraint,
        &[],
        "Optional get_constraint()"
      );
    return_value
  }

  pub fn get_default<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_default,
        &[],
        "Optional get_default()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "Swc4jAstIdent get_name()"
      );
    return_value
  }

  pub fn is_const<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_const,
        &[],
        "boolean is_const()"
      );
    return_value
  }

  pub fn is_in<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_in,
        &[],
        "boolean is_in()"
      );
    return_value
  }

  pub fn is_out<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_out,
        &[],
        "boolean is_out()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeParamDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeParamDecl {}
unsafe impl Sync for JavaSwc4jAstTsTypeParamDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeParamDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl")
      .expect("Couldn't find class Swc4jAstTsTypeParamDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeParamDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamDecl::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamDecl.getParams");
    JavaSwc4jAstTsTypeParamDecl {
      class,
      method_construct,
      method_get_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, span],
        "Swc4jAstTsTypeParamDecl construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeParamInstantiation {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeParamInstantiation {}
unsafe impl Sync for JavaSwc4jAstTsTypeParamInstantiation {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeParamInstantiation {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation")
      .expect("Couldn't find class Swc4jAstTsTypeParamInstantiation");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeParamInstantiation");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamInstantiation::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamInstantiation.getParams");
    JavaSwc4jAstTsTypeParamInstantiation {
      class,
      method_construct,
      method_get_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, span],
        "Swc4jAstTsTypeParamInstantiation construct()"
      );
    return_value
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypePredicate {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_param_name: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_asserts: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypePredicate {}
unsafe impl Sync for JavaSwc4jAstTsTypePredicate {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypePredicate {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypePredicate")
      .expect("Couldn't find class Swc4jAstTsTypePredicate");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypePredicate");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsThisTypeOrIdent;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate::new");
    let method_get_param_name = env
      .get_method_id(
        &class,
        "getParamName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsThisTypeOrIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate.getParamName");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate.getTypeAnn");
    let method_is_asserts = env
      .get_method_id(
        &class,
        "isAsserts",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate.isAsserts");
    JavaSwc4jAstTsTypePredicate {
      class,
      method_construct,
      method_get_param_name,
      method_get_type_ann,
      method_is_asserts,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    asserts: bool,
    param_name: &JObject<'_>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let asserts = boolean_to_jvalue!(asserts);
    let param_name = object_to_jvalue!(param_name);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[asserts, param_name, type_ann, span],
        "Swc4jAstTsTypePredicate construct()"
      );
    return_value
  }

  pub fn get_param_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param_name,
        &[],
        "ISwc4jAstTsThisTypeOrIdent get_param_name()"
      );
    return_value
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      );
    return_value
  }

  pub fn is_asserts<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_asserts,
        &[],
        "boolean is_asserts()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeQuery {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr_name: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeQuery {}
unsafe impl Sync for JavaSwc4jAstTsTypeQuery {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeQuery {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeQuery")
      .expect("Couldn't find class Swc4jAstTsTypeQuery");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeQuery");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsTypeQueryExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeQuery::new");
    let method_get_expr_name = env
      .get_method_id(
        &class,
        "getExprName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsTypeQueryExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeQuery.getExprName");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeQuery.getTypeArgs");
    JavaSwc4jAstTsTypeQuery {
      class,
      method_construct,
      method_get_expr_name,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr_name: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let expr_name = object_to_jvalue!(expr_name);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr_name, type_args, span],
        "Swc4jAstTsTypeQuery construct()"
      );
    return_value
  }

  pub fn get_expr_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr_name,
        &[],
        "ISwc4jAstTsTypeQueryExpr get_expr_name()"
      );
    return_value
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeRef {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_name: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeRef {}
unsafe impl Sync for JavaSwc4jAstTsTypeRef {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeRef {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeRef")
      .expect("Couldn't find class Swc4jAstTsTypeRef");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeRef");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeRef::new");
    let method_get_type_name = env
      .get_method_id(
        &class,
        "getTypeName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeRef.getTypeName");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeRef.getTypeParams");
    JavaSwc4jAstTsTypeRef {
      class,
      method_construct,
      method_get_type_name,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_name: &JObject<'_>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let type_name = object_to_jvalue!(type_name);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_name, type_params, span],
        "Swc4jAstTsTypeRef construct()"
      );
    return_value
  }

  pub fn get_type_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_name,
        &[],
        "ISwc4jAstTsEntityName get_type_name()"
      );
    return_value
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsUnionType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsUnionType {}
unsafe impl Sync for JavaSwc4jAstTsUnionType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsUnionType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsUnionType")
      .expect("Couldn't find class Swc4jAstTsUnionType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsUnionType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsUnionType::new");
    let method_get_types = env
      .get_method_id(
        &class,
        "getTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsUnionType.getTypes");
    JavaSwc4jAstTsUnionType {
      class,
      method_construct,
      method_get_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    types: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let types = object_to_jvalue!(types);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[types, span],
        "Swc4jAstTsUnionType construct()"
      );
    return_value
  }

  pub fn get_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_types,
        &[],
        "List get_types()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstUnaryExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_op: JMethodID,
}
unsafe impl Send for JavaSwc4jAstUnaryExpr {}
unsafe impl Sync for JavaSwc4jAstUnaryExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstUnaryExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstUnaryExpr")
      .expect("Couldn't find class Swc4jAstUnaryExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstUnaryExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUnaryOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstUnaryExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstUnaryExpr.getArg");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUnaryOp;",
      )
      .expect("Couldn't find method Swc4jAstUnaryExpr.getOp");
    JavaSwc4jAstUnaryExpr {
      class,
      method_construct,
      method_get_arg,
      method_get_op,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, arg, span],
        "Swc4jAstUnaryExpr construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstUnaryOp get_op()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstUpdateExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_op: JMethodID,
  method_is_prefix: JMethodID,
}
unsafe impl Send for JavaSwc4jAstUpdateExpr {}
unsafe impl Sync for JavaSwc4jAstUpdateExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstUpdateExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstUpdateExpr")
      .expect("Couldn't find class Swc4jAstUpdateExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstUpdateExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUpdateOp;ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr.getArg");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUpdateOp;",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr.getOp");
    let method_is_prefix = env
      .get_method_id(
        &class,
        "isPrefix",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr.isPrefix");
    JavaSwc4jAstUpdateExpr {
      class,
      method_construct,
      method_get_arg,
      method_get_op,
      method_is_prefix,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    prefix: bool,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let prefix = boolean_to_jvalue!(prefix);
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, prefix, arg, span],
        "Swc4jAstUpdateExpr construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      );
    return_value
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstUpdateOp get_op()"
      );
    return_value
  }

  pub fn is_prefix<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_prefix,
        &[],
        "boolean is_prefix()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstUsingDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decls: JMethodID,
  method_is_await: JMethodID,
}
unsafe impl Send for JavaSwc4jAstUsingDecl {}
unsafe impl Sync for JavaSwc4jAstUsingDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstUsingDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstUsingDecl")
      .expect("Couldn't find class Swc4jAstUsingDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstUsingDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLjava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstUsingDecl::new");
    let method_get_decls = env
      .get_method_id(
        &class,
        "getDecls",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstUsingDecl.getDecls");
    let method_is_await = env
      .get_method_id(
        &class,
        "isAwait",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstUsingDecl.isAwait");
    JavaSwc4jAstUsingDecl {
      class,
      method_construct,
      method_get_decls,
      method_is_await,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    is_await: bool,
    decls: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let is_await = boolean_to_jvalue!(is_await);
    let decls = object_to_jvalue!(decls);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[is_await, decls, span],
        "Swc4jAstUsingDecl construct()"
      );
    return_value
  }

  pub fn get_decls<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decls,
        &[],
        "List get_decls()"
      );
    return_value
  }

  pub fn is_await<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_await,
        &[],
        "boolean is_await()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstVarDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decls: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstVarDecl {}
unsafe impl Sync for JavaSwc4jAstVarDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstVarDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstVarDecl")
      .expect("Couldn't find class Swc4jAstVarDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstVarDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstVarDeclKind;ZLjava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstVarDecl::new");
    let method_get_decls = env
      .get_method_id(
        &class,
        "getDecls",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstVarDecl.getDecls");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstVarDecl.isDeclare");
    JavaSwc4jAstVarDecl {
      class,
      method_construct,
      method_get_decls,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    kind: &JObject<'_>,
    declare: bool,
    decls: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let kind = object_to_jvalue!(kind);
    let declare = boolean_to_jvalue!(declare);
    let decls = object_to_jvalue!(decls);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[kind, declare, decls, span],
        "Swc4jAstVarDecl construct()"
      );
    return_value
  }

  pub fn get_decls<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decls,
        &[],
        "List get_decls()"
      );
    return_value
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstVarDeclarator {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_init: JMethodID,
  method_get_name: JMethodID,
  method_is_definite: JMethodID,
}
unsafe impl Send for JavaSwc4jAstVarDeclarator {}
unsafe impl Sync for JavaSwc4jAstVarDeclarator {}

#[allow(dead_code)]
impl JavaSwc4jAstVarDeclarator {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstVarDeclarator")
      .expect("Couldn't find class Swc4jAstVarDeclarator");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstVarDeclarator");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator::new");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator.getInit");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator.getName");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator.isDefinite");
    JavaSwc4jAstVarDeclarator {
      class,
      method_construct,
      method_get_init,
      method_get_name,
      method_is_definite,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    init: &Option<JObject>,
    definite: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let init = optional_object_to_jvalue!(init);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, init, definite, span],
        "Swc4jAstVarDeclarator construct()"
      );
    return_value
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      );
    return_value
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstPat get_name()"
      );
    return_value
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstWhileStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstWhileStmt {}
unsafe impl Sync for JavaSwc4jAstWhileStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstWhileStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstWhileStmt")
      .expect("Couldn't find class Swc4jAstWhileStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstWhileStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstWhileStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstWhileStmt.getBody");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstWhileStmt.getTest");
    JavaSwc4jAstWhileStmt {
      class,
      method_construct,
      method_get_body,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, body, span],
        "Swc4jAstWhileStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstWithStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_obj: JMethodID,
}
unsafe impl Send for JavaSwc4jAstWithStmt {}
unsafe impl Sync for JavaSwc4jAstWithStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstWithStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstWithStmt")
      .expect("Couldn't find class Swc4jAstWithStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstWithStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstWithStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstWithStmt.getBody");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstWithStmt.getObj");
    JavaSwc4jAstWithStmt {
      class,
      method_construct,
      method_get_body,
      method_get_obj,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, body, span],
        "Swc4jAstWithStmt construct()"
      );
    return_value
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      );
    return_value
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "ISwc4jAstExpr get_obj()"
      );
    return_value
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstYieldExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_is_delegate: JMethodID,
}
unsafe impl Send for JavaSwc4jAstYieldExpr {}
unsafe impl Sync for JavaSwc4jAstYieldExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstYieldExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstYieldExpr")
      .expect("Couldn't find class Swc4jAstYieldExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstYieldExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstYieldExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstYieldExpr.getArg");
    let method_is_delegate = env
      .get_method_id(
        &class,
        "isDelegate",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstYieldExpr.isDelegate");
    JavaSwc4jAstYieldExpr {
      class,
      method_construct,
      method_get_arg,
      method_is_delegate,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &Option<JObject>,
    delegate: bool,
    span: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let arg = optional_object_to_jvalue!(arg);
    let delegate = boolean_to_jvalue!(delegate);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, delegate, span],
        "Swc4jAstYieldExpr construct()"
      );
    return_value
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> JObject<'a>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "Optional get_arg()"
      );
    return_value
  }

  pub fn is_delegate<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> bool
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_delegate,
        &[],
        "boolean is_delegate()"
      );
    return_value
  }
}

static mut JAVA_CLASS_ARRAY_LIT: Option<JavaSwc4jAstArrayLit> = None;
static mut JAVA_CLASS_ARRAY_PAT: Option<JavaSwc4jAstArrayPat> = None;
static mut JAVA_CLASS_ARROW_EXPR: Option<JavaSwc4jAstArrowExpr> = None;
static mut JAVA_CLASS_ASSIGN_EXPR: Option<JavaSwc4jAstAssignExpr> = None;
static mut JAVA_CLASS_ASSIGN_PAT: Option<JavaSwc4jAstAssignPat> = None;
static mut JAVA_CLASS_ASSIGN_PAT_PROP: Option<JavaSwc4jAstAssignPatProp> = None;
static mut JAVA_CLASS_ASSIGN_PROP: Option<JavaSwc4jAstAssignProp> = None;
static mut JAVA_CLASS_AUTO_ACCESSOR: Option<JavaSwc4jAstAutoAccessor> = None;
static mut JAVA_CLASS_AWAIT_EXPR: Option<JavaSwc4jAstAwaitExpr> = None;
static mut JAVA_CLASS_BIG_INT: Option<JavaSwc4jAstBigInt> = None;
static mut JAVA_CLASS_BIN_EXPR: Option<JavaSwc4jAstBinExpr> = None;
static mut JAVA_CLASS_BINDING_IDENT: Option<JavaSwc4jAstBindingIdent> = None;
static mut JAVA_CLASS_BLOCK_STMT: Option<JavaSwc4jAstBlockStmt> = None;
static mut JAVA_CLASS_BOOL: Option<JavaSwc4jAstBool> = None;
static mut JAVA_CLASS_BREAK_STMT: Option<JavaSwc4jAstBreakStmt> = None;
static mut JAVA_CLASS_CALL_EXPR: Option<JavaSwc4jAstCallExpr> = None;
static mut JAVA_CLASS_CATCH_CLAUSE: Option<JavaSwc4jAstCatchClause> = None;
static mut JAVA_CLASS_CLASS: Option<JavaSwc4jAstClass> = None;
static mut JAVA_CLASS_CLASS_DECL: Option<JavaSwc4jAstClassDecl> = None;
static mut JAVA_CLASS_CLASS_EXPR: Option<JavaSwc4jAstClassExpr> = None;
static mut JAVA_CLASS_CLASS_METHOD: Option<JavaSwc4jAstClassMethod> = None;
static mut JAVA_CLASS_CLASS_PROP: Option<JavaSwc4jAstClassProp> = None;
static mut JAVA_CLASS_COMPUTED_PROP_NAME: Option<JavaSwc4jAstComputedPropName> = None;
static mut JAVA_CLASS_COND_EXPR: Option<JavaSwc4jAstCondExpr> = None;
static mut JAVA_CLASS_CONSTRUCTOR: Option<JavaSwc4jAstConstructor> = None;
static mut JAVA_CLASS_CONTINUE_STMT: Option<JavaSwc4jAstContinueStmt> = None;
static mut JAVA_CLASS_DEBUGGER_STMT: Option<JavaSwc4jAstDebuggerStmt> = None;
static mut JAVA_CLASS_DECORATOR: Option<JavaSwc4jAstDecorator> = None;
static mut JAVA_CLASS_DO_WHILE_STMT: Option<JavaSwc4jAstDoWhileStmt> = None;
static mut JAVA_CLASS_EMPTY_STMT: Option<JavaSwc4jAstEmptyStmt> = None;
static mut JAVA_CLASS_EXPORT_ALL: Option<JavaSwc4jAstExportAll> = None;
static mut JAVA_CLASS_EXPORT_DECL: Option<JavaSwc4jAstExportDecl> = None;
static mut JAVA_CLASS_EXPORT_DEFAULT_DECL: Option<JavaSwc4jAstExportDefaultDecl> = None;
static mut JAVA_CLASS_EXPORT_DEFAULT_EXPR: Option<JavaSwc4jAstExportDefaultExpr> = None;
static mut JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER: Option<JavaSwc4jAstExportDefaultSpecifier> = None;
static mut JAVA_CLASS_EXPORT_NAMED_SPECIFIER: Option<JavaSwc4jAstExportNamedSpecifier> = None;
static mut JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER: Option<JavaSwc4jAstExportNamespaceSpecifier> = None;
static mut JAVA_CLASS_EXPR_OR_SPREAD: Option<JavaSwc4jAstExprOrSpread> = None;
static mut JAVA_CLASS_EXPR_STMT: Option<JavaSwc4jAstExprStmt> = None;
static mut JAVA_CLASS_FN_DECL: Option<JavaSwc4jAstFnDecl> = None;
static mut JAVA_CLASS_FN_EXPR: Option<JavaSwc4jAstFnExpr> = None;
static mut JAVA_CLASS_FOR_IN_STMT: Option<JavaSwc4jAstForInStmt> = None;
static mut JAVA_CLASS_FOR_OF_STMT: Option<JavaSwc4jAstForOfStmt> = None;
static mut JAVA_CLASS_FOR_STMT: Option<JavaSwc4jAstForStmt> = None;
static mut JAVA_CLASS_FUNCTION: Option<JavaSwc4jAstFunction> = None;
static mut JAVA_CLASS_GETTER_PROP: Option<JavaSwc4jAstGetterProp> = None;
static mut JAVA_CLASS_IDENT: Option<JavaSwc4jAstIdent> = None;
static mut JAVA_CLASS_IF_STMT: Option<JavaSwc4jAstIfStmt> = None;
static mut JAVA_CLASS_IMPORT: Option<JavaSwc4jAstImport> = None;
static mut JAVA_CLASS_IMPORT_DECL: Option<JavaSwc4jAstImportDecl> = None;
static mut JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER: Option<JavaSwc4jAstImportDefaultSpecifier> = None;
static mut JAVA_CLASS_IMPORT_NAMED_SPECIFIER: Option<JavaSwc4jAstImportNamedSpecifier> = None;
static mut JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER: Option<JavaSwc4jAstImportStarAsSpecifier> = None;
static mut JAVA_CLASS_INVALID: Option<JavaSwc4jAstInvalid> = None;
static mut JAVA_CLASS_JSX_ATTR: Option<JavaSwc4jAstJsxAttr> = None;
static mut JAVA_CLASS_JSX_CLOSING_ELEMENT: Option<JavaSwc4jAstJsxClosingElement> = None;
static mut JAVA_CLASS_JSX_CLOSING_FRAGMENT: Option<JavaSwc4jAstJsxClosingFragment> = None;
static mut JAVA_CLASS_JSX_ELEMENT: Option<JavaSwc4jAstJsxElement> = None;
static mut JAVA_CLASS_JSX_EMPTY_EXPR: Option<JavaSwc4jAstJsxEmptyExpr> = None;
static mut JAVA_CLASS_JSX_EXPR_CONTAINER: Option<JavaSwc4jAstJsxExprContainer> = None;
static mut JAVA_CLASS_JSX_FRAGMENT: Option<JavaSwc4jAstJsxFragment> = None;
static mut JAVA_CLASS_JSX_MEMBER_EXPR: Option<JavaSwc4jAstJsxMemberExpr> = None;
static mut JAVA_CLASS_JSX_NAMESPACED_NAME: Option<JavaSwc4jAstJsxNamespacedName> = None;
static mut JAVA_CLASS_JSX_OPENING_ELEMENT: Option<JavaSwc4jAstJsxOpeningElement> = None;
static mut JAVA_CLASS_JSX_OPENING_FRAGMENT: Option<JavaSwc4jAstJsxOpeningFragment> = None;
static mut JAVA_CLASS_JSX_SPREAD_CHILD: Option<JavaSwc4jAstJsxSpreadChild> = None;
static mut JAVA_CLASS_JSX_TEXT: Option<JavaSwc4jAstJsxText> = None;
static mut JAVA_CLASS_KEY_VALUE_PAT_PROP: Option<JavaSwc4jAstKeyValuePatProp> = None;
static mut JAVA_CLASS_KEY_VALUE_PROP: Option<JavaSwc4jAstKeyValueProp> = None;
static mut JAVA_CLASS_LABELED_STMT: Option<JavaSwc4jAstLabeledStmt> = None;
static mut JAVA_CLASS_MEMBER_EXPR: Option<JavaSwc4jAstMemberExpr> = None;
static mut JAVA_CLASS_META_PROP_EXPR: Option<JavaSwc4jAstMetaPropExpr> = None;
static mut JAVA_CLASS_METHOD_PROP: Option<JavaSwc4jAstMethodProp> = None;
static mut JAVA_CLASS_MODULE: Option<JavaSwc4jAstModule> = None;
static mut JAVA_CLASS_NAMED_EXPORT: Option<JavaSwc4jAstNamedExport> = None;
static mut JAVA_CLASS_NEW_EXPR: Option<JavaSwc4jAstNewExpr> = None;
static mut JAVA_CLASS_NULL: Option<JavaSwc4jAstNull> = None;
static mut JAVA_CLASS_NUMBER: Option<JavaSwc4jAstNumber> = None;
static mut JAVA_CLASS_OBJECT_LIT: Option<JavaSwc4jAstObjectLit> = None;
static mut JAVA_CLASS_OBJECT_PAT: Option<JavaSwc4jAstObjectPat> = None;
static mut JAVA_CLASS_OPT_CALL: Option<JavaSwc4jAstOptCall> = None;
static mut JAVA_CLASS_OPT_CHAIN_EXPR: Option<JavaSwc4jAstOptChainExpr> = None;
static mut JAVA_CLASS_PARAM: Option<JavaSwc4jAstParam> = None;
static mut JAVA_CLASS_PAREN_EXPR: Option<JavaSwc4jAstParenExpr> = None;
static mut JAVA_CLASS_PRIVATE_METHOD: Option<JavaSwc4jAstPrivateMethod> = None;
static mut JAVA_CLASS_PRIVATE_NAME: Option<JavaSwc4jAstPrivateName> = None;
static mut JAVA_CLASS_PRIVATE_PROP: Option<JavaSwc4jAstPrivateProp> = None;
static mut JAVA_CLASS_REGEX: Option<JavaSwc4jAstRegex> = None;
static mut JAVA_CLASS_REST_PAT: Option<JavaSwc4jAstRestPat> = None;
static mut JAVA_CLASS_RETURN_STMT: Option<JavaSwc4jAstReturnStmt> = None;
static mut JAVA_CLASS_SCRIPT: Option<JavaSwc4jAstScript> = None;
static mut JAVA_CLASS_SEQ_EXPR: Option<JavaSwc4jAstSeqExpr> = None;
static mut JAVA_CLASS_SETTER_PROP: Option<JavaSwc4jAstSetterProp> = None;
static mut JAVA_CLASS_SPREAD_ELEMENT: Option<JavaSwc4jAstSpreadElement> = None;
static mut JAVA_CLASS_STATIC_BLOCK: Option<JavaSwc4jAstStaticBlock> = None;
static mut JAVA_CLASS_STR: Option<JavaSwc4jAstStr> = None;
static mut JAVA_CLASS_SUPER: Option<JavaSwc4jAstSuper> = None;
static mut JAVA_CLASS_SUPER_PROP_EXPR: Option<JavaSwc4jAstSuperPropExpr> = None;
static mut JAVA_CLASS_SWITCH_CASE: Option<JavaSwc4jAstSwitchCase> = None;
static mut JAVA_CLASS_SWITCH_STMT: Option<JavaSwc4jAstSwitchStmt> = None;
static mut JAVA_CLASS_TAGGED_TPL: Option<JavaSwc4jAstTaggedTpl> = None;
static mut JAVA_CLASS_THIS_EXPR: Option<JavaSwc4jAstThisExpr> = None;
static mut JAVA_CLASS_THROW_STMT: Option<JavaSwc4jAstThrowStmt> = None;
static mut JAVA_CLASS_TPL: Option<JavaSwc4jAstTpl> = None;
static mut JAVA_CLASS_TPL_ELEMENT: Option<JavaSwc4jAstTplElement> = None;
static mut JAVA_CLASS_TRY_STMT: Option<JavaSwc4jAstTryStmt> = None;
static mut JAVA_CLASS_TS_ARRAY_TYPE: Option<JavaSwc4jAstTsArrayType> = None;
static mut JAVA_CLASS_TS_AS_EXPR: Option<JavaSwc4jAstTsAsExpr> = None;
static mut JAVA_CLASS_TS_CALL_SIGNATURE_DECL: Option<JavaSwc4jAstTsCallSignatureDecl> = None;
static mut JAVA_CLASS_TS_CONDITIONAL_TYPE: Option<JavaSwc4jAstTsConditionalType> = None;
static mut JAVA_CLASS_TS_CONST_ASSERTION: Option<JavaSwc4jAstTsConstAssertion> = None;
static mut JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL: Option<JavaSwc4jAstTsConstructSignatureDecl> = None;
static mut JAVA_CLASS_TS_CONSTRUCTOR_TYPE: Option<JavaSwc4jAstTsConstructorType> = None;
static mut JAVA_CLASS_TS_ENUM_DECL: Option<JavaSwc4jAstTsEnumDecl> = None;
static mut JAVA_CLASS_TS_ENUM_MEMBER: Option<JavaSwc4jAstTsEnumMember> = None;
static mut JAVA_CLASS_TS_EXPORT_ASSIGNMENT: Option<JavaSwc4jAstTsExportAssignment> = None;
static mut JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS: Option<JavaSwc4jAstTsExprWithTypeArgs> = None;
static mut JAVA_CLASS_TS_EXTERNAL_MODULE_REF: Option<JavaSwc4jAstTsExternalModuleRef> = None;
static mut JAVA_CLASS_TS_FN_TYPE: Option<JavaSwc4jAstTsFnType> = None;
static mut JAVA_CLASS_TS_GETTER_SIGNATURE: Option<JavaSwc4jAstTsGetterSignature> = None;
static mut JAVA_CLASS_TS_IMPORT_EQUALS_DECL: Option<JavaSwc4jAstTsImportEqualsDecl> = None;
static mut JAVA_CLASS_TS_IMPORT_TYPE: Option<JavaSwc4jAstTsImportType> = None;
static mut JAVA_CLASS_TS_INDEX_SIGNATURE: Option<JavaSwc4jAstTsIndexSignature> = None;
static mut JAVA_CLASS_TS_INDEXED_ACCESS_TYPE: Option<JavaSwc4jAstTsIndexedAccessType> = None;
static mut JAVA_CLASS_TS_INFER_TYPE: Option<JavaSwc4jAstTsInferType> = None;
static mut JAVA_CLASS_TS_INSTANTIATION: Option<JavaSwc4jAstTsInstantiation> = None;
static mut JAVA_CLASS_TS_INTERFACE_BODY: Option<JavaSwc4jAstTsInterfaceBody> = None;
static mut JAVA_CLASS_TS_INTERFACE_DECL: Option<JavaSwc4jAstTsInterfaceDecl> = None;
static mut JAVA_CLASS_TS_INTERSECTION_TYPE: Option<JavaSwc4jAstTsIntersectionType> = None;
static mut JAVA_CLASS_TS_KEYWORD_TYPE: Option<JavaSwc4jAstTsKeywordType> = None;
static mut JAVA_CLASS_TS_LIT_TYPE: Option<JavaSwc4jAstTsLitType> = None;
static mut JAVA_CLASS_TS_MAPPED_TYPE: Option<JavaSwc4jAstTsMappedType> = None;
static mut JAVA_CLASS_TS_METHOD_SIGNATURE: Option<JavaSwc4jAstTsMethodSignature> = None;
static mut JAVA_CLASS_TS_MODULE_BLOCK: Option<JavaSwc4jAstTsModuleBlock> = None;
static mut JAVA_CLASS_TS_MODULE_DECL: Option<JavaSwc4jAstTsModuleDecl> = None;
static mut JAVA_CLASS_TS_NAMESPACE_DECL: Option<JavaSwc4jAstTsNamespaceDecl> = None;
static mut JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL: Option<JavaSwc4jAstTsNamespaceExportDecl> = None;
static mut JAVA_CLASS_TS_NON_NULL_EXPR: Option<JavaSwc4jAstTsNonNullExpr> = None;
static mut JAVA_CLASS_TS_OPTIONAL_TYPE: Option<JavaSwc4jAstTsOptionalType> = None;
static mut JAVA_CLASS_TS_PARAM_PROP: Option<JavaSwc4jAstTsParamProp> = None;
static mut JAVA_CLASS_TS_PARENTHESIZED_TYPE: Option<JavaSwc4jAstTsParenthesizedType> = None;
static mut JAVA_CLASS_TS_PROPERTY_SIGNATURE: Option<JavaSwc4jAstTsPropertySignature> = None;
static mut JAVA_CLASS_TS_QUALIFIED_NAME: Option<JavaSwc4jAstTsQualifiedName> = None;
static mut JAVA_CLASS_TS_REST_TYPE: Option<JavaSwc4jAstTsRestType> = None;
static mut JAVA_CLASS_TS_SATISFIES_EXPR: Option<JavaSwc4jAstTsSatisfiesExpr> = None;
static mut JAVA_CLASS_TS_SETTER_SIGNATURE: Option<JavaSwc4jAstTsSetterSignature> = None;
static mut JAVA_CLASS_TS_THIS_TYPE: Option<JavaSwc4jAstTsThisType> = None;
static mut JAVA_CLASS_TS_TPL_LIT_TYPE: Option<JavaSwc4jAstTsTplLitType> = None;
static mut JAVA_CLASS_TS_TUPLE_ELEMENT: Option<JavaSwc4jAstTsTupleElement> = None;
static mut JAVA_CLASS_TS_TUPLE_TYPE: Option<JavaSwc4jAstTsTupleType> = None;
static mut JAVA_CLASS_TS_TYPE_ALIAS_DECL: Option<JavaSwc4jAstTsTypeAliasDecl> = None;
static mut JAVA_CLASS_TS_TYPE_ANN: Option<JavaSwc4jAstTsTypeAnn> = None;
static mut JAVA_CLASS_TS_TYPE_ASSERTION: Option<JavaSwc4jAstTsTypeAssertion> = None;
static mut JAVA_CLASS_TS_TYPE_LIT: Option<JavaSwc4jAstTsTypeLit> = None;
static mut JAVA_CLASS_TS_TYPE_OPERATOR: Option<JavaSwc4jAstTsTypeOperator> = None;
static mut JAVA_CLASS_TS_TYPE_PARAM: Option<JavaSwc4jAstTsTypeParam> = None;
static mut JAVA_CLASS_TS_TYPE_PARAM_DECL: Option<JavaSwc4jAstTsTypeParamDecl> = None;
static mut JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION: Option<JavaSwc4jAstTsTypeParamInstantiation> = None;
static mut JAVA_CLASS_TS_TYPE_PREDICATE: Option<JavaSwc4jAstTsTypePredicate> = None;
static mut JAVA_CLASS_TS_TYPE_QUERY: Option<JavaSwc4jAstTsTypeQuery> = None;
static mut JAVA_CLASS_TS_TYPE_REF: Option<JavaSwc4jAstTsTypeRef> = None;
static mut JAVA_CLASS_TS_UNION_TYPE: Option<JavaSwc4jAstTsUnionType> = None;
static mut JAVA_CLASS_UNARY_EXPR: Option<JavaSwc4jAstUnaryExpr> = None;
static mut JAVA_CLASS_UPDATE_EXPR: Option<JavaSwc4jAstUpdateExpr> = None;
static mut JAVA_CLASS_USING_DECL: Option<JavaSwc4jAstUsingDecl> = None;
static mut JAVA_CLASS_VAR_DECL: Option<JavaSwc4jAstVarDecl> = None;
static mut JAVA_CLASS_VAR_DECLARATOR: Option<JavaSwc4jAstVarDeclarator> = None;
static mut JAVA_CLASS_WHILE_STMT: Option<JavaSwc4jAstWhileStmt> = None;
static mut JAVA_CLASS_WITH_STMT: Option<JavaSwc4jAstWithStmt> = None;
static mut JAVA_CLASS_YIELD_EXPR: Option<JavaSwc4jAstYieldExpr> = None;

pub fn init<'local>(env: &mut JNIEnv<'local>) {
  unsafe {
    JAVA_CLASS_ARRAY_LIT = Some(JavaSwc4jAstArrayLit::new(env));
    JAVA_CLASS_ARRAY_PAT = Some(JavaSwc4jAstArrayPat::new(env));
    JAVA_CLASS_ARROW_EXPR = Some(JavaSwc4jAstArrowExpr::new(env));
    JAVA_CLASS_ASSIGN_EXPR = Some(JavaSwc4jAstAssignExpr::new(env));
    JAVA_CLASS_ASSIGN_PAT = Some(JavaSwc4jAstAssignPat::new(env));
    JAVA_CLASS_ASSIGN_PAT_PROP = Some(JavaSwc4jAstAssignPatProp::new(env));
    JAVA_CLASS_ASSIGN_PROP = Some(JavaSwc4jAstAssignProp::new(env));
    JAVA_CLASS_AUTO_ACCESSOR = Some(JavaSwc4jAstAutoAccessor::new(env));
    JAVA_CLASS_AWAIT_EXPR = Some(JavaSwc4jAstAwaitExpr::new(env));
    JAVA_CLASS_BIG_INT = Some(JavaSwc4jAstBigInt::new(env));
    JAVA_CLASS_BIN_EXPR = Some(JavaSwc4jAstBinExpr::new(env));
    JAVA_CLASS_BINDING_IDENT = Some(JavaSwc4jAstBindingIdent::new(env));
    JAVA_CLASS_BLOCK_STMT = Some(JavaSwc4jAstBlockStmt::new(env));
    JAVA_CLASS_BOOL = Some(JavaSwc4jAstBool::new(env));
    JAVA_CLASS_BREAK_STMT = Some(JavaSwc4jAstBreakStmt::new(env));
    JAVA_CLASS_CALL_EXPR = Some(JavaSwc4jAstCallExpr::new(env));
    JAVA_CLASS_CATCH_CLAUSE = Some(JavaSwc4jAstCatchClause::new(env));
    JAVA_CLASS_CLASS = Some(JavaSwc4jAstClass::new(env));
    JAVA_CLASS_CLASS_DECL = Some(JavaSwc4jAstClassDecl::new(env));
    JAVA_CLASS_CLASS_EXPR = Some(JavaSwc4jAstClassExpr::new(env));
    JAVA_CLASS_CLASS_METHOD = Some(JavaSwc4jAstClassMethod::new(env));
    JAVA_CLASS_CLASS_PROP = Some(JavaSwc4jAstClassProp::new(env));
    JAVA_CLASS_COMPUTED_PROP_NAME = Some(JavaSwc4jAstComputedPropName::new(env));
    JAVA_CLASS_COND_EXPR = Some(JavaSwc4jAstCondExpr::new(env));
    JAVA_CLASS_CONSTRUCTOR = Some(JavaSwc4jAstConstructor::new(env));
    JAVA_CLASS_CONTINUE_STMT = Some(JavaSwc4jAstContinueStmt::new(env));
    JAVA_CLASS_DEBUGGER_STMT = Some(JavaSwc4jAstDebuggerStmt::new(env));
    JAVA_CLASS_DECORATOR = Some(JavaSwc4jAstDecorator::new(env));
    JAVA_CLASS_DO_WHILE_STMT = Some(JavaSwc4jAstDoWhileStmt::new(env));
    JAVA_CLASS_EMPTY_STMT = Some(JavaSwc4jAstEmptyStmt::new(env));
    JAVA_CLASS_EXPORT_ALL = Some(JavaSwc4jAstExportAll::new(env));
    JAVA_CLASS_EXPORT_DECL = Some(JavaSwc4jAstExportDecl::new(env));
    JAVA_CLASS_EXPORT_DEFAULT_DECL = Some(JavaSwc4jAstExportDefaultDecl::new(env));
    JAVA_CLASS_EXPORT_DEFAULT_EXPR = Some(JavaSwc4jAstExportDefaultExpr::new(env));
    JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER = Some(JavaSwc4jAstExportDefaultSpecifier::new(env));
    JAVA_CLASS_EXPORT_NAMED_SPECIFIER = Some(JavaSwc4jAstExportNamedSpecifier::new(env));
    JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER = Some(JavaSwc4jAstExportNamespaceSpecifier::new(env));
    JAVA_CLASS_EXPR_OR_SPREAD = Some(JavaSwc4jAstExprOrSpread::new(env));
    JAVA_CLASS_EXPR_STMT = Some(JavaSwc4jAstExprStmt::new(env));
    JAVA_CLASS_FN_DECL = Some(JavaSwc4jAstFnDecl::new(env));
    JAVA_CLASS_FN_EXPR = Some(JavaSwc4jAstFnExpr::new(env));
    JAVA_CLASS_FOR_IN_STMT = Some(JavaSwc4jAstForInStmt::new(env));
    JAVA_CLASS_FOR_OF_STMT = Some(JavaSwc4jAstForOfStmt::new(env));
    JAVA_CLASS_FOR_STMT = Some(JavaSwc4jAstForStmt::new(env));
    JAVA_CLASS_FUNCTION = Some(JavaSwc4jAstFunction::new(env));
    JAVA_CLASS_GETTER_PROP = Some(JavaSwc4jAstGetterProp::new(env));
    JAVA_CLASS_IDENT = Some(JavaSwc4jAstIdent::new(env));
    JAVA_CLASS_IF_STMT = Some(JavaSwc4jAstIfStmt::new(env));
    JAVA_CLASS_IMPORT = Some(JavaSwc4jAstImport::new(env));
    JAVA_CLASS_IMPORT_DECL = Some(JavaSwc4jAstImportDecl::new(env));
    JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER = Some(JavaSwc4jAstImportDefaultSpecifier::new(env));
    JAVA_CLASS_IMPORT_NAMED_SPECIFIER = Some(JavaSwc4jAstImportNamedSpecifier::new(env));
    JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER = Some(JavaSwc4jAstImportStarAsSpecifier::new(env));
    JAVA_CLASS_INVALID = Some(JavaSwc4jAstInvalid::new(env));
    JAVA_CLASS_JSX_ATTR = Some(JavaSwc4jAstJsxAttr::new(env));
    JAVA_CLASS_JSX_CLOSING_ELEMENT = Some(JavaSwc4jAstJsxClosingElement::new(env));
    JAVA_CLASS_JSX_CLOSING_FRAGMENT = Some(JavaSwc4jAstJsxClosingFragment::new(env));
    JAVA_CLASS_JSX_ELEMENT = Some(JavaSwc4jAstJsxElement::new(env));
    JAVA_CLASS_JSX_EMPTY_EXPR = Some(JavaSwc4jAstJsxEmptyExpr::new(env));
    JAVA_CLASS_JSX_EXPR_CONTAINER = Some(JavaSwc4jAstJsxExprContainer::new(env));
    JAVA_CLASS_JSX_FRAGMENT = Some(JavaSwc4jAstJsxFragment::new(env));
    JAVA_CLASS_JSX_MEMBER_EXPR = Some(JavaSwc4jAstJsxMemberExpr::new(env));
    JAVA_CLASS_JSX_NAMESPACED_NAME = Some(JavaSwc4jAstJsxNamespacedName::new(env));
    JAVA_CLASS_JSX_OPENING_ELEMENT = Some(JavaSwc4jAstJsxOpeningElement::new(env));
    JAVA_CLASS_JSX_OPENING_FRAGMENT = Some(JavaSwc4jAstJsxOpeningFragment::new(env));
    JAVA_CLASS_JSX_SPREAD_CHILD = Some(JavaSwc4jAstJsxSpreadChild::new(env));
    JAVA_CLASS_JSX_TEXT = Some(JavaSwc4jAstJsxText::new(env));
    JAVA_CLASS_KEY_VALUE_PAT_PROP = Some(JavaSwc4jAstKeyValuePatProp::new(env));
    JAVA_CLASS_KEY_VALUE_PROP = Some(JavaSwc4jAstKeyValueProp::new(env));
    JAVA_CLASS_LABELED_STMT = Some(JavaSwc4jAstLabeledStmt::new(env));
    JAVA_CLASS_MEMBER_EXPR = Some(JavaSwc4jAstMemberExpr::new(env));
    JAVA_CLASS_META_PROP_EXPR = Some(JavaSwc4jAstMetaPropExpr::new(env));
    JAVA_CLASS_METHOD_PROP = Some(JavaSwc4jAstMethodProp::new(env));
    JAVA_CLASS_MODULE = Some(JavaSwc4jAstModule::new(env));
    JAVA_CLASS_NAMED_EXPORT = Some(JavaSwc4jAstNamedExport::new(env));
    JAVA_CLASS_NEW_EXPR = Some(JavaSwc4jAstNewExpr::new(env));
    JAVA_CLASS_NULL = Some(JavaSwc4jAstNull::new(env));
    JAVA_CLASS_NUMBER = Some(JavaSwc4jAstNumber::new(env));
    JAVA_CLASS_OBJECT_LIT = Some(JavaSwc4jAstObjectLit::new(env));
    JAVA_CLASS_OBJECT_PAT = Some(JavaSwc4jAstObjectPat::new(env));
    JAVA_CLASS_OPT_CALL = Some(JavaSwc4jAstOptCall::new(env));
    JAVA_CLASS_OPT_CHAIN_EXPR = Some(JavaSwc4jAstOptChainExpr::new(env));
    JAVA_CLASS_PARAM = Some(JavaSwc4jAstParam::new(env));
    JAVA_CLASS_PAREN_EXPR = Some(JavaSwc4jAstParenExpr::new(env));
    JAVA_CLASS_PRIVATE_METHOD = Some(JavaSwc4jAstPrivateMethod::new(env));
    JAVA_CLASS_PRIVATE_NAME = Some(JavaSwc4jAstPrivateName::new(env));
    JAVA_CLASS_PRIVATE_PROP = Some(JavaSwc4jAstPrivateProp::new(env));
    JAVA_CLASS_REGEX = Some(JavaSwc4jAstRegex::new(env));
    JAVA_CLASS_REST_PAT = Some(JavaSwc4jAstRestPat::new(env));
    JAVA_CLASS_RETURN_STMT = Some(JavaSwc4jAstReturnStmt::new(env));
    JAVA_CLASS_SCRIPT = Some(JavaSwc4jAstScript::new(env));
    JAVA_CLASS_SEQ_EXPR = Some(JavaSwc4jAstSeqExpr::new(env));
    JAVA_CLASS_SETTER_PROP = Some(JavaSwc4jAstSetterProp::new(env));
    JAVA_CLASS_SPREAD_ELEMENT = Some(JavaSwc4jAstSpreadElement::new(env));
    JAVA_CLASS_STATIC_BLOCK = Some(JavaSwc4jAstStaticBlock::new(env));
    JAVA_CLASS_STR = Some(JavaSwc4jAstStr::new(env));
    JAVA_CLASS_SUPER = Some(JavaSwc4jAstSuper::new(env));
    JAVA_CLASS_SUPER_PROP_EXPR = Some(JavaSwc4jAstSuperPropExpr::new(env));
    JAVA_CLASS_SWITCH_CASE = Some(JavaSwc4jAstSwitchCase::new(env));
    JAVA_CLASS_SWITCH_STMT = Some(JavaSwc4jAstSwitchStmt::new(env));
    JAVA_CLASS_TAGGED_TPL = Some(JavaSwc4jAstTaggedTpl::new(env));
    JAVA_CLASS_THIS_EXPR = Some(JavaSwc4jAstThisExpr::new(env));
    JAVA_CLASS_THROW_STMT = Some(JavaSwc4jAstThrowStmt::new(env));
    JAVA_CLASS_TPL = Some(JavaSwc4jAstTpl::new(env));
    JAVA_CLASS_TPL_ELEMENT = Some(JavaSwc4jAstTplElement::new(env));
    JAVA_CLASS_TRY_STMT = Some(JavaSwc4jAstTryStmt::new(env));
    JAVA_CLASS_TS_ARRAY_TYPE = Some(JavaSwc4jAstTsArrayType::new(env));
    JAVA_CLASS_TS_AS_EXPR = Some(JavaSwc4jAstTsAsExpr::new(env));
    JAVA_CLASS_TS_CALL_SIGNATURE_DECL = Some(JavaSwc4jAstTsCallSignatureDecl::new(env));
    JAVA_CLASS_TS_CONDITIONAL_TYPE = Some(JavaSwc4jAstTsConditionalType::new(env));
    JAVA_CLASS_TS_CONST_ASSERTION = Some(JavaSwc4jAstTsConstAssertion::new(env));
    JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL = Some(JavaSwc4jAstTsConstructSignatureDecl::new(env));
    JAVA_CLASS_TS_CONSTRUCTOR_TYPE = Some(JavaSwc4jAstTsConstructorType::new(env));
    JAVA_CLASS_TS_ENUM_DECL = Some(JavaSwc4jAstTsEnumDecl::new(env));
    JAVA_CLASS_TS_ENUM_MEMBER = Some(JavaSwc4jAstTsEnumMember::new(env));
    JAVA_CLASS_TS_EXPORT_ASSIGNMENT = Some(JavaSwc4jAstTsExportAssignment::new(env));
    JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS = Some(JavaSwc4jAstTsExprWithTypeArgs::new(env));
    JAVA_CLASS_TS_EXTERNAL_MODULE_REF = Some(JavaSwc4jAstTsExternalModuleRef::new(env));
    JAVA_CLASS_TS_FN_TYPE = Some(JavaSwc4jAstTsFnType::new(env));
    JAVA_CLASS_TS_GETTER_SIGNATURE = Some(JavaSwc4jAstTsGetterSignature::new(env));
    JAVA_CLASS_TS_IMPORT_EQUALS_DECL = Some(JavaSwc4jAstTsImportEqualsDecl::new(env));
    JAVA_CLASS_TS_IMPORT_TYPE = Some(JavaSwc4jAstTsImportType::new(env));
    JAVA_CLASS_TS_INDEX_SIGNATURE = Some(JavaSwc4jAstTsIndexSignature::new(env));
    JAVA_CLASS_TS_INDEXED_ACCESS_TYPE = Some(JavaSwc4jAstTsIndexedAccessType::new(env));
    JAVA_CLASS_TS_INFER_TYPE = Some(JavaSwc4jAstTsInferType::new(env));
    JAVA_CLASS_TS_INSTANTIATION = Some(JavaSwc4jAstTsInstantiation::new(env));
    JAVA_CLASS_TS_INTERFACE_BODY = Some(JavaSwc4jAstTsInterfaceBody::new(env));
    JAVA_CLASS_TS_INTERFACE_DECL = Some(JavaSwc4jAstTsInterfaceDecl::new(env));
    JAVA_CLASS_TS_INTERSECTION_TYPE = Some(JavaSwc4jAstTsIntersectionType::new(env));
    JAVA_CLASS_TS_KEYWORD_TYPE = Some(JavaSwc4jAstTsKeywordType::new(env));
    JAVA_CLASS_TS_LIT_TYPE = Some(JavaSwc4jAstTsLitType::new(env));
    JAVA_CLASS_TS_MAPPED_TYPE = Some(JavaSwc4jAstTsMappedType::new(env));
    JAVA_CLASS_TS_METHOD_SIGNATURE = Some(JavaSwc4jAstTsMethodSignature::new(env));
    JAVA_CLASS_TS_MODULE_BLOCK = Some(JavaSwc4jAstTsModuleBlock::new(env));
    JAVA_CLASS_TS_MODULE_DECL = Some(JavaSwc4jAstTsModuleDecl::new(env));
    JAVA_CLASS_TS_NAMESPACE_DECL = Some(JavaSwc4jAstTsNamespaceDecl::new(env));
    JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL = Some(JavaSwc4jAstTsNamespaceExportDecl::new(env));
    JAVA_CLASS_TS_NON_NULL_EXPR = Some(JavaSwc4jAstTsNonNullExpr::new(env));
    JAVA_CLASS_TS_OPTIONAL_TYPE = Some(JavaSwc4jAstTsOptionalType::new(env));
    JAVA_CLASS_TS_PARAM_PROP = Some(JavaSwc4jAstTsParamProp::new(env));
    JAVA_CLASS_TS_PARENTHESIZED_TYPE = Some(JavaSwc4jAstTsParenthesizedType::new(env));
    JAVA_CLASS_TS_PROPERTY_SIGNATURE = Some(JavaSwc4jAstTsPropertySignature::new(env));
    JAVA_CLASS_TS_QUALIFIED_NAME = Some(JavaSwc4jAstTsQualifiedName::new(env));
    JAVA_CLASS_TS_REST_TYPE = Some(JavaSwc4jAstTsRestType::new(env));
    JAVA_CLASS_TS_SATISFIES_EXPR = Some(JavaSwc4jAstTsSatisfiesExpr::new(env));
    JAVA_CLASS_TS_SETTER_SIGNATURE = Some(JavaSwc4jAstTsSetterSignature::new(env));
    JAVA_CLASS_TS_THIS_TYPE = Some(JavaSwc4jAstTsThisType::new(env));
    JAVA_CLASS_TS_TPL_LIT_TYPE = Some(JavaSwc4jAstTsTplLitType::new(env));
    JAVA_CLASS_TS_TUPLE_ELEMENT = Some(JavaSwc4jAstTsTupleElement::new(env));
    JAVA_CLASS_TS_TUPLE_TYPE = Some(JavaSwc4jAstTsTupleType::new(env));
    JAVA_CLASS_TS_TYPE_ALIAS_DECL = Some(JavaSwc4jAstTsTypeAliasDecl::new(env));
    JAVA_CLASS_TS_TYPE_ANN = Some(JavaSwc4jAstTsTypeAnn::new(env));
    JAVA_CLASS_TS_TYPE_ASSERTION = Some(JavaSwc4jAstTsTypeAssertion::new(env));
    JAVA_CLASS_TS_TYPE_LIT = Some(JavaSwc4jAstTsTypeLit::new(env));
    JAVA_CLASS_TS_TYPE_OPERATOR = Some(JavaSwc4jAstTsTypeOperator::new(env));
    JAVA_CLASS_TS_TYPE_PARAM = Some(JavaSwc4jAstTsTypeParam::new(env));
    JAVA_CLASS_TS_TYPE_PARAM_DECL = Some(JavaSwc4jAstTsTypeParamDecl::new(env));
    JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION = Some(JavaSwc4jAstTsTypeParamInstantiation::new(env));
    JAVA_CLASS_TS_TYPE_PREDICATE = Some(JavaSwc4jAstTsTypePredicate::new(env));
    JAVA_CLASS_TS_TYPE_QUERY = Some(JavaSwc4jAstTsTypeQuery::new(env));
    JAVA_CLASS_TS_TYPE_REF = Some(JavaSwc4jAstTsTypeRef::new(env));
    JAVA_CLASS_TS_UNION_TYPE = Some(JavaSwc4jAstTsUnionType::new(env));
    JAVA_CLASS_UNARY_EXPR = Some(JavaSwc4jAstUnaryExpr::new(env));
    JAVA_CLASS_UPDATE_EXPR = Some(JavaSwc4jAstUpdateExpr::new(env));
    JAVA_CLASS_USING_DECL = Some(JavaSwc4jAstUsingDecl::new(env));
    JAVA_CLASS_VAR_DECL = Some(JavaSwc4jAstVarDecl::new(env));
    JAVA_CLASS_VAR_DECLARATOR = Some(JavaSwc4jAstVarDeclarator::new(env));
    JAVA_CLASS_WHILE_STMT = Some(JavaSwc4jAstWhileStmt::new(env));
    JAVA_CLASS_WITH_STMT = Some(JavaSwc4jAstWithStmt::new(env));
    JAVA_CLASS_YIELD_EXPR = Some(JavaSwc4jAstYieldExpr::new(env));
  }
}
/* JNI End */

fn create_big_int<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &BigInt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_sign = node.value.sign().to_java(env);
  let optional_raw = node.raw.as_ref().map(|node| node.as_str().to_owned());
  let return_value =
    unsafe { JAVA_CLASS_BIG_INT.as_ref().unwrap() }.construct(env, &java_sign, &optional_raw, &java_span_ex);
  delete_local_ref!(env, java_sign);
  delete_local_ref!(env, java_span_ex);
  return_value
}

/* Enum Begin */
fn enum_register_assign_target(map: &mut ByteToIndexMap, node: &AssignTarget) {
  match node {
    AssignTarget::Pat(node) => enum_register_assign_target_pat(map, node),
    AssignTarget::Simple(node) => enum_register_simple_assign_target(map, node),
  }
}

fn enum_create_assign_target<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &AssignTarget,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    AssignTarget::Pat(node) => enum_create_assign_target_pat(env, map, node),
    AssignTarget::Simple(node) => enum_create_simple_assign_target(env, map, node),
  }
}

fn enum_register_assign_target_pat(map: &mut ByteToIndexMap, node: &AssignTargetPat) {
  match node {
    AssignTargetPat::Array(node) => register_array_pat(map, node),
    AssignTargetPat::Invalid(node) => register_invalid(map, node),
    AssignTargetPat::Object(node) => register_object_pat(map, node),
  }
}

fn enum_create_assign_target_pat<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &AssignTargetPat,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    AssignTargetPat::Array(node) => create_array_pat(env, map, node),
    AssignTargetPat::Invalid(node) => create_invalid(env, map, node),
    AssignTargetPat::Object(node) => create_object_pat(env, map, node),
  }
}

fn enum_register_block_stmt_or_expr(map: &mut ByteToIndexMap, node: &BlockStmtOrExpr) {
  match node {
    BlockStmtOrExpr::BlockStmt(node) => register_block_stmt(map, node),
    BlockStmtOrExpr::Expr(node) => enum_register_expr(map, node),
  }
}

fn enum_create_block_stmt_or_expr<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &BlockStmtOrExpr,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    BlockStmtOrExpr::BlockStmt(node) => create_block_stmt(env, map, node),
    BlockStmtOrExpr::Expr(node) => enum_create_expr(env, map, node),
  }
}

fn enum_register_callee(map: &mut ByteToIndexMap, node: &Callee) {
  match node {
    Callee::Expr(node) => enum_register_expr(map, node),
    Callee::Import(node) => register_import(map, node),
    Callee::Super(node) => register_super(map, node),
  }
}

fn enum_create_callee<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &Callee,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    Callee::Expr(node) => enum_create_expr(env, map, node),
    Callee::Import(node) => create_import(env, map, node),
    Callee::Super(node) => create_super(env, map, node),
  }
}

fn enum_register_class_member(map: &mut ByteToIndexMap, node: &ClassMember) {
  match node {
    ClassMember::AutoAccessor(node) => register_auto_accessor(map, node),
    ClassMember::ClassProp(node) => register_class_prop(map, node),
    ClassMember::Constructor(node) => register_constructor(map, node),
    ClassMember::Empty(node) => register_empty_stmt(map, node),
    ClassMember::Method(node) => register_class_method(map, node),
    ClassMember::PrivateMethod(node) => register_private_method(map, node),
    ClassMember::PrivateProp(node) => register_private_prop(map, node),
    ClassMember::StaticBlock(node) => register_static_block(map, node),
    ClassMember::TsIndexSignature(node) => register_ts_index_signature(map, node),
  }
}

fn enum_create_class_member<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &ClassMember,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    ClassMember::AutoAccessor(node) => create_auto_accessor(env, map, node),
    ClassMember::ClassProp(node) => create_class_prop(env, map, node),
    ClassMember::Constructor(node) => create_constructor(env, map, node),
    ClassMember::Empty(node) => create_empty_stmt(env, map, node),
    ClassMember::Method(node) => create_class_method(env, map, node),
    ClassMember::PrivateMethod(node) => create_private_method(env, map, node),
    ClassMember::PrivateProp(node) => create_private_prop(env, map, node),
    ClassMember::StaticBlock(node) => create_static_block(env, map, node),
    ClassMember::TsIndexSignature(node) => create_ts_index_signature(env, map, node),
  }
}

fn enum_register_decl(map: &mut ByteToIndexMap, node: &Decl) {
  match node {
    Decl::Class(node) => register_class_decl(map, node),
    Decl::Fn(node) => register_fn_decl(map, node),
    Decl::TsEnum(node) => register_ts_enum_decl(map, node),
    Decl::TsInterface(node) => register_ts_interface_decl(map, node),
    Decl::TsModule(node) => register_ts_module_decl(map, node),
    Decl::TsTypeAlias(node) => register_ts_type_alias_decl(map, node),
    Decl::Using(node) => register_using_decl(map, node),
    Decl::Var(node) => register_var_decl(map, node),
  }
}

fn enum_create_decl<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &Decl,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    Decl::Class(node) => create_class_decl(env, map, node),
    Decl::Fn(node) => create_fn_decl(env, map, node),
    Decl::TsEnum(node) => create_ts_enum_decl(env, map, node),
    Decl::TsInterface(node) => create_ts_interface_decl(env, map, node),
    Decl::TsModule(node) => create_ts_module_decl(env, map, node),
    Decl::TsTypeAlias(node) => create_ts_type_alias_decl(env, map, node),
    Decl::Using(node) => create_using_decl(env, map, node),
    Decl::Var(node) => create_var_decl(env, map, node),
  }
}

fn enum_register_default_decl(map: &mut ByteToIndexMap, node: &DefaultDecl) {
  match node {
    DefaultDecl::Class(node) => register_class_expr(map, node),
    DefaultDecl::Fn(node) => register_fn_expr(map, node),
    DefaultDecl::TsInterfaceDecl(node) => register_ts_interface_decl(map, node),
  }
}

fn enum_create_default_decl<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &DefaultDecl,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    DefaultDecl::Class(node) => create_class_expr(env, map, node),
    DefaultDecl::Fn(node) => create_fn_expr(env, map, node),
    DefaultDecl::TsInterfaceDecl(node) => create_ts_interface_decl(env, map, node),
  }
}

fn enum_register_export_specifier(map: &mut ByteToIndexMap, node: &ExportSpecifier) {
  match node {
    ExportSpecifier::Default(node) => register_export_default_specifier(map, node),
    ExportSpecifier::Named(node) => register_export_named_specifier(map, node),
    ExportSpecifier::Namespace(node) => register_export_namespace_specifier(map, node),
  }
}

fn enum_create_export_specifier<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &ExportSpecifier,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    ExportSpecifier::Default(node) => create_export_default_specifier(env, map, node),
    ExportSpecifier::Named(node) => create_export_named_specifier(env, map, node),
    ExportSpecifier::Namespace(node) => create_export_namespace_specifier(env, map, node),
  }
}

fn enum_register_expr(map: &mut ByteToIndexMap, node: &Expr) {
  match node {
    Expr::Array(node) => register_array_lit(map, node),
    Expr::Arrow(node) => register_arrow_expr(map, node),
    Expr::Assign(node) => register_assign_expr(map, node),
    Expr::Await(node) => register_await_expr(map, node),
    Expr::Bin(node) => register_bin_expr(map, node),
    Expr::Call(node) => register_call_expr(map, node),
    Expr::Class(node) => register_class_expr(map, node),
    Expr::Cond(node) => register_cond_expr(map, node),
    Expr::Fn(node) => register_fn_expr(map, node),
    Expr::Ident(node) => register_ident(map, node),
    Expr::Invalid(node) => register_invalid(map, node),
    Expr::JSXElement(node) => register_jsx_element(map, node),
    Expr::JSXEmpty(node) => register_jsx_empty_expr(map, node),
    Expr::JSXFragment(node) => register_jsx_fragment(map, node),
    Expr::JSXMember(node) => register_jsx_member_expr(map, node),
    Expr::JSXNamespacedName(node) => register_jsx_namespaced_name(map, node),
    Expr::Lit(node) => enum_register_lit(map, node),
    Expr::Member(node) => register_member_expr(map, node),
    Expr::MetaProp(node) => register_meta_prop_expr(map, node),
    Expr::New(node) => register_new_expr(map, node),
    Expr::Object(node) => register_object_lit(map, node),
    Expr::OptChain(node) => register_opt_chain_expr(map, node),
    Expr::Paren(node) => register_paren_expr(map, node),
    Expr::PrivateName(node) => register_private_name(map, node),
    Expr::Seq(node) => register_seq_expr(map, node),
    Expr::SuperProp(node) => register_super_prop_expr(map, node),
    Expr::TaggedTpl(node) => register_tagged_tpl(map, node),
    Expr::This(node) => register_this_expr(map, node),
    Expr::Tpl(node) => register_tpl(map, node),
    Expr::TsAs(node) => register_ts_as_expr(map, node),
    Expr::TsConstAssertion(node) => register_ts_const_assertion(map, node),
    Expr::TsInstantiation(node) => register_ts_instantiation(map, node),
    Expr::TsNonNull(node) => register_ts_non_null_expr(map, node),
    Expr::TsSatisfies(node) => register_ts_satisfies_expr(map, node),
    Expr::TsTypeAssertion(node) => register_ts_type_assertion(map, node),
    Expr::Unary(node) => register_unary_expr(map, node),
    Expr::Update(node) => register_update_expr(map, node),
    Expr::Yield(node) => register_yield_expr(map, node),
  }
}

fn enum_create_expr<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &Expr,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    Expr::Array(node) => create_array_lit(env, map, node),
    Expr::Arrow(node) => create_arrow_expr(env, map, node),
    Expr::Assign(node) => create_assign_expr(env, map, node),
    Expr::Await(node) => create_await_expr(env, map, node),
    Expr::Bin(node) => create_bin_expr(env, map, node),
    Expr::Call(node) => create_call_expr(env, map, node),
    Expr::Class(node) => create_class_expr(env, map, node),
    Expr::Cond(node) => create_cond_expr(env, map, node),
    Expr::Fn(node) => create_fn_expr(env, map, node),
    Expr::Ident(node) => create_ident(env, map, node),
    Expr::Invalid(node) => create_invalid(env, map, node),
    Expr::JSXElement(node) => create_jsx_element(env, map, node),
    Expr::JSXEmpty(node) => create_jsx_empty_expr(env, map, node),
    Expr::JSXFragment(node) => create_jsx_fragment(env, map, node),
    Expr::JSXMember(node) => create_jsx_member_expr(env, map, node),
    Expr::JSXNamespacedName(node) => create_jsx_namespaced_name(env, map, node),
    Expr::Lit(node) => enum_create_lit(env, map, node),
    Expr::Member(node) => create_member_expr(env, map, node),
    Expr::MetaProp(node) => create_meta_prop_expr(env, map, node),
    Expr::New(node) => create_new_expr(env, map, node),
    Expr::Object(node) => create_object_lit(env, map, node),
    Expr::OptChain(node) => create_opt_chain_expr(env, map, node),
    Expr::Paren(node) => create_paren_expr(env, map, node),
    Expr::PrivateName(node) => create_private_name(env, map, node),
    Expr::Seq(node) => create_seq_expr(env, map, node),
    Expr::SuperProp(node) => create_super_prop_expr(env, map, node),
    Expr::TaggedTpl(node) => create_tagged_tpl(env, map, node),
    Expr::This(node) => create_this_expr(env, map, node),
    Expr::Tpl(node) => create_tpl(env, map, node),
    Expr::TsAs(node) => create_ts_as_expr(env, map, node),
    Expr::TsConstAssertion(node) => create_ts_const_assertion(env, map, node),
    Expr::TsInstantiation(node) => create_ts_instantiation(env, map, node),
    Expr::TsNonNull(node) => create_ts_non_null_expr(env, map, node),
    Expr::TsSatisfies(node) => create_ts_satisfies_expr(env, map, node),
    Expr::TsTypeAssertion(node) => create_ts_type_assertion(env, map, node),
    Expr::Unary(node) => create_unary_expr(env, map, node),
    Expr::Update(node) => create_update_expr(env, map, node),
    Expr::Yield(node) => create_yield_expr(env, map, node),
  }
}

fn enum_register_for_head(map: &mut ByteToIndexMap, node: &ForHead) {
  match node {
    ForHead::Pat(node) => enum_register_pat(map, node),
    ForHead::UsingDecl(node) => register_using_decl(map, node),
    ForHead::VarDecl(node) => register_var_decl(map, node),
  }
}

fn enum_create_for_head<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &ForHead,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    ForHead::Pat(node) => enum_create_pat(env, map, node),
    ForHead::UsingDecl(node) => create_using_decl(env, map, node),
    ForHead::VarDecl(node) => create_var_decl(env, map, node),
  }
}

fn enum_register_import_specifier(map: &mut ByteToIndexMap, node: &ImportSpecifier) {
  match node {
    ImportSpecifier::Default(node) => register_import_default_specifier(map, node),
    ImportSpecifier::Named(node) => register_import_named_specifier(map, node),
    ImportSpecifier::Namespace(node) => register_import_star_as_specifier(map, node),
  }
}

fn enum_create_import_specifier<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &ImportSpecifier,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    ImportSpecifier::Default(node) => create_import_default_specifier(env, map, node),
    ImportSpecifier::Named(node) => create_import_named_specifier(env, map, node),
    ImportSpecifier::Namespace(node) => create_import_star_as_specifier(env, map, node),
  }
}

fn enum_register_jsx_attr_name(map: &mut ByteToIndexMap, node: &JSXAttrName) {
  match node {
    JSXAttrName::Ident(node) => register_ident(map, node),
    JSXAttrName::JSXNamespacedName(node) => register_jsx_namespaced_name(map, node),
  }
}

fn enum_create_jsx_attr_name<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &JSXAttrName,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    JSXAttrName::Ident(node) => create_ident(env, map, node),
    JSXAttrName::JSXNamespacedName(node) => create_jsx_namespaced_name(env, map, node),
  }
}

fn enum_register_jsx_attr_or_spread(map: &mut ByteToIndexMap, node: &JSXAttrOrSpread) {
  match node {
    JSXAttrOrSpread::JSXAttr(node) => register_jsx_attr(map, node),
    JSXAttrOrSpread::SpreadElement(node) => register_spread_element(map, node),
  }
}

fn enum_create_jsx_attr_or_spread<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &JSXAttrOrSpread,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    JSXAttrOrSpread::JSXAttr(node) => create_jsx_attr(env, map, node),
    JSXAttrOrSpread::SpreadElement(node) => create_spread_element(env, map, node),
  }
}

fn enum_register_jsx_attr_value(map: &mut ByteToIndexMap, node: &JSXAttrValue) {
  match node {
    JSXAttrValue::JSXElement(node) => register_jsx_element(map, node),
    JSXAttrValue::JSXExprContainer(node) => register_jsx_expr_container(map, node),
    JSXAttrValue::JSXFragment(node) => register_jsx_fragment(map, node),
    JSXAttrValue::Lit(node) => enum_register_lit(map, node),
  }
}

fn enum_create_jsx_attr_value<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &JSXAttrValue,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    JSXAttrValue::JSXElement(node) => create_jsx_element(env, map, node),
    JSXAttrValue::JSXExprContainer(node) => create_jsx_expr_container(env, map, node),
    JSXAttrValue::JSXFragment(node) => create_jsx_fragment(env, map, node),
    JSXAttrValue::Lit(node) => enum_create_lit(env, map, node),
  }
}

fn enum_register_jsx_element_child(map: &mut ByteToIndexMap, node: &JSXElementChild) {
  match node {
    JSXElementChild::JSXElement(node) => register_jsx_element(map, node),
    JSXElementChild::JSXExprContainer(node) => register_jsx_expr_container(map, node),
    JSXElementChild::JSXFragment(node) => register_jsx_fragment(map, node),
    JSXElementChild::JSXSpreadChild(node) => register_jsx_spread_child(map, node),
    JSXElementChild::JSXText(node) => register_jsx_text(map, node),
  }
}

fn enum_create_jsx_element_child<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &JSXElementChild,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    JSXElementChild::JSXElement(node) => create_jsx_element(env, map, node),
    JSXElementChild::JSXExprContainer(node) => create_jsx_expr_container(env, map, node),
    JSXElementChild::JSXFragment(node) => create_jsx_fragment(env, map, node),
    JSXElementChild::JSXSpreadChild(node) => create_jsx_spread_child(env, map, node),
    JSXElementChild::JSXText(node) => create_jsx_text(env, map, node),
  }
}

fn enum_register_jsx_element_name(map: &mut ByteToIndexMap, node: &JSXElementName) {
  match node {
    JSXElementName::Ident(node) => register_ident(map, node),
    JSXElementName::JSXMemberExpr(node) => register_jsx_member_expr(map, node),
    JSXElementName::JSXNamespacedName(node) => register_jsx_namespaced_name(map, node),
  }
}

fn enum_create_jsx_element_name<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &JSXElementName,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    JSXElementName::Ident(node) => create_ident(env, map, node),
    JSXElementName::JSXMemberExpr(node) => create_jsx_member_expr(env, map, node),
    JSXElementName::JSXNamespacedName(node) => create_jsx_namespaced_name(env, map, node),
  }
}

fn enum_register_jsx_expr(map: &mut ByteToIndexMap, node: &JSXExpr) {
  match node {
    JSXExpr::Expr(node) => enum_register_expr(map, node),
    JSXExpr::JSXEmptyExpr(node) => register_jsx_empty_expr(map, node),
  }
}

fn enum_create_jsx_expr<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &JSXExpr,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    JSXExpr::Expr(node) => enum_create_expr(env, map, node),
    JSXExpr::JSXEmptyExpr(node) => create_jsx_empty_expr(env, map, node),
  }
}

fn enum_register_jsx_object(map: &mut ByteToIndexMap, node: &JSXObject) {
  match node {
    JSXObject::Ident(node) => register_ident(map, node),
    JSXObject::JSXMemberExpr(node) => register_jsx_member_expr(map, node),
  }
}

fn enum_create_jsx_object<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &JSXObject,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    JSXObject::Ident(node) => create_ident(env, map, node),
    JSXObject::JSXMemberExpr(node) => create_jsx_member_expr(env, map, node),
  }
}

fn enum_register_key(map: &mut ByteToIndexMap, node: &Key) {
  match node {
    Key::Private(node) => register_private_name(map, node),
    Key::Public(node) => enum_register_prop_name(map, node),
  }
}

fn enum_create_key<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &Key,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    Key::Private(node) => create_private_name(env, map, node),
    Key::Public(node) => enum_create_prop_name(env, map, node),
  }
}

fn enum_register_lit(map: &mut ByteToIndexMap, node: &Lit) {
  match node {
    Lit::BigInt(node) => register_big_int(map, node),
    Lit::Bool(node) => register_bool(map, node),
    Lit::JSXText(node) => register_jsx_text(map, node),
    Lit::Null(node) => register_null(map, node),
    Lit::Num(node) => register_number(map, node),
    Lit::Regex(node) => register_regex(map, node),
    Lit::Str(node) => register_str(map, node),
  }
}

fn enum_create_lit<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &Lit,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    Lit::BigInt(node) => create_big_int(env, map, node),
    Lit::Bool(node) => create_bool(env, map, node),
    Lit::JSXText(node) => create_jsx_text(env, map, node),
    Lit::Null(node) => create_null(env, map, node),
    Lit::Num(node) => create_number(env, map, node),
    Lit::Regex(node) => create_regex(env, map, node),
    Lit::Str(node) => create_str(env, map, node),
  }
}

fn enum_register_member_prop(map: &mut ByteToIndexMap, node: &MemberProp) {
  match node {
    MemberProp::Computed(node) => register_computed_prop_name(map, node),
    MemberProp::Ident(node) => register_ident(map, node),
    MemberProp::PrivateName(node) => register_private_name(map, node),
  }
}

fn enum_create_member_prop<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &MemberProp,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    MemberProp::Computed(node) => create_computed_prop_name(env, map, node),
    MemberProp::Ident(node) => create_ident(env, map, node),
    MemberProp::PrivateName(node) => create_private_name(env, map, node),
  }
}

fn enum_register_module_decl(map: &mut ByteToIndexMap, node: &ModuleDecl) {
  match node {
    ModuleDecl::ExportAll(node) => register_export_all(map, node),
    ModuleDecl::ExportDecl(node) => register_export_decl(map, node),
    ModuleDecl::ExportDefaultDecl(node) => register_export_default_decl(map, node),
    ModuleDecl::ExportDefaultExpr(node) => register_export_default_expr(map, node),
    ModuleDecl::ExportNamed(node) => register_named_export(map, node),
    ModuleDecl::Import(node) => register_import_decl(map, node),
    ModuleDecl::TsExportAssignment(node) => register_ts_export_assignment(map, node),
    ModuleDecl::TsImportEquals(node) => register_ts_import_equals_decl(map, node),
    ModuleDecl::TsNamespaceExport(node) => register_ts_namespace_export_decl(map, node),
  }
}

fn enum_create_module_decl<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &ModuleDecl,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    ModuleDecl::ExportAll(node) => create_export_all(env, map, node),
    ModuleDecl::ExportDecl(node) => create_export_decl(env, map, node),
    ModuleDecl::ExportDefaultDecl(node) => create_export_default_decl(env, map, node),
    ModuleDecl::ExportDefaultExpr(node) => create_export_default_expr(env, map, node),
    ModuleDecl::ExportNamed(node) => create_named_export(env, map, node),
    ModuleDecl::Import(node) => create_import_decl(env, map, node),
    ModuleDecl::TsExportAssignment(node) => create_ts_export_assignment(env, map, node),
    ModuleDecl::TsImportEquals(node) => create_ts_import_equals_decl(env, map, node),
    ModuleDecl::TsNamespaceExport(node) => create_ts_namespace_export_decl(env, map, node),
  }
}

fn enum_register_module_export_name(map: &mut ByteToIndexMap, node: &ModuleExportName) {
  match node {
    ModuleExportName::Ident(node) => register_ident(map, node),
    ModuleExportName::Str(node) => register_str(map, node),
  }
}

fn enum_create_module_export_name<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &ModuleExportName,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    ModuleExportName::Ident(node) => create_ident(env, map, node),
    ModuleExportName::Str(node) => create_str(env, map, node),
  }
}

fn enum_register_module_item(map: &mut ByteToIndexMap, node: &ModuleItem) {
  match node {
    ModuleItem::ModuleDecl(node) => enum_register_module_decl(map, node),
    ModuleItem::Stmt(node) => enum_register_stmt(map, node),
  }
}

fn enum_create_module_item<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &ModuleItem,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    ModuleItem::ModuleDecl(node) => enum_create_module_decl(env, map, node),
    ModuleItem::Stmt(node) => enum_create_stmt(env, map, node),
  }
}

fn enum_register_object_pat_prop(map: &mut ByteToIndexMap, node: &ObjectPatProp) {
  match node {
    ObjectPatProp::Assign(node) => register_assign_pat_prop(map, node),
    ObjectPatProp::KeyValue(node) => register_key_value_pat_prop(map, node),
    ObjectPatProp::Rest(node) => register_rest_pat(map, node),
  }
}

fn enum_create_object_pat_prop<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &ObjectPatProp,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    ObjectPatProp::Assign(node) => create_assign_pat_prop(env, map, node),
    ObjectPatProp::KeyValue(node) => create_key_value_pat_prop(env, map, node),
    ObjectPatProp::Rest(node) => create_rest_pat(env, map, node),
  }
}

fn enum_register_opt_chain_base(map: &mut ByteToIndexMap, node: &OptChainBase) {
  match node {
    OptChainBase::Call(node) => register_opt_call(map, node),
    OptChainBase::Member(node) => register_member_expr(map, node),
  }
}

fn enum_create_opt_chain_base<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &OptChainBase,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    OptChainBase::Call(node) => create_opt_call(env, map, node),
    OptChainBase::Member(node) => create_member_expr(env, map, node),
  }
}

fn enum_register_param_or_ts_param_prop(map: &mut ByteToIndexMap, node: &ParamOrTsParamProp) {
  match node {
    ParamOrTsParamProp::Param(node) => register_param(map, node),
    ParamOrTsParamProp::TsParamProp(node) => register_ts_param_prop(map, node),
  }
}

fn enum_create_param_or_ts_param_prop<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &ParamOrTsParamProp,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    ParamOrTsParamProp::Param(node) => create_param(env, map, node),
    ParamOrTsParamProp::TsParamProp(node) => create_ts_param_prop(env, map, node),
  }
}

fn enum_register_pat(map: &mut ByteToIndexMap, node: &Pat) {
  match node {
    Pat::Array(node) => register_array_pat(map, node),
    Pat::Assign(node) => register_assign_pat(map, node),
    Pat::Expr(node) => enum_register_expr(map, node),
    Pat::Ident(node) => register_binding_ident(map, node),
    Pat::Invalid(node) => register_invalid(map, node),
    Pat::Object(node) => register_object_pat(map, node),
    Pat::Rest(node) => register_rest_pat(map, node),
  }
}

fn enum_create_pat<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &Pat,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    Pat::Array(node) => create_array_pat(env, map, node),
    Pat::Assign(node) => create_assign_pat(env, map, node),
    Pat::Expr(node) => enum_create_expr(env, map, node),
    Pat::Ident(node) => create_binding_ident(env, map, node),
    Pat::Invalid(node) => create_invalid(env, map, node),
    Pat::Object(node) => create_object_pat(env, map, node),
    Pat::Rest(node) => create_rest_pat(env, map, node),
  }
}

pub fn enum_register_program(map: &mut ByteToIndexMap, node: &Program) {
  match node {
    Program::Module(node) => register_module(map, node),
    Program::Script(node) => register_script(map, node),
  }
}

pub fn enum_create_program<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &Program,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    Program::Module(node) => create_module(env, map, node),
    Program::Script(node) => create_script(env, map, node),
  }
}

fn enum_register_prop(map: &mut ByteToIndexMap, node: &Prop) {
  match node {
    Prop::Assign(node) => register_assign_prop(map, node),
    Prop::Getter(node) => register_getter_prop(map, node),
    Prop::KeyValue(node) => register_key_value_prop(map, node),
    Prop::Method(node) => register_method_prop(map, node),
    Prop::Setter(node) => register_setter_prop(map, node),
    Prop::Shorthand(node) => register_ident(map, node),
  }
}

fn enum_create_prop<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &Prop,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    Prop::Assign(node) => create_assign_prop(env, map, node),
    Prop::Getter(node) => create_getter_prop(env, map, node),
    Prop::KeyValue(node) => create_key_value_prop(env, map, node),
    Prop::Method(node) => create_method_prop(env, map, node),
    Prop::Setter(node) => create_setter_prop(env, map, node),
    Prop::Shorthand(node) => create_ident(env, map, node),
  }
}

fn enum_register_prop_name(map: &mut ByteToIndexMap, node: &PropName) {
  match node {
    PropName::BigInt(node) => register_big_int(map, node),
    PropName::Computed(node) => register_computed_prop_name(map, node),
    PropName::Ident(node) => register_ident(map, node),
    PropName::Num(node) => register_number(map, node),
    PropName::Str(node) => register_str(map, node),
  }
}

fn enum_create_prop_name<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &PropName,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    PropName::BigInt(node) => create_big_int(env, map, node),
    PropName::Computed(node) => create_computed_prop_name(env, map, node),
    PropName::Ident(node) => create_ident(env, map, node),
    PropName::Num(node) => create_number(env, map, node),
    PropName::Str(node) => create_str(env, map, node),
  }
}

fn enum_register_prop_or_spread(map: &mut ByteToIndexMap, node: &PropOrSpread) {
  match node {
    PropOrSpread::Prop(node) => enum_register_prop(map, node),
    PropOrSpread::Spread(node) => register_spread_element(map, node),
  }
}

fn enum_create_prop_or_spread<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &PropOrSpread,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    PropOrSpread::Prop(node) => enum_create_prop(env, map, node),
    PropOrSpread::Spread(node) => create_spread_element(env, map, node),
  }
}

fn enum_register_simple_assign_target(map: &mut ByteToIndexMap, node: &SimpleAssignTarget) {
  match node {
    SimpleAssignTarget::Ident(node) => register_binding_ident(map, node),
    SimpleAssignTarget::Invalid(node) => register_invalid(map, node),
    SimpleAssignTarget::Member(node) => register_member_expr(map, node),
    SimpleAssignTarget::OptChain(node) => register_opt_chain_expr(map, node),
    SimpleAssignTarget::Paren(node) => register_paren_expr(map, node),
    SimpleAssignTarget::SuperProp(node) => register_super_prop_expr(map, node),
    SimpleAssignTarget::TsAs(node) => register_ts_as_expr(map, node),
    SimpleAssignTarget::TsInstantiation(node) => register_ts_instantiation(map, node),
    SimpleAssignTarget::TsNonNull(node) => register_ts_non_null_expr(map, node),
    SimpleAssignTarget::TsSatisfies(node) => register_ts_satisfies_expr(map, node),
    SimpleAssignTarget::TsTypeAssertion(node) => register_ts_type_assertion(map, node),
  }
}

fn enum_create_simple_assign_target<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &SimpleAssignTarget,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    SimpleAssignTarget::Ident(node) => create_binding_ident(env, map, node),
    SimpleAssignTarget::Invalid(node) => create_invalid(env, map, node),
    SimpleAssignTarget::Member(node) => create_member_expr(env, map, node),
    SimpleAssignTarget::OptChain(node) => create_opt_chain_expr(env, map, node),
    SimpleAssignTarget::Paren(node) => create_paren_expr(env, map, node),
    SimpleAssignTarget::SuperProp(node) => create_super_prop_expr(env, map, node),
    SimpleAssignTarget::TsAs(node) => create_ts_as_expr(env, map, node),
    SimpleAssignTarget::TsInstantiation(node) => create_ts_instantiation(env, map, node),
    SimpleAssignTarget::TsNonNull(node) => create_ts_non_null_expr(env, map, node),
    SimpleAssignTarget::TsSatisfies(node) => create_ts_satisfies_expr(env, map, node),
    SimpleAssignTarget::TsTypeAssertion(node) => create_ts_type_assertion(env, map, node),
  }
}

fn enum_register_stmt(map: &mut ByteToIndexMap, node: &Stmt) {
  match node {
    Stmt::Block(node) => register_block_stmt(map, node),
    Stmt::Break(node) => register_break_stmt(map, node),
    Stmt::Continue(node) => register_continue_stmt(map, node),
    Stmt::Debugger(node) => register_debugger_stmt(map, node),
    Stmt::Decl(node) => enum_register_decl(map, node),
    Stmt::DoWhile(node) => register_do_while_stmt(map, node),
    Stmt::Empty(node) => register_empty_stmt(map, node),
    Stmt::Expr(node) => register_expr_stmt(map, node),
    Stmt::For(node) => register_for_stmt(map, node),
    Stmt::ForIn(node) => register_for_in_stmt(map, node),
    Stmt::ForOf(node) => register_for_of_stmt(map, node),
    Stmt::If(node) => register_if_stmt(map, node),
    Stmt::Labeled(node) => register_labeled_stmt(map, node),
    Stmt::Return(node) => register_return_stmt(map, node),
    Stmt::Switch(node) => register_switch_stmt(map, node),
    Stmt::Throw(node) => register_throw_stmt(map, node),
    Stmt::Try(node) => register_try_stmt(map, node),
    Stmt::While(node) => register_while_stmt(map, node),
    Stmt::With(node) => register_with_stmt(map, node),
  }
}

fn enum_create_stmt<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &Stmt,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    Stmt::Block(node) => create_block_stmt(env, map, node),
    Stmt::Break(node) => create_break_stmt(env, map, node),
    Stmt::Continue(node) => create_continue_stmt(env, map, node),
    Stmt::Debugger(node) => create_debugger_stmt(env, map, node),
    Stmt::Decl(node) => enum_create_decl(env, map, node),
    Stmt::DoWhile(node) => create_do_while_stmt(env, map, node),
    Stmt::Empty(node) => create_empty_stmt(env, map, node),
    Stmt::Expr(node) => create_expr_stmt(env, map, node),
    Stmt::For(node) => create_for_stmt(env, map, node),
    Stmt::ForIn(node) => create_for_in_stmt(env, map, node),
    Stmt::ForOf(node) => create_for_of_stmt(env, map, node),
    Stmt::If(node) => create_if_stmt(env, map, node),
    Stmt::Labeled(node) => create_labeled_stmt(env, map, node),
    Stmt::Return(node) => create_return_stmt(env, map, node),
    Stmt::Switch(node) => create_switch_stmt(env, map, node),
    Stmt::Throw(node) => create_throw_stmt(env, map, node),
    Stmt::Try(node) => create_try_stmt(env, map, node),
    Stmt::While(node) => create_while_stmt(env, map, node),
    Stmt::With(node) => create_with_stmt(env, map, node),
  }
}

fn enum_register_super_prop(map: &mut ByteToIndexMap, node: &SuperProp) {
  match node {
    SuperProp::Computed(node) => register_computed_prop_name(map, node),
    SuperProp::Ident(node) => register_ident(map, node),
  }
}

fn enum_create_super_prop<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &SuperProp,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    SuperProp::Computed(node) => create_computed_prop_name(env, map, node),
    SuperProp::Ident(node) => create_ident(env, map, node),
  }
}

fn enum_register_ts_entity_name(map: &mut ByteToIndexMap, node: &TsEntityName) {
  match node {
    TsEntityName::Ident(node) => register_ident(map, node),
    TsEntityName::TsQualifiedName(node) => register_ts_qualified_name(map, node),
  }
}

fn enum_create_ts_entity_name<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsEntityName,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsEntityName::Ident(node) => create_ident(env, map, node),
    TsEntityName::TsQualifiedName(node) => create_ts_qualified_name(env, map, node),
  }
}

fn enum_register_ts_enum_member_id(map: &mut ByteToIndexMap, node: &TsEnumMemberId) {
  match node {
    TsEnumMemberId::Ident(node) => register_ident(map, node),
    TsEnumMemberId::Str(node) => register_str(map, node),
  }
}

fn enum_create_ts_enum_member_id<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsEnumMemberId,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsEnumMemberId::Ident(node) => create_ident(env, map, node),
    TsEnumMemberId::Str(node) => create_str(env, map, node),
  }
}

fn enum_register_ts_fn_or_constructor_type(map: &mut ByteToIndexMap, node: &TsFnOrConstructorType) {
  match node {
    TsFnOrConstructorType::TsConstructorType(node) => register_ts_constructor_type(map, node),
    TsFnOrConstructorType::TsFnType(node) => register_ts_fn_type(map, node),
  }
}

fn enum_create_ts_fn_or_constructor_type<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsFnOrConstructorType,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsFnOrConstructorType::TsConstructorType(node) => create_ts_constructor_type(env, map, node),
    TsFnOrConstructorType::TsFnType(node) => create_ts_fn_type(env, map, node),
  }
}

fn enum_register_ts_fn_param(map: &mut ByteToIndexMap, node: &TsFnParam) {
  match node {
    TsFnParam::Array(node) => register_array_pat(map, node),
    TsFnParam::Ident(node) => register_binding_ident(map, node),
    TsFnParam::Object(node) => register_object_pat(map, node),
    TsFnParam::Rest(node) => register_rest_pat(map, node),
  }
}

fn enum_create_ts_fn_param<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsFnParam,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsFnParam::Array(node) => create_array_pat(env, map, node),
    TsFnParam::Ident(node) => create_binding_ident(env, map, node),
    TsFnParam::Object(node) => create_object_pat(env, map, node),
    TsFnParam::Rest(node) => create_rest_pat(env, map, node),
  }
}

fn enum_register_ts_lit(map: &mut ByteToIndexMap, node: &TsLit) {
  match node {
    TsLit::BigInt(node) => register_big_int(map, node),
    TsLit::Bool(node) => register_bool(map, node),
    TsLit::Number(node) => register_number(map, node),
    TsLit::Str(node) => register_str(map, node),
    TsLit::Tpl(node) => register_ts_tpl_lit_type(map, node),
  }
}

fn enum_create_ts_lit<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsLit,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsLit::BigInt(node) => create_big_int(env, map, node),
    TsLit::Bool(node) => create_bool(env, map, node),
    TsLit::Number(node) => create_number(env, map, node),
    TsLit::Str(node) => create_str(env, map, node),
    TsLit::Tpl(node) => create_ts_tpl_lit_type(env, map, node),
  }
}

fn enum_register_ts_module_name(map: &mut ByteToIndexMap, node: &TsModuleName) {
  match node {
    TsModuleName::Ident(node) => register_ident(map, node),
    TsModuleName::Str(node) => register_str(map, node),
  }
}

fn enum_create_ts_module_name<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsModuleName,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsModuleName::Ident(node) => create_ident(env, map, node),
    TsModuleName::Str(node) => create_str(env, map, node),
  }
}

fn enum_register_ts_module_ref(map: &mut ByteToIndexMap, node: &TsModuleRef) {
  match node {
    TsModuleRef::TsEntityName(node) => enum_register_ts_entity_name(map, node),
    TsModuleRef::TsExternalModuleRef(node) => register_ts_external_module_ref(map, node),
  }
}

fn enum_create_ts_module_ref<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsModuleRef,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsModuleRef::TsEntityName(node) => enum_create_ts_entity_name(env, map, node),
    TsModuleRef::TsExternalModuleRef(node) => create_ts_external_module_ref(env, map, node),
  }
}

fn enum_register_ts_namespace_body(map: &mut ByteToIndexMap, node: &TsNamespaceBody) {
  match node {
    TsNamespaceBody::TsModuleBlock(node) => register_ts_module_block(map, node),
    TsNamespaceBody::TsNamespaceDecl(node) => register_ts_namespace_decl(map, node),
  }
}

fn enum_create_ts_namespace_body<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsNamespaceBody,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsNamespaceBody::TsModuleBlock(node) => create_ts_module_block(env, map, node),
    TsNamespaceBody::TsNamespaceDecl(node) => create_ts_namespace_decl(env, map, node),
  }
}

fn enum_register_ts_param_prop_param(map: &mut ByteToIndexMap, node: &TsParamPropParam) {
  match node {
    TsParamPropParam::Assign(node) => register_assign_pat(map, node),
    TsParamPropParam::Ident(node) => register_binding_ident(map, node),
  }
}

fn enum_create_ts_param_prop_param<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsParamPropParam,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsParamPropParam::Assign(node) => create_assign_pat(env, map, node),
    TsParamPropParam::Ident(node) => create_binding_ident(env, map, node),
  }
}

fn enum_register_ts_this_type_or_ident(map: &mut ByteToIndexMap, node: &TsThisTypeOrIdent) {
  match node {
    TsThisTypeOrIdent::Ident(node) => register_ident(map, node),
    TsThisTypeOrIdent::TsThisType(node) => register_ts_this_type(map, node),
  }
}

fn enum_create_ts_this_type_or_ident<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsThisTypeOrIdent,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsThisTypeOrIdent::Ident(node) => create_ident(env, map, node),
    TsThisTypeOrIdent::TsThisType(node) => create_ts_this_type(env, map, node),
  }
}

fn enum_register_ts_type(map: &mut ByteToIndexMap, node: &TsType) {
  match node {
    TsType::TsArrayType(node) => register_ts_array_type(map, node),
    TsType::TsConditionalType(node) => register_ts_conditional_type(map, node),
    TsType::TsFnOrConstructorType(node) => enum_register_ts_fn_or_constructor_type(map, node),
    TsType::TsImportType(node) => register_ts_import_type(map, node),
    TsType::TsIndexedAccessType(node) => register_ts_indexed_access_type(map, node),
    TsType::TsInferType(node) => register_ts_infer_type(map, node),
    TsType::TsKeywordType(node) => register_ts_keyword_type(map, node),
    TsType::TsLitType(node) => register_ts_lit_type(map, node),
    TsType::TsMappedType(node) => register_ts_mapped_type(map, node),
    TsType::TsOptionalType(node) => register_ts_optional_type(map, node),
    TsType::TsParenthesizedType(node) => register_ts_parenthesized_type(map, node),
    TsType::TsRestType(node) => register_ts_rest_type(map, node),
    TsType::TsThisType(node) => register_ts_this_type(map, node),
    TsType::TsTupleType(node) => register_ts_tuple_type(map, node),
    TsType::TsTypeLit(node) => register_ts_type_lit(map, node),
    TsType::TsTypeOperator(node) => register_ts_type_operator(map, node),
    TsType::TsTypePredicate(node) => register_ts_type_predicate(map, node),
    TsType::TsTypeQuery(node) => register_ts_type_query(map, node),
    TsType::TsTypeRef(node) => register_ts_type_ref(map, node),
    TsType::TsUnionOrIntersectionType(node) => enum_register_ts_union_or_intersection_type(map, node),
  }
}

fn enum_create_ts_type<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsType,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsType::TsArrayType(node) => create_ts_array_type(env, map, node),
    TsType::TsConditionalType(node) => create_ts_conditional_type(env, map, node),
    TsType::TsFnOrConstructorType(node) => enum_create_ts_fn_or_constructor_type(env, map, node),
    TsType::TsImportType(node) => create_ts_import_type(env, map, node),
    TsType::TsIndexedAccessType(node) => create_ts_indexed_access_type(env, map, node),
    TsType::TsInferType(node) => create_ts_infer_type(env, map, node),
    TsType::TsKeywordType(node) => create_ts_keyword_type(env, map, node),
    TsType::TsLitType(node) => create_ts_lit_type(env, map, node),
    TsType::TsMappedType(node) => create_ts_mapped_type(env, map, node),
    TsType::TsOptionalType(node) => create_ts_optional_type(env, map, node),
    TsType::TsParenthesizedType(node) => create_ts_parenthesized_type(env, map, node),
    TsType::TsRestType(node) => create_ts_rest_type(env, map, node),
    TsType::TsThisType(node) => create_ts_this_type(env, map, node),
    TsType::TsTupleType(node) => create_ts_tuple_type(env, map, node),
    TsType::TsTypeLit(node) => create_ts_type_lit(env, map, node),
    TsType::TsTypeOperator(node) => create_ts_type_operator(env, map, node),
    TsType::TsTypePredicate(node) => create_ts_type_predicate(env, map, node),
    TsType::TsTypeQuery(node) => create_ts_type_query(env, map, node),
    TsType::TsTypeRef(node) => create_ts_type_ref(env, map, node),
    TsType::TsUnionOrIntersectionType(node) => enum_create_ts_union_or_intersection_type(env, map, node),
  }
}

fn enum_register_ts_type_element(map: &mut ByteToIndexMap, node: &TsTypeElement) {
  match node {
    TsTypeElement::TsCallSignatureDecl(node) => register_ts_call_signature_decl(map, node),
    TsTypeElement::TsConstructSignatureDecl(node) => register_ts_construct_signature_decl(map, node),
    TsTypeElement::TsGetterSignature(node) => register_ts_getter_signature(map, node),
    TsTypeElement::TsIndexSignature(node) => register_ts_index_signature(map, node),
    TsTypeElement::TsMethodSignature(node) => register_ts_method_signature(map, node),
    TsTypeElement::TsPropertySignature(node) => register_ts_property_signature(map, node),
    TsTypeElement::TsSetterSignature(node) => register_ts_setter_signature(map, node),
  }
}

fn enum_create_ts_type_element<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsTypeElement,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsTypeElement::TsCallSignatureDecl(node) => create_ts_call_signature_decl(env, map, node),
    TsTypeElement::TsConstructSignatureDecl(node) => create_ts_construct_signature_decl(env, map, node),
    TsTypeElement::TsGetterSignature(node) => create_ts_getter_signature(env, map, node),
    TsTypeElement::TsIndexSignature(node) => create_ts_index_signature(env, map, node),
    TsTypeElement::TsMethodSignature(node) => create_ts_method_signature(env, map, node),
    TsTypeElement::TsPropertySignature(node) => create_ts_property_signature(env, map, node),
    TsTypeElement::TsSetterSignature(node) => create_ts_setter_signature(env, map, node),
  }
}

fn enum_register_ts_type_query_expr(map: &mut ByteToIndexMap, node: &TsTypeQueryExpr) {
  match node {
    TsTypeQueryExpr::Import(node) => register_ts_import_type(map, node),
    TsTypeQueryExpr::TsEntityName(node) => enum_register_ts_entity_name(map, node),
  }
}

fn enum_create_ts_type_query_expr<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsTypeQueryExpr,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsTypeQueryExpr::Import(node) => create_ts_import_type(env, map, node),
    TsTypeQueryExpr::TsEntityName(node) => enum_create_ts_entity_name(env, map, node),
  }
}

fn enum_register_ts_union_or_intersection_type(map: &mut ByteToIndexMap, node: &TsUnionOrIntersectionType) {
  match node {
    TsUnionOrIntersectionType::TsIntersectionType(node) => register_ts_intersection_type(map, node),
    TsUnionOrIntersectionType::TsUnionType(node) => register_ts_union_type(map, node),
  }
}

fn enum_create_ts_union_or_intersection_type<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &TsUnionOrIntersectionType,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    TsUnionOrIntersectionType::TsIntersectionType(node) => create_ts_intersection_type(env, map, node),
    TsUnionOrIntersectionType::TsUnionType(node) => create_ts_union_type(env, map, node),
  }
}

fn enum_register_var_decl_or_expr(map: &mut ByteToIndexMap, node: &VarDeclOrExpr) {
  match node {
    VarDeclOrExpr::Expr(node) => enum_register_expr(map, node),
    VarDeclOrExpr::VarDecl(node) => register_var_decl(map, node),
  }
}

fn enum_create_var_decl_or_expr<'local, 'a>(
  env: &mut JNIEnv<'local>,
  map: &ByteToIndexMap,
  node: &VarDeclOrExpr,
) -> JObject<'a>
where
  'local: 'a,
{
  match node {
    VarDeclOrExpr::Expr(node) => enum_create_expr(env, map, node),
    VarDeclOrExpr::VarDecl(node) => create_var_decl(env, map, node),
  }
}
/* Enum End */

/* Node Begin */
fn register_array_lit(map: &mut ByteToIndexMap, node: &ArrayLit) {
  map.register_by_span(&node.span);
  node.elems.iter().for_each(|node| {
    node.as_ref().map(|node| register_expr_or_spread(map, node));
  });
}

fn create_array_lit<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ArrayLit) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_elems = list_new(env, node.elems.len());
  node.elems.iter().for_each(|node| {
    let java_node = node.as_ref().map_or_else(
      || Default::default(),
      |node| create_expr_or_spread(env, map, node));
    list_add(env, &java_elems, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_ARRAY_LIT.as_ref().unwrap() }
    .construct(env, &java_elems, &java_span_ex);
  delete_local_ref!(env, java_elems);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_array_pat(map: &mut ByteToIndexMap, node: &ArrayPat) {
  map.register_by_span(&node.span);
  node.elems.iter().for_each(|node| {
    node.as_ref().map(|node| enum_register_pat(map, node));
  });
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
}

fn create_array_pat<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ArrayPat) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_elems = list_new(env, node.elems.len());
  node.elems.iter().for_each(|node| {
    let java_node = node.as_ref().map_or_else(
      || Default::default(),
      |node| enum_create_pat(env, map, node));
    list_add(env, &java_elems, &java_node);
    delete_local_ref!(env, java_node);
  });
  let optional = node.optional;
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let return_value = unsafe { JAVA_CLASS_ARRAY_PAT.as_ref().unwrap() }
    .construct(env, &java_elems, optional, &java_optional_type_ann, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_ref!(env, java_elems);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_arrow_expr(map: &mut ByteToIndexMap, node: &ArrowExpr) {
  map.register_by_span(&node.span);
  node.params.iter().for_each(|node| {
    enum_register_pat(map, node);
  });
  enum_register_block_stmt_or_expr(map, &node.body);
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
  node.return_type.as_ref().map(|node| register_ts_type_ann(map, node));
}

fn create_arrow_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ArrowExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_pat(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_body = enum_create_block_stmt_or_expr(env, map, &node.body);
  let is_async = node.is_async;
  let is_generator = node.is_generator;
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let java_optional_return_type = node.return_type.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let return_value = unsafe { JAVA_CLASS_ARROW_EXPR.as_ref().unwrap() }
    .construct(env, &java_params, &java_body, is_async, is_generator, &java_optional_type_params, &java_optional_return_type, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_optional_ref!(env, java_optional_return_type);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_assign_expr(map: &mut ByteToIndexMap, node: &AssignExpr) {
  map.register_by_span(&node.span);
  enum_register_assign_target(map, &node.left);
  enum_register_expr(map, &node.right);
}

fn create_assign_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &AssignExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_op = node.op.to_java(env);
  let java_left = enum_create_assign_target(env, map, &node.left);
  let java_right = enum_create_expr(env, map, &node.right);
  let return_value = unsafe { JAVA_CLASS_ASSIGN_EXPR.as_ref().unwrap() }
    .construct(env, &java_op, &java_left, &java_right, &java_span_ex);
  delete_local_ref!(env, java_op);
  delete_local_ref!(env, java_left);
  delete_local_ref!(env, java_right);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_assign_pat(map: &mut ByteToIndexMap, node: &AssignPat) {
  map.register_by_span(&node.span);
  enum_register_pat(map, &node.left);
  enum_register_expr(map, &node.right);
}

fn create_assign_pat<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &AssignPat) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_left = enum_create_pat(env, map, &node.left);
  let java_right = enum_create_expr(env, map, &node.right);
  let return_value = unsafe { JAVA_CLASS_ASSIGN_PAT.as_ref().unwrap() }
    .construct(env, &java_left, &java_right, &java_span_ex);
  delete_local_ref!(env, java_left);
  delete_local_ref!(env, java_right);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_assign_pat_prop(map: &mut ByteToIndexMap, node: &AssignPatProp) {
  map.register_by_span(&node.span);
  register_binding_ident(map, &node.key);
  node.value.as_ref().map(|node| enum_register_expr(map, node));
}

fn create_assign_pat_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &AssignPatProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_key = create_binding_ident(env, map, &node.key);
  let java_optional_value = node.value.as_ref().map(|node| enum_create_expr(env, map, node));
  let return_value = unsafe { JAVA_CLASS_ASSIGN_PAT_PROP.as_ref().unwrap() }
    .construct(env, &java_key, &java_optional_value, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_value);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_assign_prop(map: &mut ByteToIndexMap, node: &AssignProp) {
  map.register_by_span(&node.span());
  register_ident(map, &node.key);
  enum_register_expr(map, &node.value);
}

fn create_assign_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &AssignProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_key = create_ident(env, map, &node.key);
  let java_value = enum_create_expr(env, map, &node.value);
  let return_value = unsafe { JAVA_CLASS_ASSIGN_PROP.as_ref().unwrap() }
    .construct(env, &java_key, &java_value, &java_span_ex);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_value);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_auto_accessor(map: &mut ByteToIndexMap, node: &AutoAccessor) {
  map.register_by_span(&node.span);
  enum_register_key(map, &node.key);
  node.value.as_ref().map(|node| enum_register_expr(map, node));
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
  node.decorators.iter().for_each(|node| {
    register_decorator(map, node);
  });
}

fn create_auto_accessor<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &AutoAccessor) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_key = enum_create_key(env, map, &node.key);
  let java_optional_value = node.value.as_ref().map(|node| enum_create_expr(env, map, node));
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let is_static = node.is_static;
  let java_decorators = list_new(env, node.decorators.len());
  node.decorators.iter().for_each(|node| {
    let java_node = create_decorator(env, map, node);
    list_add(env, &java_decorators, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_accessibility = node.accessibility.as_ref().map(|node| node.to_java(env));
  let is_override = node.is_override;
  let definite = node.definite;
  let return_value = unsafe { JAVA_CLASS_AUTO_ACCESSOR.as_ref().unwrap() }
    .construct(env, &java_key, &java_optional_value, &java_optional_type_ann, is_static, &java_decorators, &java_optional_accessibility, is_override, definite, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_value);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_optional_ref!(env, java_optional_accessibility);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_decorators);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_await_expr(map: &mut ByteToIndexMap, node: &AwaitExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.arg);
}

fn create_await_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &AwaitExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_arg = enum_create_expr(env, map, &node.arg);
  let return_value = unsafe { JAVA_CLASS_AWAIT_EXPR.as_ref().unwrap() }
    .construct(env, &java_arg, &java_span_ex);
  delete_local_ref!(env, java_arg);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_big_int(map: &mut ByteToIndexMap, node: &BigInt) {
  map.register_by_span(&node.span);
}

fn register_bin_expr(map: &mut ByteToIndexMap, node: &BinExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.left);
  enum_register_expr(map, &node.right);
}

fn create_bin_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &BinExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_op = node.op.to_java(env);
  let java_left = enum_create_expr(env, map, &node.left);
  let java_right = enum_create_expr(env, map, &node.right);
  let return_value = unsafe { JAVA_CLASS_BIN_EXPR.as_ref().unwrap() }
    .construct(env, &java_op, &java_left, &java_right, &java_span_ex);
  delete_local_ref!(env, java_op);
  delete_local_ref!(env, java_left);
  delete_local_ref!(env, java_right);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_binding_ident(map: &mut ByteToIndexMap, node: &BindingIdent) {
  map.register_by_span(&node.span());
  register_ident(map, &node.id);
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
}

fn create_binding_ident<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &BindingIdent) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_id = create_ident(env, map, &node.id);
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let return_value = unsafe { JAVA_CLASS_BINDING_IDENT.as_ref().unwrap() }
    .construct(env, &java_id, &java_optional_type_ann, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_block_stmt(map: &mut ByteToIndexMap, node: &BlockStmt) {
  map.register_by_span(&node.span);
  node.stmts.iter().for_each(|node| {
    enum_register_stmt(map, node);
  });
}

fn create_block_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &BlockStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_stmts = list_new(env, node.stmts.len());
  node.stmts.iter().for_each(|node| {
    let java_node = enum_create_stmt(env, map, node);
    list_add(env, &java_stmts, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_BLOCK_STMT.as_ref().unwrap() }
    .construct(env, &java_stmts, &java_span_ex);
  delete_local_ref!(env, java_stmts);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_bool(map: &mut ByteToIndexMap, node: &Bool) {
  map.register_by_span(&node.span);
}

fn create_bool<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Bool) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let value = node.value;
  let return_value = unsafe { JAVA_CLASS_BOOL.as_ref().unwrap() }
    .construct(env, value, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_break_stmt(map: &mut ByteToIndexMap, node: &BreakStmt) {
  map.register_by_span(&node.span);
  node.label.as_ref().map(|node| register_ident(map, node));
}

fn create_break_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &BreakStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_optional_label = node.label.as_ref().map(|node| create_ident(env, map, node));
  let return_value = unsafe { JAVA_CLASS_BREAK_STMT.as_ref().unwrap() }
    .construct(env, &java_optional_label, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_label);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_call_expr(map: &mut ByteToIndexMap, node: &CallExpr) {
  map.register_by_span(&node.span);
  enum_register_callee(map, &node.callee);
  node.args.iter().for_each(|node| {
    register_expr_or_spread(map, node);
  });
  node.type_args.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
}

fn create_call_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &CallExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_callee = enum_create_callee(env, map, &node.callee);
  let java_args = list_new(env, node.args.len());
  node.args.iter().for_each(|node| {
    let java_node = create_expr_or_spread(env, map, node);
    list_add(env, &java_args, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_type_args = node.type_args.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let return_value = unsafe { JAVA_CLASS_CALL_EXPR.as_ref().unwrap() }
    .construct(env, &java_callee, &java_args, &java_optional_type_args, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_args);
  delete_local_ref!(env, java_callee);
  delete_local_ref!(env, java_args);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_catch_clause(map: &mut ByteToIndexMap, node: &CatchClause) {
  map.register_by_span(&node.span);
  node.param.as_ref().map(|node| enum_register_pat(map, node));
  register_block_stmt(map, &node.body);
}

fn create_catch_clause<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &CatchClause) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_optional_param = node.param.as_ref().map(|node| enum_create_pat(env, map, node));
  let java_body = create_block_stmt(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_CATCH_CLAUSE.as_ref().unwrap() }
    .construct(env, &java_optional_param, &java_body, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_param);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_class(map: &mut ByteToIndexMap, node: &Class) {
  map.register_by_span(&node.span);
  node.decorators.iter().for_each(|node| {
    register_decorator(map, node);
  });
  node.body.iter().for_each(|node| {
    enum_register_class_member(map, node);
  });
  node.super_class.as_ref().map(|node| enum_register_expr(map, node));
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
  node.super_type_params.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
  node.implements.iter().for_each(|node| {
    register_ts_expr_with_type_args(map, node);
  });
}

fn create_class<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Class) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_decorators = list_new(env, node.decorators.len());
  node.decorators.iter().for_each(|node| {
    let java_node = create_decorator(env, map, node);
    list_add(env, &java_decorators, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_body = list_new(env, node.body.len());
  node.body.iter().for_each(|node| {
    let java_node = enum_create_class_member(env, map, node);
    list_add(env, &java_body, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_super_class = node.super_class.as_ref().map(|node| enum_create_expr(env, map, node));
  let is_abstract = node.is_abstract;
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let java_optional_super_type_params = node.super_type_params.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let java_implements = list_new(env, node.implements.len());
  node.implements.iter().for_each(|node| {
    let java_node = create_ts_expr_with_type_args(env, map, node);
    list_add(env, &java_implements, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_CLASS.as_ref().unwrap() }
    .construct(env, &java_decorators, &java_body, &java_optional_super_class, is_abstract, &java_optional_type_params, &java_optional_super_type_params, &java_implements, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_super_class);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_optional_ref!(env, java_optional_super_type_params);
  delete_local_ref!(env, java_decorators);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_implements);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_class_decl(map: &mut ByteToIndexMap, node: &ClassDecl) {
  map.register_by_span(&node.span());
  register_ident(map, &node.ident);
  register_class(map, &node.class);
}

fn create_class_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ClassDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_ident = create_ident(env, map, &node.ident);
  let declare = node.declare;
  let java_class = create_class(env, map, &node.class);
  let return_value = unsafe { JAVA_CLASS_CLASS_DECL.as_ref().unwrap() }
    .construct(env, &java_ident, declare, &java_class, &java_span_ex);
  delete_local_ref!(env, java_ident);
  delete_local_ref!(env, java_class);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_class_expr(map: &mut ByteToIndexMap, node: &ClassExpr) {
  map.register_by_span(&node.span());
  node.ident.as_ref().map(|node| register_ident(map, node));
  register_class(map, &node.class);
}

fn create_class_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ClassExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_optional_ident = node.ident.as_ref().map(|node| create_ident(env, map, node));
  let java_class = create_class(env, map, &node.class);
  let return_value = unsafe { JAVA_CLASS_CLASS_EXPR.as_ref().unwrap() }
    .construct(env, &java_optional_ident, &java_class, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_ident);
  delete_local_ref!(env, java_class);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_class_method(map: &mut ByteToIndexMap, node: &ClassMethod) {
  map.register_by_span(&node.span);
  enum_register_prop_name(map, &node.key);
  register_function(map, &node.function);
}

fn create_class_method<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ClassMethod) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_key = enum_create_prop_name(env, map, &node.key);
  let java_function = create_function(env, map, &node.function);
  let java_kind = node.kind.to_java(env);
  let is_static = node.is_static;
  let java_optional_accessibility = node.accessibility.as_ref().map(|node| node.to_java(env));
  let is_abstract = node.is_abstract;
  let is_optional = node.is_optional;
  let is_override = node.is_override;
  let return_value = unsafe { JAVA_CLASS_CLASS_METHOD.as_ref().unwrap() }
    .construct(env, &java_key, &java_function, &java_kind, is_static, &java_optional_accessibility, is_abstract, is_optional, is_override, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_accessibility);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_function);
  delete_local_ref!(env, java_kind);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_class_prop(map: &mut ByteToIndexMap, node: &ClassProp) {
  map.register_by_span(&node.span);
  enum_register_prop_name(map, &node.key);
  node.value.as_ref().map(|node| enum_register_expr(map, node));
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
  node.decorators.iter().for_each(|node| {
    register_decorator(map, node);
  });
}

fn create_class_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ClassProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_key = enum_create_prop_name(env, map, &node.key);
  let java_optional_value = node.value.as_ref().map(|node| enum_create_expr(env, map, node));
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let is_static = node.is_static;
  let java_decorators = list_new(env, node.decorators.len());
  node.decorators.iter().for_each(|node| {
    let java_node = create_decorator(env, map, node);
    list_add(env, &java_decorators, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_accessibility = node.accessibility.as_ref().map(|node| node.to_java(env));
  let is_abstract = node.is_abstract;
  let is_optional = node.is_optional;
  let is_override = node.is_override;
  let readonly = node.readonly;
  let declare = node.declare;
  let definite = node.definite;
  let return_value = unsafe { JAVA_CLASS_CLASS_PROP.as_ref().unwrap() }
    .construct(env, &java_key, &java_optional_value, &java_optional_type_ann, is_static, &java_decorators, &java_optional_accessibility, is_abstract, is_optional, is_override, readonly, declare, definite, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_value);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_optional_ref!(env, java_optional_accessibility);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_decorators);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_computed_prop_name(map: &mut ByteToIndexMap, node: &ComputedPropName) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
}

fn create_computed_prop_name<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ComputedPropName) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_COMPUTED_PROP_NAME.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_cond_expr(map: &mut ByteToIndexMap, node: &CondExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.test);
  enum_register_expr(map, &node.cons);
  enum_register_expr(map, &node.alt);
}

fn create_cond_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &CondExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_test = enum_create_expr(env, map, &node.test);
  let java_cons = enum_create_expr(env, map, &node.cons);
  let java_alt = enum_create_expr(env, map, &node.alt);
  let return_value = unsafe { JAVA_CLASS_COND_EXPR.as_ref().unwrap() }
    .construct(env, &java_test, &java_cons, &java_alt, &java_span_ex);
  delete_local_ref!(env, java_test);
  delete_local_ref!(env, java_cons);
  delete_local_ref!(env, java_alt);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_constructor(map: &mut ByteToIndexMap, node: &Constructor) {
  map.register_by_span(&node.span);
  enum_register_prop_name(map, &node.key);
  node.params.iter().for_each(|node| {
    enum_register_param_or_ts_param_prop(map, node);
  });
  node.body.as_ref().map(|node| register_block_stmt(map, node));
}

fn create_constructor<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Constructor) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_key = enum_create_prop_name(env, map, &node.key);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_param_or_ts_param_prop(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_body = node.body.as_ref().map(|node| create_block_stmt(env, map, node));
  let java_optional_accessibility = node.accessibility.as_ref().map(|node| node.to_java(env));
  let is_optional = node.is_optional;
  let return_value = unsafe { JAVA_CLASS_CONSTRUCTOR.as_ref().unwrap() }
    .construct(env, &java_key, &java_params, &java_optional_body, &java_optional_accessibility, is_optional, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_body);
  delete_local_optional_ref!(env, java_optional_accessibility);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_continue_stmt(map: &mut ByteToIndexMap, node: &ContinueStmt) {
  map.register_by_span(&node.span);
  node.label.as_ref().map(|node| register_ident(map, node));
}

fn create_continue_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ContinueStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_optional_label = node.label.as_ref().map(|node| create_ident(env, map, node));
  let return_value = unsafe { JAVA_CLASS_CONTINUE_STMT.as_ref().unwrap() }
    .construct(env, &java_optional_label, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_label);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_debugger_stmt(map: &mut ByteToIndexMap, node: &DebuggerStmt) {
  map.register_by_span(&node.span);
}

fn create_debugger_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &DebuggerStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_DEBUGGER_STMT.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_decorator(map: &mut ByteToIndexMap, node: &Decorator) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
}

fn create_decorator<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Decorator) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_DECORATOR.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_do_while_stmt(map: &mut ByteToIndexMap, node: &DoWhileStmt) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.test);
  enum_register_stmt(map, &node.body);
}

fn create_do_while_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &DoWhileStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_test = enum_create_expr(env, map, &node.test);
  let java_body = enum_create_stmt(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_DO_WHILE_STMT.as_ref().unwrap() }
    .construct(env, &java_test, &java_body, &java_span_ex);
  delete_local_ref!(env, java_test);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_empty_stmt(map: &mut ByteToIndexMap, node: &EmptyStmt) {
  map.register_by_span(&node.span);
}

fn create_empty_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &EmptyStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_EMPTY_STMT.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_export_all(map: &mut ByteToIndexMap, node: &ExportAll) {
  map.register_by_span(&node.span);
  register_str(map, &node.src);
  node.with.as_ref().map(|node| register_object_lit(map, node));
}

fn create_export_all<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ExportAll) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_src = create_str(env, map, &node.src);
  let type_only = node.type_only;
  let java_optional_with = node.with.as_ref().map(|node| create_object_lit(env, map, node));
  let return_value = unsafe { JAVA_CLASS_EXPORT_ALL.as_ref().unwrap() }
    .construct(env, &java_src, type_only, &java_optional_with, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_with);
  delete_local_ref!(env, java_src);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_export_decl(map: &mut ByteToIndexMap, node: &ExportDecl) {
  map.register_by_span(&node.span);
  enum_register_decl(map, &node.decl);
}

fn create_export_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ExportDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_decl = enum_create_decl(env, map, &node.decl);
  let return_value = unsafe { JAVA_CLASS_EXPORT_DECL.as_ref().unwrap() }
    .construct(env, &java_decl, &java_span_ex);
  delete_local_ref!(env, java_decl);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_export_default_decl(map: &mut ByteToIndexMap, node: &ExportDefaultDecl) {
  map.register_by_span(&node.span);
  enum_register_default_decl(map, &node.decl);
}

fn create_export_default_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ExportDefaultDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_decl = enum_create_default_decl(env, map, &node.decl);
  let return_value = unsafe { JAVA_CLASS_EXPORT_DEFAULT_DECL.as_ref().unwrap() }
    .construct(env, &java_decl, &java_span_ex);
  delete_local_ref!(env, java_decl);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_export_default_expr(map: &mut ByteToIndexMap, node: &ExportDefaultExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
}

fn create_export_default_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ExportDefaultExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_EXPORT_DEFAULT_EXPR.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_export_default_specifier(map: &mut ByteToIndexMap, node: &ExportDefaultSpecifier) {
  map.register_by_span(&node.span());
  register_ident(map, &node.exported);
}

fn create_export_default_specifier<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ExportDefaultSpecifier) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_exported = create_ident(env, map, &node.exported);
  let return_value = unsafe { JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER.as_ref().unwrap() }
    .construct(env, &java_exported, &java_span_ex);
  delete_local_ref!(env, java_exported);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_export_named_specifier(map: &mut ByteToIndexMap, node: &ExportNamedSpecifier) {
  map.register_by_span(&node.span);
  enum_register_module_export_name(map, &node.orig);
  node.exported.as_ref().map(|node| enum_register_module_export_name(map, node));
}

fn create_export_named_specifier<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ExportNamedSpecifier) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_orig = enum_create_module_export_name(env, map, &node.orig);
  let java_optional_exported = node.exported.as_ref().map(|node| enum_create_module_export_name(env, map, node));
  let is_type_only = node.is_type_only;
  let return_value = unsafe { JAVA_CLASS_EXPORT_NAMED_SPECIFIER.as_ref().unwrap() }
    .construct(env, &java_orig, &java_optional_exported, is_type_only, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_exported);
  delete_local_ref!(env, java_orig);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_export_namespace_specifier(map: &mut ByteToIndexMap, node: &ExportNamespaceSpecifier) {
  map.register_by_span(&node.span);
  enum_register_module_export_name(map, &node.name);
}

fn create_export_namespace_specifier<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ExportNamespaceSpecifier) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_name = enum_create_module_export_name(env, map, &node.name);
  let return_value = unsafe { JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER.as_ref().unwrap() }
    .construct(env, &java_name, &java_span_ex);
  delete_local_ref!(env, java_name);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_expr_or_spread(map: &mut ByteToIndexMap, node: &ExprOrSpread) {
  map.register_by_span(&node.span());
  node.spread.as_ref().map(|node| map.register_by_span(node));
  enum_register_expr(map, &node.expr);
}

fn create_expr_or_spread<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ExprOrSpread) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_optional_spread = node.spread.as_ref().map(|node| map.get_span_ex_by_span(node).to_java(env));
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_EXPR_OR_SPREAD.as_ref().unwrap() }
    .construct(env, &java_optional_spread, &java_expr, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_spread);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_expr_stmt(map: &mut ByteToIndexMap, node: &ExprStmt) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
}

fn create_expr_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ExprStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_EXPR_STMT.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_fn_decl(map: &mut ByteToIndexMap, node: &FnDecl) {
  map.register_by_span(&node.span());
  register_ident(map, &node.ident);
  register_function(map, &node.function);
}

fn create_fn_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &FnDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_ident = create_ident(env, map, &node.ident);
  let declare = node.declare;
  let java_function = create_function(env, map, &node.function);
  let return_value = unsafe { JAVA_CLASS_FN_DECL.as_ref().unwrap() }
    .construct(env, &java_ident, declare, &java_function, &java_span_ex);
  delete_local_ref!(env, java_ident);
  delete_local_ref!(env, java_function);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_fn_expr(map: &mut ByteToIndexMap, node: &FnExpr) {
  map.register_by_span(&node.span());
  node.ident.as_ref().map(|node| register_ident(map, node));
  register_function(map, &node.function);
}

fn create_fn_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &FnExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_optional_ident = node.ident.as_ref().map(|node| create_ident(env, map, node));
  let java_function = create_function(env, map, &node.function);
  let return_value = unsafe { JAVA_CLASS_FN_EXPR.as_ref().unwrap() }
    .construct(env, &java_optional_ident, &java_function, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_ident);
  delete_local_ref!(env, java_function);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_for_in_stmt(map: &mut ByteToIndexMap, node: &ForInStmt) {
  map.register_by_span(&node.span);
  enum_register_for_head(map, &node.left);
  enum_register_expr(map, &node.right);
  enum_register_stmt(map, &node.body);
}

fn create_for_in_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ForInStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_left = enum_create_for_head(env, map, &node.left);
  let java_right = enum_create_expr(env, map, &node.right);
  let java_body = enum_create_stmt(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_FOR_IN_STMT.as_ref().unwrap() }
    .construct(env, &java_left, &java_right, &java_body, &java_span_ex);
  delete_local_ref!(env, java_left);
  delete_local_ref!(env, java_right);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_for_of_stmt(map: &mut ByteToIndexMap, node: &ForOfStmt) {
  map.register_by_span(&node.span);
  enum_register_for_head(map, &node.left);
  enum_register_expr(map, &node.right);
  enum_register_stmt(map, &node.body);
}

fn create_for_of_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ForOfStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let is_await = node.is_await;
  let java_left = enum_create_for_head(env, map, &node.left);
  let java_right = enum_create_expr(env, map, &node.right);
  let java_body = enum_create_stmt(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_FOR_OF_STMT.as_ref().unwrap() }
    .construct(env, is_await, &java_left, &java_right, &java_body, &java_span_ex);
  delete_local_ref!(env, java_left);
  delete_local_ref!(env, java_right);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_for_stmt(map: &mut ByteToIndexMap, node: &ForStmt) {
  map.register_by_span(&node.span);
  node.init.as_ref().map(|node| enum_register_var_decl_or_expr(map, node));
  node.test.as_ref().map(|node| enum_register_expr(map, node));
  node.update.as_ref().map(|node| enum_register_expr(map, node));
  enum_register_stmt(map, &node.body);
}

fn create_for_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ForStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_optional_init = node.init.as_ref().map(|node| enum_create_var_decl_or_expr(env, map, node));
  let java_optional_test = node.test.as_ref().map(|node| enum_create_expr(env, map, node));
  let java_optional_update = node.update.as_ref().map(|node| enum_create_expr(env, map, node));
  let java_body = enum_create_stmt(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_FOR_STMT.as_ref().unwrap() }
    .construct(env, &java_optional_init, &java_optional_test, &java_optional_update, &java_body, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_init);
  delete_local_optional_ref!(env, java_optional_test);
  delete_local_optional_ref!(env, java_optional_update);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_function(map: &mut ByteToIndexMap, node: &Function) {
  map.register_by_span(&node.span);
  node.params.iter().for_each(|node| {
    register_param(map, node);
  });
  node.decorators.iter().for_each(|node| {
    register_decorator(map, node);
  });
  node.body.as_ref().map(|node| register_block_stmt(map, node));
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
  node.return_type.as_ref().map(|node| register_ts_type_ann(map, node));
}

fn create_function<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Function) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = create_param(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_decorators = list_new(env, node.decorators.len());
  node.decorators.iter().for_each(|node| {
    let java_node = create_decorator(env, map, node);
    list_add(env, &java_decorators, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_body = node.body.as_ref().map(|node| create_block_stmt(env, map, node));
  let is_generator = node.is_generator;
  let is_async = node.is_async;
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let java_optional_return_type = node.return_type.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let return_value = unsafe { JAVA_CLASS_FUNCTION.as_ref().unwrap() }
    .construct(env, &java_params, &java_decorators, &java_optional_body, is_generator, is_async, &java_optional_type_params, &java_optional_return_type, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_body);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_optional_ref!(env, java_optional_return_type);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_decorators);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_getter_prop(map: &mut ByteToIndexMap, node: &GetterProp) {
  map.register_by_span(&node.span);
  enum_register_prop_name(map, &node.key);
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
  node.body.as_ref().map(|node| register_block_stmt(map, node));
}

fn create_getter_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &GetterProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_key = enum_create_prop_name(env, map, &node.key);
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let java_optional_body = node.body.as_ref().map(|node| create_block_stmt(env, map, node));
  let return_value = unsafe { JAVA_CLASS_GETTER_PROP.as_ref().unwrap() }
    .construct(env, &java_key, &java_optional_type_ann, &java_optional_body, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_optional_ref!(env, java_optional_body);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ident(map: &mut ByteToIndexMap, node: &Ident) {
  map.register_by_span(&node.span);
}

fn create_ident<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Ident) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let sym = node.sym.as_str();
  let optional = node.optional;
  let return_value = unsafe { JAVA_CLASS_IDENT.as_ref().unwrap() }
    .construct(env, sym, optional, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_if_stmt(map: &mut ByteToIndexMap, node: &IfStmt) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.test);
  enum_register_stmt(map, &node.cons);
  node.alt.as_ref().map(|node| enum_register_stmt(map, node));
}

fn create_if_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &IfStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_test = enum_create_expr(env, map, &node.test);
  let java_cons = enum_create_stmt(env, map, &node.cons);
  let java_optional_alt = node.alt.as_ref().map(|node| enum_create_stmt(env, map, node));
  let return_value = unsafe { JAVA_CLASS_IF_STMT.as_ref().unwrap() }
    .construct(env, &java_test, &java_cons, &java_optional_alt, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_alt);
  delete_local_ref!(env, java_test);
  delete_local_ref!(env, java_cons);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_import(map: &mut ByteToIndexMap, node: &Import) {
  map.register_by_span(&node.span);
}

fn create_import<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Import) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_phase = node.phase.to_java(env);
  let return_value = unsafe { JAVA_CLASS_IMPORT.as_ref().unwrap() }
    .construct(env, &java_phase, &java_span_ex);
  delete_local_ref!(env, java_phase);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_import_decl(map: &mut ByteToIndexMap, node: &ImportDecl) {
  map.register_by_span(&node.span);
  node.specifiers.iter().for_each(|node| {
    enum_register_import_specifier(map, node);
  });
  register_str(map, &node.src);
  node.with.as_ref().map(|node| register_object_lit(map, node));
}

fn create_import_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ImportDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_specifiers = list_new(env, node.specifiers.len());
  node.specifiers.iter().for_each(|node| {
    let java_node = enum_create_import_specifier(env, map, node);
    list_add(env, &java_specifiers, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_src = create_str(env, map, &node.src);
  let type_only = node.type_only;
  let java_optional_with = node.with.as_ref().map(|node| create_object_lit(env, map, node));
  let java_phase = node.phase.to_java(env);
  let return_value = unsafe { JAVA_CLASS_IMPORT_DECL.as_ref().unwrap() }
    .construct(env, &java_specifiers, &java_src, type_only, &java_optional_with, &java_phase, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_with);
  delete_local_ref!(env, java_specifiers);
  delete_local_ref!(env, java_src);
  delete_local_ref!(env, java_phase);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_import_default_specifier(map: &mut ByteToIndexMap, node: &ImportDefaultSpecifier) {
  map.register_by_span(&node.span);
  register_ident(map, &node.local);
}

fn create_import_default_specifier<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ImportDefaultSpecifier) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_local = create_ident(env, map, &node.local);
  let return_value = unsafe { JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER.as_ref().unwrap() }
    .construct(env, &java_local, &java_span_ex);
  delete_local_ref!(env, java_local);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_import_named_specifier(map: &mut ByteToIndexMap, node: &ImportNamedSpecifier) {
  map.register_by_span(&node.span);
  register_ident(map, &node.local);
  node.imported.as_ref().map(|node| enum_register_module_export_name(map, node));
}

fn create_import_named_specifier<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ImportNamedSpecifier) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_local = create_ident(env, map, &node.local);
  let java_optional_imported = node.imported.as_ref().map(|node| enum_create_module_export_name(env, map, node));
  let is_type_only = node.is_type_only;
  let return_value = unsafe { JAVA_CLASS_IMPORT_NAMED_SPECIFIER.as_ref().unwrap() }
    .construct(env, &java_local, &java_optional_imported, is_type_only, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_imported);
  delete_local_ref!(env, java_local);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_import_star_as_specifier(map: &mut ByteToIndexMap, node: &ImportStarAsSpecifier) {
  map.register_by_span(&node.span);
  register_ident(map, &node.local);
}

fn create_import_star_as_specifier<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ImportStarAsSpecifier) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_local = create_ident(env, map, &node.local);
  let return_value = unsafe { JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER.as_ref().unwrap() }
    .construct(env, &java_local, &java_span_ex);
  delete_local_ref!(env, java_local);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_invalid(map: &mut ByteToIndexMap, node: &Invalid) {
  map.register_by_span(&node.span);
}

fn create_invalid<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Invalid) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_INVALID.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_attr(map: &mut ByteToIndexMap, node: &JSXAttr) {
  map.register_by_span(&node.span);
  enum_register_jsx_attr_name(map, &node.name);
  node.value.as_ref().map(|node| enum_register_jsx_attr_value(map, node));
}

fn create_jsx_attr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXAttr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_name = enum_create_jsx_attr_name(env, map, &node.name);
  let java_optional_value = node.value.as_ref().map(|node| enum_create_jsx_attr_value(env, map, node));
  let return_value = unsafe { JAVA_CLASS_JSX_ATTR.as_ref().unwrap() }
    .construct(env, &java_name, &java_optional_value, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_value);
  delete_local_ref!(env, java_name);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_closing_element(map: &mut ByteToIndexMap, node: &JSXClosingElement) {
  map.register_by_span(&node.span);
  enum_register_jsx_element_name(map, &node.name);
}

fn create_jsx_closing_element<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXClosingElement) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_name = enum_create_jsx_element_name(env, map, &node.name);
  let return_value = unsafe { JAVA_CLASS_JSX_CLOSING_ELEMENT.as_ref().unwrap() }
    .construct(env, &java_name, &java_span_ex);
  delete_local_ref!(env, java_name);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_closing_fragment(map: &mut ByteToIndexMap, node: &JSXClosingFragment) {
  map.register_by_span(&node.span);
}

fn create_jsx_closing_fragment<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXClosingFragment) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_JSX_CLOSING_FRAGMENT.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_element(map: &mut ByteToIndexMap, node: &JSXElement) {
  map.register_by_span(&node.span);
  register_jsx_opening_element(map, &node.opening);
  node.children.iter().for_each(|node| {
    enum_register_jsx_element_child(map, node);
  });
  node.closing.as_ref().map(|node| register_jsx_closing_element(map, node));
}

fn create_jsx_element<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXElement) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_opening = create_jsx_opening_element(env, map, &node.opening);
  let java_children = list_new(env, node.children.len());
  node.children.iter().for_each(|node| {
    let java_node = enum_create_jsx_element_child(env, map, node);
    list_add(env, &java_children, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_closing = node.closing.as_ref().map(|node| create_jsx_closing_element(env, map, node));
  let return_value = unsafe { JAVA_CLASS_JSX_ELEMENT.as_ref().unwrap() }
    .construct(env, &java_opening, &java_children, &java_optional_closing, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_closing);
  delete_local_ref!(env, java_opening);
  delete_local_ref!(env, java_children);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_empty_expr(map: &mut ByteToIndexMap, node: &JSXEmptyExpr) {
  map.register_by_span(&node.span);
}

fn create_jsx_empty_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXEmptyExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_JSX_EMPTY_EXPR.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_expr_container(map: &mut ByteToIndexMap, node: &JSXExprContainer) {
  map.register_by_span(&node.span);
  enum_register_jsx_expr(map, &node.expr);
}

fn create_jsx_expr_container<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXExprContainer) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_jsx_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_JSX_EXPR_CONTAINER.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_fragment(map: &mut ByteToIndexMap, node: &JSXFragment) {
  map.register_by_span(&node.span);
  register_jsx_opening_fragment(map, &node.opening);
  node.children.iter().for_each(|node| {
    enum_register_jsx_element_child(map, node);
  });
  register_jsx_closing_fragment(map, &node.closing);
}

fn create_jsx_fragment<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXFragment) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_opening = create_jsx_opening_fragment(env, map, &node.opening);
  let java_children = list_new(env, node.children.len());
  node.children.iter().for_each(|node| {
    let java_node = enum_create_jsx_element_child(env, map, node);
    list_add(env, &java_children, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_closing = create_jsx_closing_fragment(env, map, &node.closing);
  let return_value = unsafe { JAVA_CLASS_JSX_FRAGMENT.as_ref().unwrap() }
    .construct(env, &java_opening, &java_children, &java_closing, &java_span_ex);
  delete_local_ref!(env, java_opening);
  delete_local_ref!(env, java_children);
  delete_local_ref!(env, java_closing);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_member_expr(map: &mut ByteToIndexMap, node: &JSXMemberExpr) {
  map.register_by_span(&node.span());
  enum_register_jsx_object(map, &node.obj);
  register_ident(map, &node.prop);
}

fn create_jsx_member_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXMemberExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_obj = enum_create_jsx_object(env, map, &node.obj);
  let java_prop = create_ident(env, map, &node.prop);
  let return_value = unsafe { JAVA_CLASS_JSX_MEMBER_EXPR.as_ref().unwrap() }
    .construct(env, &java_obj, &java_prop, &java_span_ex);
  delete_local_ref!(env, java_obj);
  delete_local_ref!(env, java_prop);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_namespaced_name(map: &mut ByteToIndexMap, node: &JSXNamespacedName) {
  map.register_by_span(&node.span());
  register_ident(map, &node.ns);
  register_ident(map, &node.name);
}

fn create_jsx_namespaced_name<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXNamespacedName) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_ns = create_ident(env, map, &node.ns);
  let java_name = create_ident(env, map, &node.name);
  let return_value = unsafe { JAVA_CLASS_JSX_NAMESPACED_NAME.as_ref().unwrap() }
    .construct(env, &java_ns, &java_name, &java_span_ex);
  delete_local_ref!(env, java_ns);
  delete_local_ref!(env, java_name);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_opening_element(map: &mut ByteToIndexMap, node: &JSXOpeningElement) {
  map.register_by_span(&node.span);
  enum_register_jsx_element_name(map, &node.name);
  node.attrs.iter().for_each(|node| {
    enum_register_jsx_attr_or_spread(map, node);
  });
  node.type_args.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
}

fn create_jsx_opening_element<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXOpeningElement) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_name = enum_create_jsx_element_name(env, map, &node.name);
  let java_attrs = list_new(env, node.attrs.len());
  node.attrs.iter().for_each(|node| {
    let java_node = enum_create_jsx_attr_or_spread(env, map, node);
    list_add(env, &java_attrs, &java_node);
    delete_local_ref!(env, java_node);
  });
  let self_closing = node.self_closing;
  let java_optional_type_args = node.type_args.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let return_value = unsafe { JAVA_CLASS_JSX_OPENING_ELEMENT.as_ref().unwrap() }
    .construct(env, &java_name, &java_attrs, self_closing, &java_optional_type_args, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_args);
  delete_local_ref!(env, java_name);
  delete_local_ref!(env, java_attrs);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_opening_fragment(map: &mut ByteToIndexMap, node: &JSXOpeningFragment) {
  map.register_by_span(&node.span);
}

fn create_jsx_opening_fragment<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXOpeningFragment) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_JSX_OPENING_FRAGMENT.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_spread_child(map: &mut ByteToIndexMap, node: &JSXSpreadChild) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
}

fn create_jsx_spread_child<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXSpreadChild) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_JSX_SPREAD_CHILD.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_jsx_text(map: &mut ByteToIndexMap, node: &JSXText) {
  map.register_by_span(&node.span);
}

fn create_jsx_text<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &JSXText) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let value = node.value.as_str();
  let raw = node.raw.as_str();
  let return_value = unsafe { JAVA_CLASS_JSX_TEXT.as_ref().unwrap() }
    .construct(env, value, raw, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_key_value_pat_prop(map: &mut ByteToIndexMap, node: &KeyValuePatProp) {
  map.register_by_span(&node.span());
  enum_register_prop_name(map, &node.key);
  enum_register_pat(map, &node.value);
}

fn create_key_value_pat_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &KeyValuePatProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_key = enum_create_prop_name(env, map, &node.key);
  let java_value = enum_create_pat(env, map, &node.value);
  let return_value = unsafe { JAVA_CLASS_KEY_VALUE_PAT_PROP.as_ref().unwrap() }
    .construct(env, &java_key, &java_value, &java_span_ex);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_value);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_key_value_prop(map: &mut ByteToIndexMap, node: &KeyValueProp) {
  map.register_by_span(&node.span());
  enum_register_prop_name(map, &node.key);
  enum_register_expr(map, &node.value);
}

fn create_key_value_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &KeyValueProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_key = enum_create_prop_name(env, map, &node.key);
  let java_value = enum_create_expr(env, map, &node.value);
  let return_value = unsafe { JAVA_CLASS_KEY_VALUE_PROP.as_ref().unwrap() }
    .construct(env, &java_key, &java_value, &java_span_ex);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_value);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_labeled_stmt(map: &mut ByteToIndexMap, node: &LabeledStmt) {
  map.register_by_span(&node.span);
  register_ident(map, &node.label);
  enum_register_stmt(map, &node.body);
}

fn create_labeled_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &LabeledStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_label = create_ident(env, map, &node.label);
  let java_body = enum_create_stmt(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_LABELED_STMT.as_ref().unwrap() }
    .construct(env, &java_label, &java_body, &java_span_ex);
  delete_local_ref!(env, java_label);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_member_expr(map: &mut ByteToIndexMap, node: &MemberExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.obj);
  enum_register_member_prop(map, &node.prop);
}

fn create_member_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &MemberExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_obj = enum_create_expr(env, map, &node.obj);
  let java_prop = enum_create_member_prop(env, map, &node.prop);
  let return_value = unsafe { JAVA_CLASS_MEMBER_EXPR.as_ref().unwrap() }
    .construct(env, &java_obj, &java_prop, &java_span_ex);
  delete_local_ref!(env, java_obj);
  delete_local_ref!(env, java_prop);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_meta_prop_expr(map: &mut ByteToIndexMap, node: &MetaPropExpr) {
  map.register_by_span(&node.span);
}

fn create_meta_prop_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &MetaPropExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_kind = node.kind.to_java(env);
  let return_value = unsafe { JAVA_CLASS_META_PROP_EXPR.as_ref().unwrap() }
    .construct(env, &java_kind, &java_span_ex);
  delete_local_ref!(env, java_kind);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_method_prop(map: &mut ByteToIndexMap, node: &MethodProp) {
  map.register_by_span(&node.span());
  enum_register_prop_name(map, &node.key);
  register_function(map, &node.function);
}

fn create_method_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &MethodProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_key = enum_create_prop_name(env, map, &node.key);
  let java_function = create_function(env, map, &node.function);
  let return_value = unsafe { JAVA_CLASS_METHOD_PROP.as_ref().unwrap() }
    .construct(env, &java_key, &java_function, &java_span_ex);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_function);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_module(map: &mut ByteToIndexMap, node: &Module) {
  map.register_by_span(&node.span);
  node.body.iter().for_each(|node| {
    enum_register_module_item(map, node);
  });
}

fn create_module<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Module) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_body = list_new(env, node.body.len());
  node.body.iter().for_each(|node| {
    let java_node = enum_create_module_item(env, map, node);
    list_add(env, &java_body, &java_node);
    delete_local_ref!(env, java_node);
  });
  let optional_shebang = node.shebang.as_ref().map(|node| node.to_string());
  let return_value = unsafe { JAVA_CLASS_MODULE.as_ref().unwrap() }
    .construct(env, &java_body, &optional_shebang, &java_span_ex);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_named_export(map: &mut ByteToIndexMap, node: &NamedExport) {
  map.register_by_span(&node.span);
  node.specifiers.iter().for_each(|node| {
    enum_register_export_specifier(map, node);
  });
  node.src.as_ref().map(|node| register_str(map, node));
  node.with.as_ref().map(|node| register_object_lit(map, node));
}

fn create_named_export<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &NamedExport) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_specifiers = list_new(env, node.specifiers.len());
  node.specifiers.iter().for_each(|node| {
    let java_node = enum_create_export_specifier(env, map, node);
    list_add(env, &java_specifiers, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_src = node.src.as_ref().map(|node| create_str(env, map, node));
  let type_only = node.type_only;
  let java_optional_with = node.with.as_ref().map(|node| create_object_lit(env, map, node));
  let return_value = unsafe { JAVA_CLASS_NAMED_EXPORT.as_ref().unwrap() }
    .construct(env, &java_specifiers, &java_optional_src, type_only, &java_optional_with, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_src);
  delete_local_optional_ref!(env, java_optional_with);
  delete_local_ref!(env, java_specifiers);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_new_expr(map: &mut ByteToIndexMap, node: &NewExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.callee);
  node.args.as_ref().map(|nodes| nodes.iter().for_each(|node| register_expr_or_spread(map, node)));
  node.type_args.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
}

fn create_new_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &NewExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_callee = enum_create_expr(env, map, &node.callee);
  let java_optional_args = node.args.as_ref().map(|nodes| {
    let java_args = list_new(env, nodes.len());
    nodes.iter().for_each(|node| {
      let java_node = create_expr_or_spread(env, map, node);
      list_add(env, &java_args, &java_node);
      delete_local_ref!(env, java_node);
    });
    java_args
  });
  let java_optional_type_args = node.type_args.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let return_value = unsafe { JAVA_CLASS_NEW_EXPR.as_ref().unwrap() }
    .construct(env, &java_callee, &java_optional_args, &java_optional_type_args, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_args);
  delete_local_optional_ref!(env, java_optional_type_args);
  delete_local_ref!(env, java_callee);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_null(map: &mut ByteToIndexMap, node: &Null) {
  map.register_by_span(&node.span);
}

fn create_null<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Null) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_NULL.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_number(map: &mut ByteToIndexMap, node: &Number) {
  map.register_by_span(&node.span);
}

fn create_number<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Number) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let value = node.value;
  let optional_raw = node.raw.as_ref().map(|node| node.to_string());
  let return_value = unsafe { JAVA_CLASS_NUMBER.as_ref().unwrap() }
    .construct(env, value, &optional_raw, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_object_lit(map: &mut ByteToIndexMap, node: &ObjectLit) {
  map.register_by_span(&node.span);
  node.props.iter().for_each(|node| {
    enum_register_prop_or_spread(map, node);
  });
}

fn create_object_lit<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ObjectLit) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_props = list_new(env, node.props.len());
  node.props.iter().for_each(|node| {
    let java_node = enum_create_prop_or_spread(env, map, node);
    list_add(env, &java_props, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_OBJECT_LIT.as_ref().unwrap() }
    .construct(env, &java_props, &java_span_ex);
  delete_local_ref!(env, java_props);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_object_pat(map: &mut ByteToIndexMap, node: &ObjectPat) {
  map.register_by_span(&node.span);
  node.props.iter().for_each(|node| {
    enum_register_object_pat_prop(map, node);
  });
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
}

fn create_object_pat<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ObjectPat) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_props = list_new(env, node.props.len());
  node.props.iter().for_each(|node| {
    let java_node = enum_create_object_pat_prop(env, map, node);
    list_add(env, &java_props, &java_node);
    delete_local_ref!(env, java_node);
  });
  let optional = node.optional;
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let return_value = unsafe { JAVA_CLASS_OBJECT_PAT.as_ref().unwrap() }
    .construct(env, &java_props, optional, &java_optional_type_ann, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_ref!(env, java_props);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_opt_call(map: &mut ByteToIndexMap, node: &OptCall) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.callee);
  node.args.iter().for_each(|node| {
    register_expr_or_spread(map, node);
  });
  node.type_args.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
}

fn create_opt_call<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &OptCall) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_callee = enum_create_expr(env, map, &node.callee);
  let java_args = list_new(env, node.args.len());
  node.args.iter().for_each(|node| {
    let java_node = create_expr_or_spread(env, map, node);
    list_add(env, &java_args, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_type_args = node.type_args.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let return_value = unsafe { JAVA_CLASS_OPT_CALL.as_ref().unwrap() }
    .construct(env, &java_callee, &java_args, &java_optional_type_args, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_args);
  delete_local_ref!(env, java_callee);
  delete_local_ref!(env, java_args);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_opt_chain_expr(map: &mut ByteToIndexMap, node: &OptChainExpr) {
  map.register_by_span(&node.span);
  enum_register_opt_chain_base(map, &node.base);
}

fn create_opt_chain_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &OptChainExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let optional = node.optional;
  let java_base = enum_create_opt_chain_base(env, map, &node.base);
  let return_value = unsafe { JAVA_CLASS_OPT_CHAIN_EXPR.as_ref().unwrap() }
    .construct(env, optional, &java_base, &java_span_ex);
  delete_local_ref!(env, java_base);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_param(map: &mut ByteToIndexMap, node: &Param) {
  map.register_by_span(&node.span);
  node.decorators.iter().for_each(|node| {
    register_decorator(map, node);
  });
  enum_register_pat(map, &node.pat);
}

fn create_param<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Param) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_decorators = list_new(env, node.decorators.len());
  node.decorators.iter().for_each(|node| {
    let java_node = create_decorator(env, map, node);
    list_add(env, &java_decorators, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_pat = enum_create_pat(env, map, &node.pat);
  let return_value = unsafe { JAVA_CLASS_PARAM.as_ref().unwrap() }
    .construct(env, &java_decorators, &java_pat, &java_span_ex);
  delete_local_ref!(env, java_decorators);
  delete_local_ref!(env, java_pat);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_paren_expr(map: &mut ByteToIndexMap, node: &ParenExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
}

fn create_paren_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ParenExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_PAREN_EXPR.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_private_method(map: &mut ByteToIndexMap, node: &PrivateMethod) {
  map.register_by_span(&node.span);
  register_private_name(map, &node.key);
  register_function(map, &node.function);
}

fn create_private_method<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &PrivateMethod) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_key = create_private_name(env, map, &node.key);
  let java_function = create_function(env, map, &node.function);
  let java_kind = node.kind.to_java(env);
  let is_static = node.is_static;
  let java_optional_accessibility = node.accessibility.as_ref().map(|node| node.to_java(env));
  let is_abstract = node.is_abstract;
  let is_optional = node.is_optional;
  let is_override = node.is_override;
  let return_value = unsafe { JAVA_CLASS_PRIVATE_METHOD.as_ref().unwrap() }
    .construct(env, &java_key, &java_function, &java_kind, is_static, &java_optional_accessibility, is_abstract, is_optional, is_override, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_accessibility);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_function);
  delete_local_ref!(env, java_kind);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_private_name(map: &mut ByteToIndexMap, node: &PrivateName) {
  map.register_by_span(&node.span);
  register_ident(map, &node.id);
}

fn create_private_name<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &PrivateName) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_id = create_ident(env, map, &node.id);
  let return_value = unsafe { JAVA_CLASS_PRIVATE_NAME.as_ref().unwrap() }
    .construct(env, &java_id, &java_span_ex);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_private_prop(map: &mut ByteToIndexMap, node: &PrivateProp) {
  map.register_by_span(&node.span);
  register_private_name(map, &node.key);
  node.value.as_ref().map(|node| enum_register_expr(map, node));
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
  node.decorators.iter().for_each(|node| {
    register_decorator(map, node);
  });
}

fn create_private_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &PrivateProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_key = create_private_name(env, map, &node.key);
  let java_optional_value = node.value.as_ref().map(|node| enum_create_expr(env, map, node));
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let is_static = node.is_static;
  let java_decorators = list_new(env, node.decorators.len());
  node.decorators.iter().for_each(|node| {
    let java_node = create_decorator(env, map, node);
    list_add(env, &java_decorators, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_accessibility = node.accessibility.as_ref().map(|node| node.to_java(env));
  let is_optional = node.is_optional;
  let is_override = node.is_override;
  let readonly = node.readonly;
  let definite = node.definite;
  let return_value = unsafe { JAVA_CLASS_PRIVATE_PROP.as_ref().unwrap() }
    .construct(env, &java_key, &java_optional_value, &java_optional_type_ann, is_static, &java_decorators, &java_optional_accessibility, is_optional, is_override, readonly, definite, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_value);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_optional_ref!(env, java_optional_accessibility);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_decorators);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_regex(map: &mut ByteToIndexMap, node: &Regex) {
  map.register_by_span(&node.span);
}

fn create_regex<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Regex) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let exp = node.exp.as_str();
  let flags = node.flags.as_str();
  let return_value = unsafe { JAVA_CLASS_REGEX.as_ref().unwrap() }
    .construct(env, exp, flags, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_rest_pat(map: &mut ByteToIndexMap, node: &RestPat) {
  map.register_by_span(&node.span);
  map.register_by_span(&node.dot3_token);
  enum_register_pat(map, &node.arg);
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
}

fn create_rest_pat<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &RestPat) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_dot3_token = map.get_span_ex_by_span(&node.dot3_token).to_java(env);
  let java_arg = enum_create_pat(env, map, &node.arg);
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let return_value = unsafe { JAVA_CLASS_REST_PAT.as_ref().unwrap() }
    .construct(env, &java_dot3_token, &java_arg, &java_optional_type_ann, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_ref!(env, java_dot3_token);
  delete_local_ref!(env, java_arg);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_return_stmt(map: &mut ByteToIndexMap, node: &ReturnStmt) {
  map.register_by_span(&node.span);
  node.arg.as_ref().map(|node| enum_register_expr(map, node));
}

fn create_return_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ReturnStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_optional_arg = node.arg.as_ref().map(|node| enum_create_expr(env, map, node));
  let return_value = unsafe { JAVA_CLASS_RETURN_STMT.as_ref().unwrap() }
    .construct(env, &java_optional_arg, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_arg);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_script(map: &mut ByteToIndexMap, node: &Script) {
  map.register_by_span(&node.span);
  node.body.iter().for_each(|node| {
    enum_register_stmt(map, node);
  });
}

fn create_script<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Script) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_body = list_new(env, node.body.len());
  node.body.iter().for_each(|node| {
    let java_node = enum_create_stmt(env, map, node);
    list_add(env, &java_body, &java_node);
    delete_local_ref!(env, java_node);
  });
  let optional_shebang = node.shebang.as_ref().map(|node| node.to_string());
  let return_value = unsafe { JAVA_CLASS_SCRIPT.as_ref().unwrap() }
    .construct(env, &java_body, &optional_shebang, &java_span_ex);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_seq_expr(map: &mut ByteToIndexMap, node: &SeqExpr) {
  map.register_by_span(&node.span);
  node.exprs.iter().for_each(|node| {
    enum_register_expr(map, node);
  });
}

fn create_seq_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &SeqExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_exprs = list_new(env, node.exprs.len());
  node.exprs.iter().for_each(|node| {
    let java_node = enum_create_expr(env, map, node);
    list_add(env, &java_exprs, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_SEQ_EXPR.as_ref().unwrap() }
    .construct(env, &java_exprs, &java_span_ex);
  delete_local_ref!(env, java_exprs);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_setter_prop(map: &mut ByteToIndexMap, node: &SetterProp) {
  map.register_by_span(&node.span);
  enum_register_prop_name(map, &node.key);
  node.this_param.as_ref().map(|node| enum_register_pat(map, node));
  enum_register_pat(map, &node.param);
  node.body.as_ref().map(|node| register_block_stmt(map, node));
}

fn create_setter_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &SetterProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_key = enum_create_prop_name(env, map, &node.key);
  let java_optional_this_param = node.this_param.as_ref().map(|node| enum_create_pat(env, map, node));
  let java_param = enum_create_pat(env, map, &node.param);
  let java_optional_body = node.body.as_ref().map(|node| create_block_stmt(env, map, node));
  let return_value = unsafe { JAVA_CLASS_SETTER_PROP.as_ref().unwrap() }
    .construct(env, &java_key, &java_optional_this_param, &java_param, &java_optional_body, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_this_param);
  delete_local_optional_ref!(env, java_optional_body);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_param);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_spread_element(map: &mut ByteToIndexMap, node: &SpreadElement) {
  map.register_by_span(&node.span());
  map.register_by_span(&node.dot3_token);
  enum_register_expr(map, &node.expr);
}

fn create_spread_element<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &SpreadElement) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_dot3_token = map.get_span_ex_by_span(&node.dot3_token).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_SPREAD_ELEMENT.as_ref().unwrap() }
    .construct(env, &java_dot3_token, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_dot3_token);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_static_block(map: &mut ByteToIndexMap, node: &StaticBlock) {
  map.register_by_span(&node.span);
  register_block_stmt(map, &node.body);
}

fn create_static_block<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &StaticBlock) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_body = create_block_stmt(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_STATIC_BLOCK.as_ref().unwrap() }
    .construct(env, &java_body, &java_span_ex);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_str(map: &mut ByteToIndexMap, node: &Str) {
  map.register_by_span(&node.span);
}

fn create_str<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Str) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let value = node.value.as_str();
  let optional_raw = node.raw.as_ref().map(|node| node.to_string());
  let return_value = unsafe { JAVA_CLASS_STR.as_ref().unwrap() }
    .construct(env, value, &optional_raw, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_super(map: &mut ByteToIndexMap, node: &Super) {
  map.register_by_span(&node.span);
}

fn create_super<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Super) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_SUPER.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_super_prop_expr(map: &mut ByteToIndexMap, node: &SuperPropExpr) {
  map.register_by_span(&node.span);
  register_super(map, &node.obj);
  enum_register_super_prop(map, &node.prop);
}

fn create_super_prop_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &SuperPropExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_obj = create_super(env, map, &node.obj);
  let java_prop = enum_create_super_prop(env, map, &node.prop);
  let return_value = unsafe { JAVA_CLASS_SUPER_PROP_EXPR.as_ref().unwrap() }
    .construct(env, &java_obj, &java_prop, &java_span_ex);
  delete_local_ref!(env, java_obj);
  delete_local_ref!(env, java_prop);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_switch_case(map: &mut ByteToIndexMap, node: &SwitchCase) {
  map.register_by_span(&node.span);
  node.test.as_ref().map(|node| enum_register_expr(map, node));
  node.cons.iter().for_each(|node| {
    enum_register_stmt(map, node);
  });
}

fn create_switch_case<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &SwitchCase) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_optional_test = node.test.as_ref().map(|node| enum_create_expr(env, map, node));
  let java_cons = list_new(env, node.cons.len());
  node.cons.iter().for_each(|node| {
    let java_node = enum_create_stmt(env, map, node);
    list_add(env, &java_cons, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_SWITCH_CASE.as_ref().unwrap() }
    .construct(env, &java_optional_test, &java_cons, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_test);
  delete_local_ref!(env, java_cons);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_switch_stmt(map: &mut ByteToIndexMap, node: &SwitchStmt) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.discriminant);
  node.cases.iter().for_each(|node| {
    register_switch_case(map, node);
  });
}

fn create_switch_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &SwitchStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_discriminant = enum_create_expr(env, map, &node.discriminant);
  let java_cases = list_new(env, node.cases.len());
  node.cases.iter().for_each(|node| {
    let java_node = create_switch_case(env, map, node);
    list_add(env, &java_cases, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_SWITCH_STMT.as_ref().unwrap() }
    .construct(env, &java_discriminant, &java_cases, &java_span_ex);
  delete_local_ref!(env, java_discriminant);
  delete_local_ref!(env, java_cases);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_tagged_tpl(map: &mut ByteToIndexMap, node: &TaggedTpl) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.tag);
  node.type_params.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
  register_tpl(map, &node.tpl);
}

fn create_tagged_tpl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TaggedTpl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_tag = enum_create_expr(env, map, &node.tag);
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let java_tpl = create_tpl(env, map, &node.tpl);
  let return_value = unsafe { JAVA_CLASS_TAGGED_TPL.as_ref().unwrap() }
    .construct(env, &java_tag, &java_optional_type_params, &java_tpl, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_tag);
  delete_local_ref!(env, java_tpl);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_this_expr(map: &mut ByteToIndexMap, node: &ThisExpr) {
  map.register_by_span(&node.span);
}

fn create_this_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ThisExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_THIS_EXPR.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_throw_stmt(map: &mut ByteToIndexMap, node: &ThrowStmt) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.arg);
}

fn create_throw_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &ThrowStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_arg = enum_create_expr(env, map, &node.arg);
  let return_value = unsafe { JAVA_CLASS_THROW_STMT.as_ref().unwrap() }
    .construct(env, &java_arg, &java_span_ex);
  delete_local_ref!(env, java_arg);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_tpl(map: &mut ByteToIndexMap, node: &Tpl) {
  map.register_by_span(&node.span);
  node.exprs.iter().for_each(|node| {
    enum_register_expr(map, node);
  });
  node.quasis.iter().for_each(|node| {
    register_tpl_element(map, node);
  });
}

fn create_tpl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &Tpl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_exprs = list_new(env, node.exprs.len());
  node.exprs.iter().for_each(|node| {
    let java_node = enum_create_expr(env, map, node);
    list_add(env, &java_exprs, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_quasis = list_new(env, node.quasis.len());
  node.quasis.iter().for_each(|node| {
    let java_node = create_tpl_element(env, map, node);
    list_add(env, &java_quasis, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TPL.as_ref().unwrap() }
    .construct(env, &java_exprs, &java_quasis, &java_span_ex);
  delete_local_ref!(env, java_exprs);
  delete_local_ref!(env, java_quasis);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_tpl_element(map: &mut ByteToIndexMap, node: &TplElement) {
  map.register_by_span(&node.span);
}

fn create_tpl_element<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TplElement) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let tail = node.tail;
  let optional_cooked = node.cooked.as_ref().map(|node| node.to_string());
  let raw = node.raw.as_str();
  let return_value = unsafe { JAVA_CLASS_TPL_ELEMENT.as_ref().unwrap() }
    .construct(env, tail, &optional_cooked, raw, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_try_stmt(map: &mut ByteToIndexMap, node: &TryStmt) {
  map.register_by_span(&node.span);
  register_block_stmt(map, &node.block);
  node.handler.as_ref().map(|node| register_catch_clause(map, node));
  node.finalizer.as_ref().map(|node| register_block_stmt(map, node));
}

fn create_try_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TryStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_block = create_block_stmt(env, map, &node.block);
  let java_optional_handler = node.handler.as_ref().map(|node| create_catch_clause(env, map, node));
  let java_optional_finalizer = node.finalizer.as_ref().map(|node| create_block_stmt(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TRY_STMT.as_ref().unwrap() }
    .construct(env, &java_block, &java_optional_handler, &java_optional_finalizer, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_handler);
  delete_local_optional_ref!(env, java_optional_finalizer);
  delete_local_ref!(env, java_block);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_array_type(map: &mut ByteToIndexMap, node: &TsArrayType) {
  map.register_by_span(&node.span);
  enum_register_ts_type(map, &node.elem_type);
}

fn create_ts_array_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsArrayType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_elem_type = enum_create_ts_type(env, map, &node.elem_type);
  let return_value = unsafe { JAVA_CLASS_TS_ARRAY_TYPE.as_ref().unwrap() }
    .construct(env, &java_elem_type, &java_span_ex);
  delete_local_ref!(env, java_elem_type);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_as_expr(map: &mut ByteToIndexMap, node: &TsAsExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
  enum_register_ts_type(map, &node.type_ann);
}

fn create_ts_as_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsAsExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let java_type_ann = enum_create_ts_type(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_AS_EXPR.as_ref().unwrap() }
    .construct(env, &java_expr, &java_type_ann, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_call_signature_decl(map: &mut ByteToIndexMap, node: &TsCallSignatureDecl) {
  map.register_by_span(&node.span);
  node.params.iter().for_each(|node| {
    enum_register_ts_fn_param(map, node);
  });
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
}

fn create_ts_call_signature_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsCallSignatureDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_ts_fn_param(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_CALL_SIGNATURE_DECL.as_ref().unwrap() }
    .construct(env, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_conditional_type(map: &mut ByteToIndexMap, node: &TsConditionalType) {
  map.register_by_span(&node.span);
  enum_register_ts_type(map, &node.check_type);
  enum_register_ts_type(map, &node.extends_type);
  enum_register_ts_type(map, &node.true_type);
  enum_register_ts_type(map, &node.false_type);
}

fn create_ts_conditional_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsConditionalType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_check_type = enum_create_ts_type(env, map, &node.check_type);
  let java_extends_type = enum_create_ts_type(env, map, &node.extends_type);
  let java_true_type = enum_create_ts_type(env, map, &node.true_type);
  let java_false_type = enum_create_ts_type(env, map, &node.false_type);
  let return_value = unsafe { JAVA_CLASS_TS_CONDITIONAL_TYPE.as_ref().unwrap() }
    .construct(env, &java_check_type, &java_extends_type, &java_true_type, &java_false_type, &java_span_ex);
  delete_local_ref!(env, java_check_type);
  delete_local_ref!(env, java_extends_type);
  delete_local_ref!(env, java_true_type);
  delete_local_ref!(env, java_false_type);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_const_assertion(map: &mut ByteToIndexMap, node: &TsConstAssertion) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
}

fn create_ts_const_assertion<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsConstAssertion) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_TS_CONST_ASSERTION.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_construct_signature_decl(map: &mut ByteToIndexMap, node: &TsConstructSignatureDecl) {
  map.register_by_span(&node.span);
  node.params.iter().for_each(|node| {
    enum_register_ts_fn_param(map, node);
  });
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
}

fn create_ts_construct_signature_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsConstructSignatureDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_ts_fn_param(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL.as_ref().unwrap() }
    .construct(env, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_constructor_type(map: &mut ByteToIndexMap, node: &TsConstructorType) {
  map.register_by_span(&node.span);
  node.params.iter().for_each(|node| {
    enum_register_ts_fn_param(map, node);
  });
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
  register_ts_type_ann(map, &node.type_ann);
}

fn create_ts_constructor_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsConstructorType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_ts_fn_param(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let java_type_ann = create_ts_type_ann(env, map, &node.type_ann);
  let is_abstract = node.is_abstract;
  let return_value = unsafe { JAVA_CLASS_TS_CONSTRUCTOR_TYPE.as_ref().unwrap() }
    .construct(env, &java_params, &java_optional_type_params, &java_type_ann, is_abstract, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_enum_decl(map: &mut ByteToIndexMap, node: &TsEnumDecl) {
  map.register_by_span(&node.span);
  register_ident(map, &node.id);
  node.members.iter().for_each(|node| {
    register_ts_enum_member(map, node);
  });
}

fn create_ts_enum_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsEnumDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let declare = node.declare;
  let is_const = node.is_const;
  let java_id = create_ident(env, map, &node.id);
  let java_members = list_new(env, node.members.len());
  node.members.iter().for_each(|node| {
    let java_node = create_ts_enum_member(env, map, node);
    list_add(env, &java_members, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_ENUM_DECL.as_ref().unwrap() }
    .construct(env, declare, is_const, &java_id, &java_members, &java_span_ex);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_members);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_enum_member(map: &mut ByteToIndexMap, node: &TsEnumMember) {
  map.register_by_span(&node.span);
  enum_register_ts_enum_member_id(map, &node.id);
  node.init.as_ref().map(|node| enum_register_expr(map, node));
}

fn create_ts_enum_member<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsEnumMember) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_id = enum_create_ts_enum_member_id(env, map, &node.id);
  let java_optional_init = node.init.as_ref().map(|node| enum_create_expr(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_ENUM_MEMBER.as_ref().unwrap() }
    .construct(env, &java_id, &java_optional_init, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_init);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_export_assignment(map: &mut ByteToIndexMap, node: &TsExportAssignment) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
}

fn create_ts_export_assignment<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsExportAssignment) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_TS_EXPORT_ASSIGNMENT.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_expr_with_type_args(map: &mut ByteToIndexMap, node: &TsExprWithTypeArgs) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
  node.type_args.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
}

fn create_ts_expr_with_type_args<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsExprWithTypeArgs) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let java_optional_type_args = node.type_args.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS.as_ref().unwrap() }
    .construct(env, &java_expr, &java_optional_type_args, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_args);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_external_module_ref(map: &mut ByteToIndexMap, node: &TsExternalModuleRef) {
  map.register_by_span(&node.span);
  register_str(map, &node.expr);
}

fn create_ts_external_module_ref<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsExternalModuleRef) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = create_str(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_TS_EXTERNAL_MODULE_REF.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_fn_type(map: &mut ByteToIndexMap, node: &TsFnType) {
  map.register_by_span(&node.span);
  node.params.iter().for_each(|node| {
    enum_register_ts_fn_param(map, node);
  });
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
  register_ts_type_ann(map, &node.type_ann);
}

fn create_ts_fn_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsFnType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_ts_fn_param(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let java_type_ann = create_ts_type_ann(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_FN_TYPE.as_ref().unwrap() }
    .construct(env, &java_params, &java_optional_type_params, &java_type_ann, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_getter_signature(map: &mut ByteToIndexMap, node: &TsGetterSignature) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.key);
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
}

fn create_ts_getter_signature<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsGetterSignature) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let readonly = node.readonly;
  let java_key = enum_create_expr(env, map, &node.key);
  let computed = node.computed;
  let optional = node.optional;
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_GETTER_SIGNATURE.as_ref().unwrap() }
    .construct(env, readonly, &java_key, computed, optional, &java_optional_type_ann, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_import_equals_decl(map: &mut ByteToIndexMap, node: &TsImportEqualsDecl) {
  map.register_by_span(&node.span);
  register_ident(map, &node.id);
  enum_register_ts_module_ref(map, &node.module_ref);
}

fn create_ts_import_equals_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsImportEqualsDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let is_export = node.is_export;
  let is_type_only = node.is_type_only;
  let java_id = create_ident(env, map, &node.id);
  let java_module_ref = enum_create_ts_module_ref(env, map, &node.module_ref);
  let return_value = unsafe { JAVA_CLASS_TS_IMPORT_EQUALS_DECL.as_ref().unwrap() }
    .construct(env, is_export, is_type_only, &java_id, &java_module_ref, &java_span_ex);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_module_ref);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_import_type(map: &mut ByteToIndexMap, node: &TsImportType) {
  map.register_by_span(&node.span);
  register_str(map, &node.arg);
  node.qualifier.as_ref().map(|node| enum_register_ts_entity_name(map, node));
  node.type_args.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
}

fn create_ts_import_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsImportType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_arg = create_str(env, map, &node.arg);
  let java_optional_qualifier = node.qualifier.as_ref().map(|node| enum_create_ts_entity_name(env, map, node));
  let java_optional_type_args = node.type_args.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_IMPORT_TYPE.as_ref().unwrap() }
    .construct(env, &java_arg, &java_optional_qualifier, &java_optional_type_args, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_qualifier);
  delete_local_optional_ref!(env, java_optional_type_args);
  delete_local_ref!(env, java_arg);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_index_signature(map: &mut ByteToIndexMap, node: &TsIndexSignature) {
  map.register_by_span(&node.span);
  node.params.iter().for_each(|node| {
    enum_register_ts_fn_param(map, node);
  });
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
}

fn create_ts_index_signature<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsIndexSignature) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_ts_fn_param(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let readonly = node.readonly;
  let is_static = node.is_static;
  let return_value = unsafe { JAVA_CLASS_TS_INDEX_SIGNATURE.as_ref().unwrap() }
    .construct(env, &java_params, &java_optional_type_ann, readonly, is_static, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_indexed_access_type(map: &mut ByteToIndexMap, node: &TsIndexedAccessType) {
  map.register_by_span(&node.span);
  enum_register_ts_type(map, &node.obj_type);
  enum_register_ts_type(map, &node.index_type);
}

fn create_ts_indexed_access_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsIndexedAccessType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let readonly = node.readonly;
  let java_obj_type = enum_create_ts_type(env, map, &node.obj_type);
  let java_index_type = enum_create_ts_type(env, map, &node.index_type);
  let return_value = unsafe { JAVA_CLASS_TS_INDEXED_ACCESS_TYPE.as_ref().unwrap() }
    .construct(env, readonly, &java_obj_type, &java_index_type, &java_span_ex);
  delete_local_ref!(env, java_obj_type);
  delete_local_ref!(env, java_index_type);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_infer_type(map: &mut ByteToIndexMap, node: &TsInferType) {
  map.register_by_span(&node.span);
  register_ts_type_param(map, &node.type_param);
}

fn create_ts_infer_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsInferType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_type_param = create_ts_type_param(env, map, &node.type_param);
  let return_value = unsafe { JAVA_CLASS_TS_INFER_TYPE.as_ref().unwrap() }
    .construct(env, &java_type_param, &java_span_ex);
  delete_local_ref!(env, java_type_param);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_instantiation(map: &mut ByteToIndexMap, node: &TsInstantiation) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
  register_ts_type_param_instantiation(map, &node.type_args);
}

fn create_ts_instantiation<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsInstantiation) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let java_type_args = create_ts_type_param_instantiation(env, map, &node.type_args);
  let return_value = unsafe { JAVA_CLASS_TS_INSTANTIATION.as_ref().unwrap() }
    .construct(env, &java_expr, &java_type_args, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_type_args);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_interface_body(map: &mut ByteToIndexMap, node: &TsInterfaceBody) {
  map.register_by_span(&node.span);
  node.body.iter().for_each(|node| {
    enum_register_ts_type_element(map, node);
  });
}

fn create_ts_interface_body<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsInterfaceBody) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_body = list_new(env, node.body.len());
  node.body.iter().for_each(|node| {
    let java_node = enum_create_ts_type_element(env, map, node);
    list_add(env, &java_body, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_INTERFACE_BODY.as_ref().unwrap() }
    .construct(env, &java_body, &java_span_ex);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_interface_decl(map: &mut ByteToIndexMap, node: &TsInterfaceDecl) {
  map.register_by_span(&node.span);
  register_ident(map, &node.id);
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
  node.extends.iter().for_each(|node| {
    register_ts_expr_with_type_args(map, node);
  });
  register_ts_interface_body(map, &node.body);
}

fn create_ts_interface_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsInterfaceDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_id = create_ident(env, map, &node.id);
  let declare = node.declare;
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let java_extends = list_new(env, node.extends.len());
  node.extends.iter().for_each(|node| {
    let java_node = create_ts_expr_with_type_args(env, map, node);
    list_add(env, &java_extends, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_body = create_ts_interface_body(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_TS_INTERFACE_DECL.as_ref().unwrap() }
    .construct(env, &java_id, declare, &java_optional_type_params, &java_extends, &java_body, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_extends);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_intersection_type(map: &mut ByteToIndexMap, node: &TsIntersectionType) {
  map.register_by_span(&node.span);
  node.types.iter().for_each(|node| {
    enum_register_ts_type(map, node);
  });
}

fn create_ts_intersection_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsIntersectionType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_types = list_new(env, node.types.len());
  node.types.iter().for_each(|node| {
    let java_node = enum_create_ts_type(env, map, node);
    list_add(env, &java_types, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_INTERSECTION_TYPE.as_ref().unwrap() }
    .construct(env, &java_types, &java_span_ex);
  delete_local_ref!(env, java_types);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_keyword_type(map: &mut ByteToIndexMap, node: &TsKeywordType) {
  map.register_by_span(&node.span);
}

fn create_ts_keyword_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsKeywordType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_kind = node.kind.to_java(env);
  let return_value = unsafe { JAVA_CLASS_TS_KEYWORD_TYPE.as_ref().unwrap() }
    .construct(env, &java_kind, &java_span_ex);
  delete_local_ref!(env, java_kind);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_lit_type(map: &mut ByteToIndexMap, node: &TsLitType) {
  map.register_by_span(&node.span);
  enum_register_ts_lit(map, &node.lit);
}

fn create_ts_lit_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsLitType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_lit = enum_create_ts_lit(env, map, &node.lit);
  let return_value = unsafe { JAVA_CLASS_TS_LIT_TYPE.as_ref().unwrap() }
    .construct(env, &java_lit, &java_span_ex);
  delete_local_ref!(env, java_lit);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_mapped_type(map: &mut ByteToIndexMap, node: &TsMappedType) {
  map.register_by_span(&node.span);
  register_ts_type_param(map, &node.type_param);
  node.name_type.as_ref().map(|node| enum_register_ts_type(map, node));
  node.type_ann.as_ref().map(|node| enum_register_ts_type(map, node));
}

fn create_ts_mapped_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsMappedType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_optional_readonly = node.readonly.as_ref().map(|node| node.to_java(env));
  let java_type_param = create_ts_type_param(env, map, &node.type_param);
  let java_optional_name_type = node.name_type.as_ref().map(|node| enum_create_ts_type(env, map, node));
  let java_optional_optional = node.optional.as_ref().map(|node| node.to_java(env));
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| enum_create_ts_type(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_MAPPED_TYPE.as_ref().unwrap() }
    .construct(env, &java_optional_readonly, &java_type_param, &java_optional_name_type, &java_optional_optional, &java_optional_type_ann, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_readonly);
  delete_local_optional_ref!(env, java_optional_name_type);
  delete_local_optional_ref!(env, java_optional_optional);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_ref!(env, java_type_param);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_method_signature(map: &mut ByteToIndexMap, node: &TsMethodSignature) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.key);
  node.params.iter().for_each(|node| {
    enum_register_ts_fn_param(map, node);
  });
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
}

fn create_ts_method_signature<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsMethodSignature) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let readonly = node.readonly;
  let java_key = enum_create_expr(env, map, &node.key);
  let computed = node.computed;
  let optional = node.optional;
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_ts_fn_param(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_METHOD_SIGNATURE.as_ref().unwrap() }
    .construct(env, readonly, &java_key, computed, optional, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_module_block(map: &mut ByteToIndexMap, node: &TsModuleBlock) {
  map.register_by_span(&node.span);
  node.body.iter().for_each(|node| {
    enum_register_module_item(map, node);
  });
}

fn create_ts_module_block<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsModuleBlock) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_body = list_new(env, node.body.len());
  node.body.iter().for_each(|node| {
    let java_node = enum_create_module_item(env, map, node);
    list_add(env, &java_body, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_MODULE_BLOCK.as_ref().unwrap() }
    .construct(env, &java_body, &java_span_ex);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_module_decl(map: &mut ByteToIndexMap, node: &TsModuleDecl) {
  map.register_by_span(&node.span);
  enum_register_ts_module_name(map, &node.id);
  node.body.as_ref().map(|node| enum_register_ts_namespace_body(map, node));
}

fn create_ts_module_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsModuleDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let declare = node.declare;
  let global = node.global;
  let java_id = enum_create_ts_module_name(env, map, &node.id);
  let java_optional_body = node.body.as_ref().map(|node| enum_create_ts_namespace_body(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_MODULE_DECL.as_ref().unwrap() }
    .construct(env, declare, global, &java_id, &java_optional_body, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_body);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_namespace_decl(map: &mut ByteToIndexMap, node: &TsNamespaceDecl) {
  map.register_by_span(&node.span);
  register_ident(map, &node.id);
  enum_register_ts_namespace_body(map, &node.body);
}

fn create_ts_namespace_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsNamespaceDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let declare = node.declare;
  let global = node.global;
  let java_id = create_ident(env, map, &node.id);
  let java_body = enum_create_ts_namespace_body(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_TS_NAMESPACE_DECL.as_ref().unwrap() }
    .construct(env, declare, global, &java_id, &java_body, &java_span_ex);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_namespace_export_decl(map: &mut ByteToIndexMap, node: &TsNamespaceExportDecl) {
  map.register_by_span(&node.span);
  register_ident(map, &node.id);
}

fn create_ts_namespace_export_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsNamespaceExportDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_id = create_ident(env, map, &node.id);
  let return_value = unsafe { JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL.as_ref().unwrap() }
    .construct(env, &java_id, &java_span_ex);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_non_null_expr(map: &mut ByteToIndexMap, node: &TsNonNullExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
}

fn create_ts_non_null_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsNonNullExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let return_value = unsafe { JAVA_CLASS_TS_NON_NULL_EXPR.as_ref().unwrap() }
    .construct(env, &java_expr, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_optional_type(map: &mut ByteToIndexMap, node: &TsOptionalType) {
  map.register_by_span(&node.span);
  enum_register_ts_type(map, &node.type_ann);
}

fn create_ts_optional_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsOptionalType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_type_ann = enum_create_ts_type(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_OPTIONAL_TYPE.as_ref().unwrap() }
    .construct(env, &java_type_ann, &java_span_ex);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_param_prop(map: &mut ByteToIndexMap, node: &TsParamProp) {
  map.register_by_span(&node.span);
  node.decorators.iter().for_each(|node| {
    register_decorator(map, node);
  });
  enum_register_ts_param_prop_param(map, &node.param);
}

fn create_ts_param_prop<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsParamProp) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_decorators = list_new(env, node.decorators.len());
  node.decorators.iter().for_each(|node| {
    let java_node = create_decorator(env, map, node);
    list_add(env, &java_decorators, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_accessibility = node.accessibility.as_ref().map(|node| node.to_java(env));
  let is_override = node.is_override;
  let readonly = node.readonly;
  let java_param = enum_create_ts_param_prop_param(env, map, &node.param);
  let return_value = unsafe { JAVA_CLASS_TS_PARAM_PROP.as_ref().unwrap() }
    .construct(env, &java_decorators, &java_optional_accessibility, is_override, readonly, &java_param, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_accessibility);
  delete_local_ref!(env, java_decorators);
  delete_local_ref!(env, java_param);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_parenthesized_type(map: &mut ByteToIndexMap, node: &TsParenthesizedType) {
  map.register_by_span(&node.span);
  enum_register_ts_type(map, &node.type_ann);
}

fn create_ts_parenthesized_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsParenthesizedType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_type_ann = enum_create_ts_type(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_PARENTHESIZED_TYPE.as_ref().unwrap() }
    .construct(env, &java_type_ann, &java_span_ex);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_property_signature(map: &mut ByteToIndexMap, node: &TsPropertySignature) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.key);
  node.init.as_ref().map(|node| enum_register_expr(map, node));
  node.params.iter().for_each(|node| {
    enum_register_ts_fn_param(map, node);
  });
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
}

fn create_ts_property_signature<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsPropertySignature) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let readonly = node.readonly;
  let java_key = enum_create_expr(env, map, &node.key);
  let computed = node.computed;
  let optional = node.optional;
  let java_optional_init = node.init.as_ref().map(|node| enum_create_expr(env, map, node));
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_ts_fn_param(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_PROPERTY_SIGNATURE.as_ref().unwrap() }
    .construct(env, readonly, &java_key, computed, optional, &java_optional_init, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_init);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_qualified_name(map: &mut ByteToIndexMap, node: &TsQualifiedName) {
  map.register_by_span(&node.span());
  enum_register_ts_entity_name(map, &node.left);
  register_ident(map, &node.right);
}

fn create_ts_qualified_name<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsQualifiedName) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span()).to_java(env);
  let java_left = enum_create_ts_entity_name(env, map, &node.left);
  let java_right = create_ident(env, map, &node.right);
  let return_value = unsafe { JAVA_CLASS_TS_QUALIFIED_NAME.as_ref().unwrap() }
    .construct(env, &java_left, &java_right, &java_span_ex);
  delete_local_ref!(env, java_left);
  delete_local_ref!(env, java_right);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_rest_type(map: &mut ByteToIndexMap, node: &TsRestType) {
  map.register_by_span(&node.span);
  enum_register_ts_type(map, &node.type_ann);
}

fn create_ts_rest_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsRestType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_type_ann = enum_create_ts_type(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_REST_TYPE.as_ref().unwrap() }
    .construct(env, &java_type_ann, &java_span_ex);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_satisfies_expr(map: &mut ByteToIndexMap, node: &TsSatisfiesExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
  enum_register_ts_type(map, &node.type_ann);
}

fn create_ts_satisfies_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsSatisfiesExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let java_type_ann = enum_create_ts_type(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_SATISFIES_EXPR.as_ref().unwrap() }
    .construct(env, &java_expr, &java_type_ann, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_setter_signature(map: &mut ByteToIndexMap, node: &TsSetterSignature) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.key);
  enum_register_ts_fn_param(map, &node.param);
}

fn create_ts_setter_signature<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsSetterSignature) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let readonly = node.readonly;
  let java_key = enum_create_expr(env, map, &node.key);
  let computed = node.computed;
  let optional = node.optional;
  let java_param = enum_create_ts_fn_param(env, map, &node.param);
  let return_value = unsafe { JAVA_CLASS_TS_SETTER_SIGNATURE.as_ref().unwrap() }
    .construct(env, readonly, &java_key, computed, optional, &java_param, &java_span_ex);
  delete_local_ref!(env, java_key);
  delete_local_ref!(env, java_param);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_this_type(map: &mut ByteToIndexMap, node: &TsThisType) {
  map.register_by_span(&node.span);
}

fn create_ts_this_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsThisType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let return_value = unsafe { JAVA_CLASS_TS_THIS_TYPE.as_ref().unwrap() }
    .construct(env, &java_span_ex);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_tpl_lit_type(map: &mut ByteToIndexMap, node: &TsTplLitType) {
  map.register_by_span(&node.span);
  node.types.iter().for_each(|node| {
    enum_register_ts_type(map, node);
  });
  node.quasis.iter().for_each(|node| {
    register_tpl_element(map, node);
  });
}

fn create_ts_tpl_lit_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTplLitType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_types = list_new(env, node.types.len());
  node.types.iter().for_each(|node| {
    let java_node = enum_create_ts_type(env, map, node);
    list_add(env, &java_types, &java_node);
    delete_local_ref!(env, java_node);
  });
  let java_quasis = list_new(env, node.quasis.len());
  node.quasis.iter().for_each(|node| {
    let java_node = create_tpl_element(env, map, node);
    list_add(env, &java_quasis, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_TPL_LIT_TYPE.as_ref().unwrap() }
    .construct(env, &java_types, &java_quasis, &java_span_ex);
  delete_local_ref!(env, java_types);
  delete_local_ref!(env, java_quasis);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_tuple_element(map: &mut ByteToIndexMap, node: &TsTupleElement) {
  map.register_by_span(&node.span);
  node.label.as_ref().map(|node| enum_register_pat(map, node));
  enum_register_ts_type(map, &node.ty);
}

fn create_ts_tuple_element<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTupleElement) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_optional_label = node.label.as_ref().map(|node| enum_create_pat(env, map, node));
  let java_ty = enum_create_ts_type(env, map, &node.ty);
  let return_value = unsafe { JAVA_CLASS_TS_TUPLE_ELEMENT.as_ref().unwrap() }
    .construct(env, &java_optional_label, &java_ty, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_label);
  delete_local_ref!(env, java_ty);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_tuple_type(map: &mut ByteToIndexMap, node: &TsTupleType) {
  map.register_by_span(&node.span);
  node.elem_types.iter().for_each(|node| {
    register_ts_tuple_element(map, node);
  });
}

fn create_ts_tuple_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTupleType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_elem_types = list_new(env, node.elem_types.len());
  node.elem_types.iter().for_each(|node| {
    let java_node = create_ts_tuple_element(env, map, node);
    list_add(env, &java_elem_types, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_TUPLE_TYPE.as_ref().unwrap() }
    .construct(env, &java_elem_types, &java_span_ex);
  delete_local_ref!(env, java_elem_types);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_alias_decl(map: &mut ByteToIndexMap, node: &TsTypeAliasDecl) {
  map.register_by_span(&node.span);
  register_ident(map, &node.id);
  node.type_params.as_ref().map(|node| register_ts_type_param_decl(map, node));
  enum_register_ts_type(map, &node.type_ann);
}

fn create_ts_type_alias_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeAliasDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_id = create_ident(env, map, &node.id);
  let declare = node.declare;
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_decl(env, map, node));
  let java_type_ann = enum_create_ts_type(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_ALIAS_DECL.as_ref().unwrap() }
    .construct(env, &java_id, declare, &java_optional_type_params, &java_type_ann, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_id);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_ann(map: &mut ByteToIndexMap, node: &TsTypeAnn) {
  map.register_by_span(&node.span);
  enum_register_ts_type(map, &node.type_ann);
}

fn create_ts_type_ann<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeAnn) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_type_ann = enum_create_ts_type(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_ANN.as_ref().unwrap() }
    .construct(env, &java_type_ann, &java_span_ex);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_assertion(map: &mut ByteToIndexMap, node: &TsTypeAssertion) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.expr);
  enum_register_ts_type(map, &node.type_ann);
}

fn create_ts_type_assertion<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeAssertion) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr = enum_create_expr(env, map, &node.expr);
  let java_type_ann = enum_create_ts_type(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_ASSERTION.as_ref().unwrap() }
    .construct(env, &java_expr, &java_type_ann, &java_span_ex);
  delete_local_ref!(env, java_expr);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_lit(map: &mut ByteToIndexMap, node: &TsTypeLit) {
  map.register_by_span(&node.span);
  node.members.iter().for_each(|node| {
    enum_register_ts_type_element(map, node);
  });
}

fn create_ts_type_lit<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeLit) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_members = list_new(env, node.members.len());
  node.members.iter().for_each(|node| {
    let java_node = enum_create_ts_type_element(env, map, node);
    list_add(env, &java_members, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_LIT.as_ref().unwrap() }
    .construct(env, &java_members, &java_span_ex);
  delete_local_ref!(env, java_members);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_operator(map: &mut ByteToIndexMap, node: &TsTypeOperator) {
  map.register_by_span(&node.span);
  enum_register_ts_type(map, &node.type_ann);
}

fn create_ts_type_operator<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeOperator) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_op = node.op.to_java(env);
  let java_type_ann = enum_create_ts_type(env, map, &node.type_ann);
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_OPERATOR.as_ref().unwrap() }
    .construct(env, &java_op, &java_type_ann, &java_span_ex);
  delete_local_ref!(env, java_op);
  delete_local_ref!(env, java_type_ann);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_param(map: &mut ByteToIndexMap, node: &TsTypeParam) {
  map.register_by_span(&node.span);
  register_ident(map, &node.name);
  node.constraint.as_ref().map(|node| enum_register_ts_type(map, node));
  node.default.as_ref().map(|node| enum_register_ts_type(map, node));
}

fn create_ts_type_param<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeParam) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_name = create_ident(env, map, &node.name);
  let is_in = node.is_in;
  let is_out = node.is_out;
  let is_const = node.is_const;
  let java_optional_constraint = node.constraint.as_ref().map(|node| enum_create_ts_type(env, map, node));
  let java_optional_default = node.default.as_ref().map(|node| enum_create_ts_type(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_PARAM.as_ref().unwrap() }
    .construct(env, &java_name, is_in, is_out, is_const, &java_optional_constraint, &java_optional_default, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_constraint);
  delete_local_optional_ref!(env, java_optional_default);
  delete_local_ref!(env, java_name);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_param_decl(map: &mut ByteToIndexMap, node: &TsTypeParamDecl) {
  map.register_by_span(&node.span);
  node.params.iter().for_each(|node| {
    register_ts_type_param(map, node);
  });
}

fn create_ts_type_param_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeParamDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = create_ts_type_param(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_PARAM_DECL.as_ref().unwrap() }
    .construct(env, &java_params, &java_span_ex);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_param_instantiation(map: &mut ByteToIndexMap, node: &TsTypeParamInstantiation) {
  map.register_by_span(&node.span);
  node.params.iter().for_each(|node| {
    enum_register_ts_type(map, node);
  });
}

fn create_ts_type_param_instantiation<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeParamInstantiation) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_params = list_new(env, node.params.len());
  node.params.iter().for_each(|node| {
    let java_node = enum_create_ts_type(env, map, node);
    list_add(env, &java_params, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION.as_ref().unwrap() }
    .construct(env, &java_params, &java_span_ex);
  delete_local_ref!(env, java_params);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_predicate(map: &mut ByteToIndexMap, node: &TsTypePredicate) {
  map.register_by_span(&node.span);
  enum_register_ts_this_type_or_ident(map, &node.param_name);
  node.type_ann.as_ref().map(|node| register_ts_type_ann(map, node));
}

fn create_ts_type_predicate<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypePredicate) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let asserts = node.asserts;
  let java_param_name = enum_create_ts_this_type_or_ident(env, map, &node.param_name);
  let java_optional_type_ann = node.type_ann.as_ref().map(|node| create_ts_type_ann(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_PREDICATE.as_ref().unwrap() }
    .construct(env, asserts, &java_param_name, &java_optional_type_ann, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_ann);
  delete_local_ref!(env, java_param_name);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_query(map: &mut ByteToIndexMap, node: &TsTypeQuery) {
  map.register_by_span(&node.span);
  enum_register_ts_type_query_expr(map, &node.expr_name);
  node.type_args.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
}

fn create_ts_type_query<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeQuery) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_expr_name = enum_create_ts_type_query_expr(env, map, &node.expr_name);
  let java_optional_type_args = node.type_args.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_QUERY.as_ref().unwrap() }
    .construct(env, &java_expr_name, &java_optional_type_args, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_args);
  delete_local_ref!(env, java_expr_name);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_type_ref(map: &mut ByteToIndexMap, node: &TsTypeRef) {
  map.register_by_span(&node.span);
  enum_register_ts_entity_name(map, &node.type_name);
  node.type_params.as_ref().map(|node| register_ts_type_param_instantiation(map, node));
}

fn create_ts_type_ref<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsTypeRef) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_type_name = enum_create_ts_entity_name(env, map, &node.type_name);
  let java_optional_type_params = node.type_params.as_ref().map(|node| create_ts_type_param_instantiation(env, map, node));
  let return_value = unsafe { JAVA_CLASS_TS_TYPE_REF.as_ref().unwrap() }
    .construct(env, &java_type_name, &java_optional_type_params, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_type_params);
  delete_local_ref!(env, java_type_name);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_ts_union_type(map: &mut ByteToIndexMap, node: &TsUnionType) {
  map.register_by_span(&node.span);
  node.types.iter().for_each(|node| {
    enum_register_ts_type(map, node);
  });
}

fn create_ts_union_type<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &TsUnionType) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_types = list_new(env, node.types.len());
  node.types.iter().for_each(|node| {
    let java_node = enum_create_ts_type(env, map, node);
    list_add(env, &java_types, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_TS_UNION_TYPE.as_ref().unwrap() }
    .construct(env, &java_types, &java_span_ex);
  delete_local_ref!(env, java_types);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_unary_expr(map: &mut ByteToIndexMap, node: &UnaryExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.arg);
}

fn create_unary_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &UnaryExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_op = node.op.to_java(env);
  let java_arg = enum_create_expr(env, map, &node.arg);
  let return_value = unsafe { JAVA_CLASS_UNARY_EXPR.as_ref().unwrap() }
    .construct(env, &java_op, &java_arg, &java_span_ex);
  delete_local_ref!(env, java_op);
  delete_local_ref!(env, java_arg);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_update_expr(map: &mut ByteToIndexMap, node: &UpdateExpr) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.arg);
}

fn create_update_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &UpdateExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_op = node.op.to_java(env);
  let prefix = node.prefix;
  let java_arg = enum_create_expr(env, map, &node.arg);
  let return_value = unsafe { JAVA_CLASS_UPDATE_EXPR.as_ref().unwrap() }
    .construct(env, &java_op, prefix, &java_arg, &java_span_ex);
  delete_local_ref!(env, java_op);
  delete_local_ref!(env, java_arg);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_using_decl(map: &mut ByteToIndexMap, node: &UsingDecl) {
  map.register_by_span(&node.span);
  node.decls.iter().for_each(|node| {
    register_var_declarator(map, node);
  });
}

fn create_using_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &UsingDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let is_await = node.is_await;
  let java_decls = list_new(env, node.decls.len());
  node.decls.iter().for_each(|node| {
    let java_node = create_var_declarator(env, map, node);
    list_add(env, &java_decls, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_USING_DECL.as_ref().unwrap() }
    .construct(env, is_await, &java_decls, &java_span_ex);
  delete_local_ref!(env, java_decls);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_var_decl(map: &mut ByteToIndexMap, node: &VarDecl) {
  map.register_by_span(&node.span);
  node.decls.iter().for_each(|node| {
    register_var_declarator(map, node);
  });
}

fn create_var_decl<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &VarDecl) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_kind = node.kind.to_java(env);
  let declare = node.declare;
  let java_decls = list_new(env, node.decls.len());
  node.decls.iter().for_each(|node| {
    let java_node = create_var_declarator(env, map, node);
    list_add(env, &java_decls, &java_node);
    delete_local_ref!(env, java_node);
  });
  let return_value = unsafe { JAVA_CLASS_VAR_DECL.as_ref().unwrap() }
    .construct(env, &java_kind, declare, &java_decls, &java_span_ex);
  delete_local_ref!(env, java_kind);
  delete_local_ref!(env, java_decls);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_var_declarator(map: &mut ByteToIndexMap, node: &VarDeclarator) {
  map.register_by_span(&node.span);
  enum_register_pat(map, &node.name);
  node.init.as_ref().map(|node| enum_register_expr(map, node));
}

fn create_var_declarator<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &VarDeclarator) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_name = enum_create_pat(env, map, &node.name);
  let java_optional_init = node.init.as_ref().map(|node| enum_create_expr(env, map, node));
  let definite = node.definite;
  let return_value = unsafe { JAVA_CLASS_VAR_DECLARATOR.as_ref().unwrap() }
    .construct(env, &java_name, &java_optional_init, definite, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_init);
  delete_local_ref!(env, java_name);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_while_stmt(map: &mut ByteToIndexMap, node: &WhileStmt) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.test);
  enum_register_stmt(map, &node.body);
}

fn create_while_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &WhileStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_test = enum_create_expr(env, map, &node.test);
  let java_body = enum_create_stmt(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_WHILE_STMT.as_ref().unwrap() }
    .construct(env, &java_test, &java_body, &java_span_ex);
  delete_local_ref!(env, java_test);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_with_stmt(map: &mut ByteToIndexMap, node: &WithStmt) {
  map.register_by_span(&node.span);
  enum_register_expr(map, &node.obj);
  enum_register_stmt(map, &node.body);
}

fn create_with_stmt<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &WithStmt) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_obj = enum_create_expr(env, map, &node.obj);
  let java_body = enum_create_stmt(env, map, &node.body);
  let return_value = unsafe { JAVA_CLASS_WITH_STMT.as_ref().unwrap() }
    .construct(env, &java_obj, &java_body, &java_span_ex);
  delete_local_ref!(env, java_obj);
  delete_local_ref!(env, java_body);
  delete_local_ref!(env, java_span_ex);
  return_value
}

fn register_yield_expr(map: &mut ByteToIndexMap, node: &YieldExpr) {
  map.register_by_span(&node.span);
  node.arg.as_ref().map(|node| enum_register_expr(map, node));
}

fn create_yield_expr<'local, 'a>(env: &mut JNIEnv<'local>, map: &ByteToIndexMap, node: &YieldExpr) -> JObject<'a>
where
  'local: 'a,
{
  let java_span_ex = map.get_span_ex_by_span(&node.span).to_java(env);
  let java_optional_arg = node.arg.as_ref().map(|node| enum_create_expr(env, map, node));
  let delegate = node.delegate;
  let return_value = unsafe { JAVA_CLASS_YIELD_EXPR.as_ref().unwrap() }
    .construct(env, &java_optional_arg, delegate, &java_span_ex);
  delete_local_optional_ref!(env, java_optional_arg);
  delete_local_ref!(env, java_span_ex);
  return_value
}
/* Node End */
